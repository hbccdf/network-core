/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef map_TYPES_H
#define map_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "struct_types.h"




struct RandomType {
  enum type {
    Random = 0,
    Fixed = 1
  };
};

extern const std::map<int, const char*> _RandomType_VALUES_TO_NAMES;

class BoxCollider;

class ObstacleData;

class PlayerStartData;

class ArenaMonsterData;

class ItemGeneratorData;

class BaseCenterData;

class CreateInMap;

class MapData;

class MapDataConfigTable;

typedef struct _BoxCollider__isset {
  _BoxCollider__isset() : center(false), size(false) {}
  bool center :1;
  bool size :1;
} _BoxCollider__isset;

class BoxCollider : public virtual ::apache::thrift::TBase {
 public:

  BoxCollider(const BoxCollider&);
  BoxCollider& operator=(const BoxCollider&);
  BoxCollider() {
  }

  virtual ~BoxCollider() throw();
   ::TVector3 center;
   ::TVector3 size;

  _BoxCollider__isset __isset;

  void __set_center(const  ::TVector3& val);

  void __set_size(const  ::TVector3& val);

  bool operator == (const BoxCollider & rhs) const
  {
    if (!(center == rhs.center))
      return false;
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const BoxCollider &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BoxCollider & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BoxCollider &a, BoxCollider &b);

inline std::ostream& operator<<(std::ostream& out, const BoxCollider& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ObstacleData__isset {
  _ObstacleData__isset() : id(false), pos(false), rot(false), collider(false) {}
  bool id :1;
  bool pos :1;
  bool rot :1;
  bool collider :1;
} _ObstacleData__isset;

class ObstacleData : public virtual ::apache::thrift::TBase {
 public:

  ObstacleData(const ObstacleData&);
  ObstacleData& operator=(const ObstacleData&);
  ObstacleData() : id(0) {
  }

  virtual ~ObstacleData() throw();
  int32_t id;
   ::TVector3 pos;
   ::TRotation rot;
  BoxCollider collider;

  _ObstacleData__isset __isset;

  void __set_id(const int32_t val);

  void __set_pos(const  ::TVector3& val);

  void __set_rot(const  ::TRotation& val);

  void __set_collider(const BoxCollider& val);

  bool operator == (const ObstacleData & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(pos == rhs.pos))
      return false;
    if (!(rot == rhs.rot))
      return false;
    if (!(collider == rhs.collider))
      return false;
    return true;
  }
  bool operator != (const ObstacleData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ObstacleData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ObstacleData &a, ObstacleData &b);

inline std::ostream& operator<<(std::ostream& out, const ObstacleData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PlayerStartData__isset {
  _PlayerStartData__isset() : id(false), pos(false), fectionType(false) {}
  bool id :1;
  bool pos :1;
  bool fectionType :1;
} _PlayerStartData__isset;

class PlayerStartData : public virtual ::apache::thrift::TBase {
 public:

  PlayerStartData(const PlayerStartData&);
  PlayerStartData& operator=(const PlayerStartData&);
  PlayerStartData() : id(0), fectionType(0) {
  }

  virtual ~PlayerStartData() throw();
  int32_t id;
   ::TVector3 pos;
  int32_t fectionType;

  _PlayerStartData__isset __isset;

  void __set_id(const int32_t val);

  void __set_pos(const  ::TVector3& val);

  void __set_fectionType(const int32_t val);

  bool operator == (const PlayerStartData & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(pos == rhs.pos))
      return false;
    if (!(fectionType == rhs.fectionType))
      return false;
    return true;
  }
  bool operator != (const PlayerStartData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerStartData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PlayerStartData &a, PlayerStartData &b);

inline std::ostream& operator<<(std::ostream& out, const PlayerStartData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ArenaMonsterData__isset {
  _ArenaMonsterData__isset() : id(false), factionId(false), monsterType(false), pos(false), size(false), offset(false) {}
  bool id :1;
  bool factionId :1;
  bool monsterType :1;
  bool pos :1;
  bool size :1;
  bool offset :1;
} _ArenaMonsterData__isset;

class ArenaMonsterData : public virtual ::apache::thrift::TBase {
 public:

  ArenaMonsterData(const ArenaMonsterData&);
  ArenaMonsterData& operator=(const ArenaMonsterData&);
  ArenaMonsterData() : id(0), factionId(0), monsterType(( ::MonsterType::type)0) {
  }

  virtual ~ArenaMonsterData() throw();
  int32_t id;
  int32_t factionId;
   ::MonsterType::type monsterType;
   ::TVector3 pos;
   ::TVector3 size;
   ::TVector3 offset;

  _ArenaMonsterData__isset __isset;

  void __set_id(const int32_t val);

  void __set_factionId(const int32_t val);

  void __set_monsterType(const  ::MonsterType::type val);

  void __set_pos(const  ::TVector3& val);

  void __set_size(const  ::TVector3& val);

  void __set_offset(const  ::TVector3& val);

  bool operator == (const ArenaMonsterData & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(factionId == rhs.factionId))
      return false;
    if (!(monsterType == rhs.monsterType))
      return false;
    if (!(pos == rhs.pos))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(offset == rhs.offset))
      return false;
    return true;
  }
  bool operator != (const ArenaMonsterData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ArenaMonsterData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ArenaMonsterData &a, ArenaMonsterData &b);

inline std::ostream& operator<<(std::ostream& out, const ArenaMonsterData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ItemGeneratorData__isset {
  _ItemGeneratorData__isset() : id(false), dropListId(false), beginDelayTime(false), tickTime(false), count(false), posList(false) {}
  bool id :1;
  bool dropListId :1;
  bool beginDelayTime :1;
  bool tickTime :1;
  bool count :1;
  bool posList :1;
} _ItemGeneratorData__isset;

class ItemGeneratorData : public virtual ::apache::thrift::TBase {
 public:

  ItemGeneratorData(const ItemGeneratorData&);
  ItemGeneratorData& operator=(const ItemGeneratorData&);
  ItemGeneratorData() : id(0), dropListId(0), beginDelayTime(0), tickTime(0), count(0) {
  }

  virtual ~ItemGeneratorData() throw();
  int32_t id;
  int32_t dropListId;
  int32_t beginDelayTime;
  int32_t tickTime;
  int32_t count;
  std::vector< ::TVector3>  posList;

  _ItemGeneratorData__isset __isset;

  void __set_id(const int32_t val);

  void __set_dropListId(const int32_t val);

  void __set_beginDelayTime(const int32_t val);

  void __set_tickTime(const int32_t val);

  void __set_count(const int32_t val);

  void __set_posList(const std::vector< ::TVector3> & val);

  bool operator == (const ItemGeneratorData & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(dropListId == rhs.dropListId))
      return false;
    if (!(beginDelayTime == rhs.beginDelayTime))
      return false;
    if (!(tickTime == rhs.tickTime))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(posList == rhs.posList))
      return false;
    return true;
  }
  bool operator != (const ItemGeneratorData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemGeneratorData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemGeneratorData &a, ItemGeneratorData &b);

inline std::ostream& operator<<(std::ostream& out, const ItemGeneratorData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BaseCenterData__isset {
  _BaseCenterData__isset() : id(false), pos(false), rot(false), collider(false), fectionType(false) {}
  bool id :1;
  bool pos :1;
  bool rot :1;
  bool collider :1;
  bool fectionType :1;
} _BaseCenterData__isset;

class BaseCenterData : public virtual ::apache::thrift::TBase {
 public:

  BaseCenterData(const BaseCenterData&);
  BaseCenterData& operator=(const BaseCenterData&);
  BaseCenterData() : id(0), fectionType(0) {
  }

  virtual ~BaseCenterData() throw();
  int32_t id;
   ::TVector3 pos;
   ::TRotation rot;
  BoxCollider collider;
  int32_t fectionType;

  _BaseCenterData__isset __isset;

  void __set_id(const int32_t val);

  void __set_pos(const  ::TVector3& val);

  void __set_rot(const  ::TRotation& val);

  void __set_collider(const BoxCollider& val);

  void __set_fectionType(const int32_t val);

  bool operator == (const BaseCenterData & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(pos == rhs.pos))
      return false;
    if (!(rot == rhs.rot))
      return false;
    if (!(collider == rhs.collider))
      return false;
    if (!(fectionType == rhs.fectionType))
      return false;
    return true;
  }
  bool operator != (const BaseCenterData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BaseCenterData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BaseCenterData &a, BaseCenterData &b);

inline std::ostream& operator<<(std::ostream& out, const BaseCenterData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CreateInMap__isset {
  _CreateInMap__isset() : id(false), objType(false), randomType(false), pos(false), rot(false), collider(false), factionType(false), dropListId(false), beginDelayTime(false), tickTime(false), count(false), refreshCountOnce(false), posList(false), monsterType(false), magicType(false) {}
  bool id :1;
  bool objType :1;
  bool randomType :1;
  bool pos :1;
  bool rot :1;
  bool collider :1;
  bool factionType :1;
  bool dropListId :1;
  bool beginDelayTime :1;
  bool tickTime :1;
  bool count :1;
  bool refreshCountOnce :1;
  bool posList :1;
  bool monsterType :1;
  bool magicType :1;
} _CreateInMap__isset;

class CreateInMap : public virtual ::apache::thrift::TBase {
 public:

  CreateInMap(const CreateInMap&);
  CreateInMap& operator=(const CreateInMap&);
  CreateInMap() : id(0), objType(( ::ObjType::type)0), randomType((RandomType::type)0), factionType(( ::FactionType::type)0), dropListId(0), beginDelayTime(0), tickTime(0), count(0), refreshCountOnce(0), monsterType(( ::MonsterType::type)0), magicType(( ::MagicType::type)0) {
  }

  virtual ~CreateInMap() throw();
  int32_t id;
   ::ObjType::type objType;
  RandomType::type randomType;
   ::TVector3 pos;
   ::TRotation rot;
  BoxCollider collider;
   ::FactionType::type factionType;
  int32_t dropListId;
  int32_t beginDelayTime;
  int32_t tickTime;
  int32_t count;
  int32_t refreshCountOnce;
  std::vector< ::TVector3>  posList;
   ::MonsterType::type monsterType;
   ::MagicType::type magicType;

  _CreateInMap__isset __isset;

  void __set_id(const int32_t val);

  void __set_objType(const  ::ObjType::type val);

  void __set_randomType(const RandomType::type val);

  void __set_pos(const  ::TVector3& val);

  void __set_rot(const  ::TRotation& val);

  void __set_collider(const BoxCollider& val);

  void __set_factionType(const  ::FactionType::type val);

  void __set_dropListId(const int32_t val);

  void __set_beginDelayTime(const int32_t val);

  void __set_tickTime(const int32_t val);

  void __set_count(const int32_t val);

  void __set_refreshCountOnce(const int32_t val);

  void __set_posList(const std::vector< ::TVector3> & val);

  void __set_monsterType(const  ::MonsterType::type val);

  void __set_magicType(const  ::MagicType::type val);

  bool operator == (const CreateInMap & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(objType == rhs.objType))
      return false;
    if (!(randomType == rhs.randomType))
      return false;
    if (!(pos == rhs.pos))
      return false;
    if (!(rot == rhs.rot))
      return false;
    if (!(collider == rhs.collider))
      return false;
    if (!(factionType == rhs.factionType))
      return false;
    if (!(dropListId == rhs.dropListId))
      return false;
    if (!(beginDelayTime == rhs.beginDelayTime))
      return false;
    if (!(tickTime == rhs.tickTime))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(refreshCountOnce == rhs.refreshCountOnce))
      return false;
    if (!(posList == rhs.posList))
      return false;
    if (!(monsterType == rhs.monsterType))
      return false;
    if (!(magicType == rhs.magicType))
      return false;
    return true;
  }
  bool operator != (const CreateInMap &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreateInMap & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreateInMap &a, CreateInMap &b);

inline std::ostream& operator<<(std::ostream& out, const CreateInMap& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MapData__isset {
  _MapData__isset() : id(false), mapName(false), bounds(false), obstacleList(false), playerStartList(false), baseCenterList(false), monsterList(false), itemGeneratorList(false), modelSize(false), createInMap(false), firstRefreshTime(false) {}
  bool id :1;
  bool mapName :1;
  bool bounds :1;
  bool obstacleList :1;
  bool playerStartList :1;
  bool baseCenterList :1;
  bool monsterList :1;
  bool itemGeneratorList :1;
  bool modelSize :1;
  bool createInMap :1;
  bool firstRefreshTime :1;
} _MapData__isset;

class MapData : public virtual ::apache::thrift::TBase {
 public:

  MapData(const MapData&);
  MapData& operator=(const MapData&);
  MapData() : id(0), mapName(), firstRefreshTime(0) {
  }

  virtual ~MapData() throw();
  int32_t id;
  std::string mapName;
   ::Bounds bounds;
  std::vector<ObstacleData>  obstacleList;
  std::vector<PlayerStartData>  playerStartList;
  std::vector<BaseCenterData>  baseCenterList;
  std::vector<ArenaMonsterData>  monsterList;
  std::vector<ItemGeneratorData>  itemGeneratorList;
  std::map<int32_t,  ::TVector3>  modelSize;
  std::vector<CreateInMap>  createInMap;
  int32_t firstRefreshTime;

  _MapData__isset __isset;

  void __set_id(const int32_t val);

  void __set_mapName(const std::string& val);

  void __set_bounds(const  ::Bounds& val);

  void __set_obstacleList(const std::vector<ObstacleData> & val);

  void __set_playerStartList(const std::vector<PlayerStartData> & val);

  void __set_baseCenterList(const std::vector<BaseCenterData> & val);

  void __set_monsterList(const std::vector<ArenaMonsterData> & val);

  void __set_itemGeneratorList(const std::vector<ItemGeneratorData> & val);

  void __set_modelSize(const std::map<int32_t,  ::TVector3> & val);

  void __set_createInMap(const std::vector<CreateInMap> & val);

  void __set_firstRefreshTime(const int32_t val);

  bool operator == (const MapData & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(mapName == rhs.mapName))
      return false;
    if (!(bounds == rhs.bounds))
      return false;
    if (!(obstacleList == rhs.obstacleList))
      return false;
    if (!(playerStartList == rhs.playerStartList))
      return false;
    if (!(baseCenterList == rhs.baseCenterList))
      return false;
    if (!(monsterList == rhs.monsterList))
      return false;
    if (!(itemGeneratorList == rhs.itemGeneratorList))
      return false;
    if (!(modelSize == rhs.modelSize))
      return false;
    if (!(createInMap == rhs.createInMap))
      return false;
    if (!(firstRefreshTime == rhs.firstRefreshTime))
      return false;
    return true;
  }
  bool operator != (const MapData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MapData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MapData &a, MapData &b);

inline std::ostream& operator<<(std::ostream& out, const MapData& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MapDataConfigTable__isset {
  _MapDataConfigTable__isset() : mapList(false) {}
  bool mapList :1;
} _MapDataConfigTable__isset;

class MapDataConfigTable : public virtual ::apache::thrift::TBase {
 public:

  MapDataConfigTable(const MapDataConfigTable&);
  MapDataConfigTable& operator=(const MapDataConfigTable&);
  MapDataConfigTable() {
  }

  virtual ~MapDataConfigTable() throw();
  std::vector<MapData>  mapList;

  _MapDataConfigTable__isset __isset;

  void __set_mapList(const std::vector<MapData> & val);

  bool operator == (const MapDataConfigTable & rhs) const
  {
    if (!(mapList == rhs.mapList))
      return false;
    return true;
  }
  bool operator != (const MapDataConfigTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MapDataConfigTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MapDataConfigTable &a, MapDataConfigTable &b);

inline std::ostream& operator<<(std::ostream& out, const MapDataConfigTable& obj)
{
  obj.printTo(out);
  return out;
}



#endif
