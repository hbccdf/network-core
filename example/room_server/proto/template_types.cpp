/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "template_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CytxGame {

int _kSkillTypeValues[] = {
  SkillType::NORMAL,
  SkillType::WEAPON
};
const char* _kSkillTypeNames[] = {
  "NORMAL",
  "WEAPON"
};
const std::map<int, const char*> _SkillType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSkillTypeValues, _kSkillTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


PlayerConfigTable::~PlayerConfigTable() throw() {
}


void PlayerConfigTable::__set_id(const int32_t val) {
  this->id = val;
}

void PlayerConfigTable::__set_speed(const int32_t val) {
  this->speed = val;
}

void PlayerConfigTable::__set_moveExpend(const int32_t val) {
  this->moveExpend = val;
}

void PlayerConfigTable::__set_maxHp(const int32_t val) {
  this->maxHp = val;
}

void PlayerConfigTable::__set_deathTime(const int32_t val) {
  this->deathTime = val;
}

void PlayerConfigTable::__set_maxMp(const int32_t val) {
  this->maxMp = val;
}

void PlayerConfigTable::__set_maxInk(const int32_t val) {
  this->maxInk = val;
}

void PlayerConfigTable::__set_inkRecover(const int32_t val) {
  this->inkRecover = val;
}

void PlayerConfigTable::__set_maxBoom(const int32_t val) {
  this->maxBoom = val;
}

void PlayerConfigTable::__set_attackedIntervalTime(const int32_t val) {
  this->attackedIntervalTime = val;
}

void PlayerConfigTable::__set_score(const int32_t val) {
  this->score = val;
}

void PlayerConfigTable::__set_category(const int32_t val) {
  this->category = val;
}

void PlayerConfigTable::__set_comPrefab(const std::string& val) {
  this->comPrefab = val;
}

void PlayerConfigTable::__set_syncHpKey(const int32_t val) {
  this->syncHpKey = val;
}

void PlayerConfigTable::__set_syncMpKey(const int32_t val) {
  this->syncMpKey = val;
}

void PlayerConfigTable::__set_syncDecelerationKey(const int32_t val) {
  this->syncDecelerationKey = val;
}

void PlayerConfigTable::__set_syncRedScoreKey(const int32_t val) {
  this->syncRedScoreKey = val;
}

void PlayerConfigTable::__set_syncBlueScoreKey(const int32_t val) {
  this->syncBlueScoreKey = val;
}

void PlayerConfigTable::__set_syncGreenScoreKey(const int32_t val) {
  this->syncGreenScoreKey = val;
}

void PlayerConfigTable::__set_syncCountDownKey(const int32_t val) {
  this->syncCountDownKey = val;
}

void PlayerConfigTable::__set_syncEnergyOutputKey(const int32_t val) {
  this->syncEnergyOutputKey = val;
}

void PlayerConfigTable::__set_syncRebirthTime(const int32_t val) {
  this->syncRebirthTime = val;
}

void PlayerConfigTable::__set_syncBaseCampState(const int32_t val) {
  this->syncBaseCampState = val;
}

void PlayerConfigTable::__set_syncAttackerKey(const int32_t val) {
  this->syncAttackerKey = val;
}

uint32_t PlayerConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->speed);
          this->__isset.speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->moveExpend);
          this->__isset.moveExpend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHp);
          this->__isset.maxHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deathTime);
          this->__isset.deathTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxMp);
          this->__isset.maxMp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxInk);
          this->__isset.maxInk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->inkRecover);
          this->__isset.inkRecover = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxBoom);
          this->__isset.maxBoom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attackedIntervalTime);
          this->__isset.attackedIntervalTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->score);
          this->__isset.score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 101:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 102:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comPrefab);
          this->__isset.comPrefab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncHpKey);
          this->__isset.syncHpKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncMpKey);
          this->__isset.syncMpKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncDecelerationKey);
          this->__isset.syncDecelerationKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 140:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncRedScoreKey);
          this->__isset.syncRedScoreKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 150:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncBlueScoreKey);
          this->__isset.syncBlueScoreKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 160:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncGreenScoreKey);
          this->__isset.syncGreenScoreKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 170:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncCountDownKey);
          this->__isset.syncCountDownKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 180:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncEnergyOutputKey);
          this->__isset.syncEnergyOutputKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 190:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncRebirthTime);
          this->__isset.syncRebirthTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 200:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncBaseCampState);
          this->__isset.syncBaseCampState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 210:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syncAttackerKey);
          this->__isset.syncAttackerKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlayerConfigTable");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speed", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("moveExpend", ::apache::thrift::protocol::T_I32, 25);
  xfer += oprot->writeI32(this->moveExpend);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxHp", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->maxHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deathTime", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->deathTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxMp", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->maxMp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxInk", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->maxInk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inkRecover", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->inkRecover);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxBoom", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->maxBoom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackedIntervalTime", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->attackedIntervalTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->score);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 101);
  xfer += oprot->writeI32(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comPrefab", ::apache::thrift::protocol::T_STRING, 102);
  xfer += oprot->writeString(this->comPrefab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncHpKey", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->syncHpKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncMpKey", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->syncMpKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncDecelerationKey", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32(this->syncDecelerationKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncRedScoreKey", ::apache::thrift::protocol::T_I32, 140);
  xfer += oprot->writeI32(this->syncRedScoreKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncBlueScoreKey", ::apache::thrift::protocol::T_I32, 150);
  xfer += oprot->writeI32(this->syncBlueScoreKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncGreenScoreKey", ::apache::thrift::protocol::T_I32, 160);
  xfer += oprot->writeI32(this->syncGreenScoreKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncCountDownKey", ::apache::thrift::protocol::T_I32, 170);
  xfer += oprot->writeI32(this->syncCountDownKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncEnergyOutputKey", ::apache::thrift::protocol::T_I32, 180);
  xfer += oprot->writeI32(this->syncEnergyOutputKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncRebirthTime", ::apache::thrift::protocol::T_I32, 190);
  xfer += oprot->writeI32(this->syncRebirthTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncBaseCampState", ::apache::thrift::protocol::T_I32, 200);
  xfer += oprot->writeI32(this->syncBaseCampState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncAttackerKey", ::apache::thrift::protocol::T_I32, 210);
  xfer += oprot->writeI32(this->syncAttackerKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerConfigTable &a, PlayerConfigTable &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.speed, b.speed);
  swap(a.moveExpend, b.moveExpend);
  swap(a.maxHp, b.maxHp);
  swap(a.deathTime, b.deathTime);
  swap(a.maxMp, b.maxMp);
  swap(a.maxInk, b.maxInk);
  swap(a.inkRecover, b.inkRecover);
  swap(a.maxBoom, b.maxBoom);
  swap(a.attackedIntervalTime, b.attackedIntervalTime);
  swap(a.score, b.score);
  swap(a.category, b.category);
  swap(a.comPrefab, b.comPrefab);
  swap(a.syncHpKey, b.syncHpKey);
  swap(a.syncMpKey, b.syncMpKey);
  swap(a.syncDecelerationKey, b.syncDecelerationKey);
  swap(a.syncRedScoreKey, b.syncRedScoreKey);
  swap(a.syncBlueScoreKey, b.syncBlueScoreKey);
  swap(a.syncGreenScoreKey, b.syncGreenScoreKey);
  swap(a.syncCountDownKey, b.syncCountDownKey);
  swap(a.syncEnergyOutputKey, b.syncEnergyOutputKey);
  swap(a.syncRebirthTime, b.syncRebirthTime);
  swap(a.syncBaseCampState, b.syncBaseCampState);
  swap(a.syncAttackerKey, b.syncAttackerKey);
  swap(a.__isset, b.__isset);
}

PlayerConfigTable::PlayerConfigTable(const PlayerConfigTable& other0) {
  id = other0.id;
  speed = other0.speed;
  moveExpend = other0.moveExpend;
  maxHp = other0.maxHp;
  deathTime = other0.deathTime;
  maxMp = other0.maxMp;
  maxInk = other0.maxInk;
  inkRecover = other0.inkRecover;
  maxBoom = other0.maxBoom;
  attackedIntervalTime = other0.attackedIntervalTime;
  score = other0.score;
  category = other0.category;
  comPrefab = other0.comPrefab;
  syncHpKey = other0.syncHpKey;
  syncMpKey = other0.syncMpKey;
  syncDecelerationKey = other0.syncDecelerationKey;
  syncRedScoreKey = other0.syncRedScoreKey;
  syncBlueScoreKey = other0.syncBlueScoreKey;
  syncGreenScoreKey = other0.syncGreenScoreKey;
  syncCountDownKey = other0.syncCountDownKey;
  syncEnergyOutputKey = other0.syncEnergyOutputKey;
  syncRebirthTime = other0.syncRebirthTime;
  syncBaseCampState = other0.syncBaseCampState;
  syncAttackerKey = other0.syncAttackerKey;
  __isset = other0.__isset;
}
PlayerConfigTable& PlayerConfigTable::operator=(const PlayerConfigTable& other1) {
  id = other1.id;
  speed = other1.speed;
  moveExpend = other1.moveExpend;
  maxHp = other1.maxHp;
  deathTime = other1.deathTime;
  maxMp = other1.maxMp;
  maxInk = other1.maxInk;
  inkRecover = other1.inkRecover;
  maxBoom = other1.maxBoom;
  attackedIntervalTime = other1.attackedIntervalTime;
  score = other1.score;
  category = other1.category;
  comPrefab = other1.comPrefab;
  syncHpKey = other1.syncHpKey;
  syncMpKey = other1.syncMpKey;
  syncDecelerationKey = other1.syncDecelerationKey;
  syncRedScoreKey = other1.syncRedScoreKey;
  syncBlueScoreKey = other1.syncBlueScoreKey;
  syncGreenScoreKey = other1.syncGreenScoreKey;
  syncCountDownKey = other1.syncCountDownKey;
  syncEnergyOutputKey = other1.syncEnergyOutputKey;
  syncRebirthTime = other1.syncRebirthTime;
  syncBaseCampState = other1.syncBaseCampState;
  syncAttackerKey = other1.syncAttackerKey;
  __isset = other1.__isset;
  return *this;
}
void PlayerConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlayerConfigTable(";
  out << "id=" << to_string(id);
  out << ", " << "speed=" << to_string(speed);
  out << ", " << "moveExpend=" << to_string(moveExpend);
  out << ", " << "maxHp=" << to_string(maxHp);
  out << ", " << "deathTime=" << to_string(deathTime);
  out << ", " << "maxMp=" << to_string(maxMp);
  out << ", " << "maxInk=" << to_string(maxInk);
  out << ", " << "inkRecover=" << to_string(inkRecover);
  out << ", " << "maxBoom=" << to_string(maxBoom);
  out << ", " << "attackedIntervalTime=" << to_string(attackedIntervalTime);
  out << ", " << "score=" << to_string(score);
  out << ", " << "category=" << to_string(category);
  out << ", " << "comPrefab=" << to_string(comPrefab);
  out << ", " << "syncHpKey=" << to_string(syncHpKey);
  out << ", " << "syncMpKey=" << to_string(syncMpKey);
  out << ", " << "syncDecelerationKey=" << to_string(syncDecelerationKey);
  out << ", " << "syncRedScoreKey=" << to_string(syncRedScoreKey);
  out << ", " << "syncBlueScoreKey=" << to_string(syncBlueScoreKey);
  out << ", " << "syncGreenScoreKey=" << to_string(syncGreenScoreKey);
  out << ", " << "syncCountDownKey=" << to_string(syncCountDownKey);
  out << ", " << "syncEnergyOutputKey=" << to_string(syncEnergyOutputKey);
  out << ", " << "syncRebirthTime=" << to_string(syncRebirthTime);
  out << ", " << "syncBaseCampState=" << to_string(syncBaseCampState);
  out << ", " << "syncAttackerKey=" << to_string(syncAttackerKey);
  out << ")";
}


LineSelfConfigTable::~LineSelfConfigTable() throw() {
}


void LineSelfConfigTable::__set_delayTime(const double val) {
  this->delayTime = val;
}

void LineSelfConfigTable::__set_deathUnit(const int32_t val) {
  this->deathUnit = val;
}

void LineSelfConfigTable::__set_cutUnit(const int32_t val) {
  this->cutUnit = val;
}

void LineSelfConfigTable::__set_lineRadius(const double val) {
  this->lineRadius = val;
}

void LineSelfConfigTable::__set_pointDistance(const double val) {
  this->pointDistance = val;
}

void LineSelfConfigTable::__set_captureMinTime(const double val) {
  this->captureMinTime = val;
}

void LineSelfConfigTable::__set_captureMinRadius(const double val) {
  this->captureMinRadius = val;
}

void LineSelfConfigTable::__set_captureMaxTime(const double val) {
  this->captureMaxTime = val;
}

void LineSelfConfigTable::__set_captureMaxRadius(const double val) {
  this->captureMaxRadius = val;
}

void LineSelfConfigTable::__set_attenRadio(const double val) {
  this->attenRadio = val;
}

void LineSelfConfigTable::__set_bufferTime(const double val) {
  this->bufferTime = val;
}

void LineSelfConfigTable::__set_decelerate(const double val) {
  this->decelerate = val;
}

void LineSelfConfigTable::__set_expend(const int32_t val) {
  this->expend = val;
}

uint32_t LineSelfConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->delayTime);
          this->__isset.delayTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deathUnit);
          this->__isset.deathUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cutUnit);
          this->__isset.cutUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lineRadius);
          this->__isset.lineRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pointDistance);
          this->__isset.pointDistance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->captureMinTime);
          this->__isset.captureMinTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->captureMinRadius);
          this->__isset.captureMinRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->captureMaxTime);
          this->__isset.captureMaxTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->captureMaxRadius);
          this->__isset.captureMaxRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->attenRadio);
          this->__isset.attenRadio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->bufferTime);
          this->__isset.bufferTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->decelerate);
          this->__isset.decelerate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expend);
          this->__isset.expend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LineSelfConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LineSelfConfigTable");

  xfer += oprot->writeFieldBegin("delayTime", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->delayTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deathUnit", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->deathUnit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cutUnit", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->cutUnit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lineRadius", ::apache::thrift::protocol::T_DOUBLE, 40);
  xfer += oprot->writeDouble(this->lineRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pointDistance", ::apache::thrift::protocol::T_DOUBLE, 50);
  xfer += oprot->writeDouble(this->pointDistance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("captureMinTime", ::apache::thrift::protocol::T_DOUBLE, 60);
  xfer += oprot->writeDouble(this->captureMinTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("captureMinRadius", ::apache::thrift::protocol::T_DOUBLE, 70);
  xfer += oprot->writeDouble(this->captureMinRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("captureMaxTime", ::apache::thrift::protocol::T_DOUBLE, 80);
  xfer += oprot->writeDouble(this->captureMaxTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("captureMaxRadius", ::apache::thrift::protocol::T_DOUBLE, 90);
  xfer += oprot->writeDouble(this->captureMaxRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attenRadio", ::apache::thrift::protocol::T_DOUBLE, 100);
  xfer += oprot->writeDouble(this->attenRadio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bufferTime", ::apache::thrift::protocol::T_DOUBLE, 110);
  xfer += oprot->writeDouble(this->bufferTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("decelerate", ::apache::thrift::protocol::T_DOUBLE, 120);
  xfer += oprot->writeDouble(this->decelerate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expend", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32(this->expend);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LineSelfConfigTable &a, LineSelfConfigTable &b) {
  using ::std::swap;
  swap(a.delayTime, b.delayTime);
  swap(a.deathUnit, b.deathUnit);
  swap(a.cutUnit, b.cutUnit);
  swap(a.lineRadius, b.lineRadius);
  swap(a.pointDistance, b.pointDistance);
  swap(a.captureMinTime, b.captureMinTime);
  swap(a.captureMinRadius, b.captureMinRadius);
  swap(a.captureMaxTime, b.captureMaxTime);
  swap(a.captureMaxRadius, b.captureMaxRadius);
  swap(a.attenRadio, b.attenRadio);
  swap(a.bufferTime, b.bufferTime);
  swap(a.decelerate, b.decelerate);
  swap(a.expend, b.expend);
  swap(a.__isset, b.__isset);
}

LineSelfConfigTable::LineSelfConfigTable(const LineSelfConfigTable& other2) {
  delayTime = other2.delayTime;
  deathUnit = other2.deathUnit;
  cutUnit = other2.cutUnit;
  lineRadius = other2.lineRadius;
  pointDistance = other2.pointDistance;
  captureMinTime = other2.captureMinTime;
  captureMinRadius = other2.captureMinRadius;
  captureMaxTime = other2.captureMaxTime;
  captureMaxRadius = other2.captureMaxRadius;
  attenRadio = other2.attenRadio;
  bufferTime = other2.bufferTime;
  decelerate = other2.decelerate;
  expend = other2.expend;
  __isset = other2.__isset;
}
LineSelfConfigTable& LineSelfConfigTable::operator=(const LineSelfConfigTable& other3) {
  delayTime = other3.delayTime;
  deathUnit = other3.deathUnit;
  cutUnit = other3.cutUnit;
  lineRadius = other3.lineRadius;
  pointDistance = other3.pointDistance;
  captureMinTime = other3.captureMinTime;
  captureMinRadius = other3.captureMinRadius;
  captureMaxTime = other3.captureMaxTime;
  captureMaxRadius = other3.captureMaxRadius;
  attenRadio = other3.attenRadio;
  bufferTime = other3.bufferTime;
  decelerate = other3.decelerate;
  expend = other3.expend;
  __isset = other3.__isset;
  return *this;
}
void LineSelfConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LineSelfConfigTable(";
  out << "delayTime=" << to_string(delayTime);
  out << ", " << "deathUnit=" << to_string(deathUnit);
  out << ", " << "cutUnit=" << to_string(cutUnit);
  out << ", " << "lineRadius=" << to_string(lineRadius);
  out << ", " << "pointDistance=" << to_string(pointDistance);
  out << ", " << "captureMinTime=" << to_string(captureMinTime);
  out << ", " << "captureMinRadius=" << to_string(captureMinRadius);
  out << ", " << "captureMaxTime=" << to_string(captureMaxTime);
  out << ", " << "captureMaxRadius=" << to_string(captureMaxRadius);
  out << ", " << "attenRadio=" << to_string(attenRadio);
  out << ", " << "bufferTime=" << to_string(bufferTime);
  out << ", " << "decelerate=" << to_string(decelerate);
  out << ", " << "expend=" << to_string(expend);
  out << ")";
}


EnergyOutputConfig::~EnergyOutputConfig() throw() {
}


void EnergyOutputConfig::__set_id(const int32_t val) {
  this->id = val;
}

void EnergyOutputConfig::__set_energy(const int32_t val) {
  this->energy = val;
}

uint32_t EnergyOutputConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->energy);
          this->__isset.energy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnergyOutputConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnergyOutputConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("energy", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->energy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnergyOutputConfig &a, EnergyOutputConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.energy, b.energy);
  swap(a.__isset, b.__isset);
}

EnergyOutputConfig::EnergyOutputConfig(const EnergyOutputConfig& other4) {
  id = other4.id;
  energy = other4.energy;
  __isset = other4.__isset;
}
EnergyOutputConfig& EnergyOutputConfig::operator=(const EnergyOutputConfig& other5) {
  id = other5.id;
  energy = other5.energy;
  __isset = other5.__isset;
  return *this;
}
void EnergyOutputConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnergyOutputConfig(";
  out << "id=" << to_string(id);
  out << ", " << "energy=" << to_string(energy);
  out << ")";
}


EnergyOutputConfigTable::~EnergyOutputConfigTable() throw() {
}


void EnergyOutputConfigTable::__set_energyConfigMap(const std::map<int32_t, EnergyOutputConfig> & val) {
  this->energyConfigMap = val;
}

uint32_t EnergyOutputConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->energyConfigMap.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              int32_t _key11;
              xfer += iprot->readI32(_key11);
              EnergyOutputConfig& _val12 = this->energyConfigMap[_key11];
              xfer += _val12.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.energyConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnergyOutputConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EnergyOutputConfigTable");

  xfer += oprot->writeFieldBegin("energyConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->energyConfigMap.size()));
    std::map<int32_t, EnergyOutputConfig> ::const_iterator _iter13;
    for (_iter13 = this->energyConfigMap.begin(); _iter13 != this->energyConfigMap.end(); ++_iter13)
    {
      xfer += oprot->writeI32(_iter13->first);
      xfer += _iter13->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnergyOutputConfigTable &a, EnergyOutputConfigTable &b) {
  using ::std::swap;
  swap(a.energyConfigMap, b.energyConfigMap);
  swap(a.__isset, b.__isset);
}

EnergyOutputConfigTable::EnergyOutputConfigTable(const EnergyOutputConfigTable& other14) {
  energyConfigMap = other14.energyConfigMap;
  __isset = other14.__isset;
}
EnergyOutputConfigTable& EnergyOutputConfigTable::operator=(const EnergyOutputConfigTable& other15) {
  energyConfigMap = other15.energyConfigMap;
  __isset = other15.__isset;
  return *this;
}
void EnergyOutputConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnergyOutputConfigTable(";
  out << "energyConfigMap=" << to_string(energyConfigMap);
  out << ")";
}


TriggerConfig::~TriggerConfig() throw() {
}


void TriggerConfig::__set_id(const int32_t val) {
  this->id = val;
}

void TriggerConfig::__set_name(const std::string& val) {
  this->name = val;
}

void TriggerConfig::__set_type(const int32_t val) {
  this->type = val;
}

void TriggerConfig::__set_assetBundle(const std::string& val) {
  this->assetBundle = val;
}

void TriggerConfig::__set_sourceName(const std::string& val) {
  this->sourceName = val;
}

void TriggerConfig::__set_bonusStrategy(const int32_t val) {
  this->bonusStrategy = val;
}

uint32_t TriggerConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->assetBundle);
          this->__isset.assetBundle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceName);
          this->__isset.sourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bonusStrategy);
          this->__isset.bonusStrategy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TriggerConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TriggerConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("assetBundle", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->assetBundle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceName", ::apache::thrift::protocol::T_STRING, 60);
  xfer += oprot->writeString(this->sourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bonusStrategy", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->bonusStrategy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TriggerConfig &a, TriggerConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.assetBundle, b.assetBundle);
  swap(a.sourceName, b.sourceName);
  swap(a.bonusStrategy, b.bonusStrategy);
  swap(a.__isset, b.__isset);
}

TriggerConfig::TriggerConfig(const TriggerConfig& other16) {
  id = other16.id;
  name = other16.name;
  type = other16.type;
  assetBundle = other16.assetBundle;
  sourceName = other16.sourceName;
  bonusStrategy = other16.bonusStrategy;
  __isset = other16.__isset;
}
TriggerConfig& TriggerConfig::operator=(const TriggerConfig& other17) {
  id = other17.id;
  name = other17.name;
  type = other17.type;
  assetBundle = other17.assetBundle;
  sourceName = other17.sourceName;
  bonusStrategy = other17.bonusStrategy;
  __isset = other17.__isset;
  return *this;
}
void TriggerConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TriggerConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "assetBundle=" << to_string(assetBundle);
  out << ", " << "sourceName=" << to_string(sourceName);
  out << ", " << "bonusStrategy=" << to_string(bonusStrategy);
  out << ")";
}


TriggerConfigTable::~TriggerConfigTable() throw() {
}


void TriggerConfigTable::__set_triggerConfigMap(const std::map<int32_t, TriggerConfig> & val) {
  this->triggerConfigMap = val;
}

uint32_t TriggerConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->triggerConfigMap.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              int32_t _key23;
              xfer += iprot->readI32(_key23);
              TriggerConfig& _val24 = this->triggerConfigMap[_key23];
              xfer += _val24.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.triggerConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TriggerConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TriggerConfigTable");

  xfer += oprot->writeFieldBegin("triggerConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggerConfigMap.size()));
    std::map<int32_t, TriggerConfig> ::const_iterator _iter25;
    for (_iter25 = this->triggerConfigMap.begin(); _iter25 != this->triggerConfigMap.end(); ++_iter25)
    {
      xfer += oprot->writeI32(_iter25->first);
      xfer += _iter25->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TriggerConfigTable &a, TriggerConfigTable &b) {
  using ::std::swap;
  swap(a.triggerConfigMap, b.triggerConfigMap);
  swap(a.__isset, b.__isset);
}

TriggerConfigTable::TriggerConfigTable(const TriggerConfigTable& other26) {
  triggerConfigMap = other26.triggerConfigMap;
  __isset = other26.__isset;
}
TriggerConfigTable& TriggerConfigTable::operator=(const TriggerConfigTable& other27) {
  triggerConfigMap = other27.triggerConfigMap;
  __isset = other27.__isset;
  return *this;
}
void TriggerConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TriggerConfigTable(";
  out << "triggerConfigMap=" << to_string(triggerConfigMap);
  out << ")";
}


BulletConfig::~BulletConfig() throw() {
}


void BulletConfig::__set_id(const int32_t val) {
  this->id = val;
}

void BulletConfig::__set_name(const std::string& val) {
  this->name = val;
}

void BulletConfig::__set_category(const int32_t val) {
  this->category = val;
}

void BulletConfig::__set_comPrefab(const std::string& val) {
  this->comPrefab = val;
}

void BulletConfig::__set_atk(const int32_t val) {
  this->atk = val;
}

void BulletConfig::__set_sourceName(const std::string& val) {
  this->sourceName = val;
}

void BulletConfig::__set_attackShipEffect(const std::string& val) {
  this->attackShipEffect = val;
}

void BulletConfig::__set_noramlEffect(const std::string& val) {
  this->noramlEffect = val;
}

void BulletConfig::__set_normalSpeed(const double val) {
  this->normalSpeed = val;
}

void BulletConfig::__set_speedInLine(const double val) {
  this->speedInLine = val;
}

void BulletConfig::__set_shootOnceIntervalTime(const double val) {
  this->shootOnceIntervalTime = val;
}

void BulletConfig::__set_shootMoreIntervalTime(const double val) {
  this->shootMoreIntervalTime = val;
}

void BulletConfig::__set_offsetByOther(const bool val) {
  this->offsetByOther = val;
}

void BulletConfig::__set_lifeCycle(const int32_t val) {
  this->lifeCycle = val;
}

uint32_t BulletConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comPrefab);
          this->__isset.comPrefab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->atk);
          this->__isset.atk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceName);
          this->__isset.sourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attackShipEffect);
          this->__isset.attackShipEffect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->noramlEffect);
          this->__isset.noramlEffect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->normalSpeed);
          this->__isset.normalSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->speedInLine);
          this->__isset.speedInLine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->shootOnceIntervalTime);
          this->__isset.shootOnceIntervalTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->shootMoreIntervalTime);
          this->__isset.shootMoreIntervalTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->offsetByOther);
          this->__isset.offsetByOther = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lifeCycle);
          this->__isset.lifeCycle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulletConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulletConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comPrefab", ::apache::thrift::protocol::T_STRING, 31);
  xfer += oprot->writeString(this->comPrefab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atk", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->atk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceName", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->sourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackShipEffect", ::apache::thrift::protocol::T_STRING, 60);
  xfer += oprot->writeString(this->attackShipEffect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noramlEffect", ::apache::thrift::protocol::T_STRING, 70);
  xfer += oprot->writeString(this->noramlEffect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("normalSpeed", ::apache::thrift::protocol::T_DOUBLE, 80);
  xfer += oprot->writeDouble(this->normalSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speedInLine", ::apache::thrift::protocol::T_DOUBLE, 90);
  xfer += oprot->writeDouble(this->speedInLine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shootOnceIntervalTime", ::apache::thrift::protocol::T_DOUBLE, 100);
  xfer += oprot->writeDouble(this->shootOnceIntervalTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shootMoreIntervalTime", ::apache::thrift::protocol::T_DOUBLE, 110);
  xfer += oprot->writeDouble(this->shootMoreIntervalTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offsetByOther", ::apache::thrift::protocol::T_BOOL, 120);
  xfer += oprot->writeBool(this->offsetByOther);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lifeCycle", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32(this->lifeCycle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulletConfig &a, BulletConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.category, b.category);
  swap(a.comPrefab, b.comPrefab);
  swap(a.atk, b.atk);
  swap(a.sourceName, b.sourceName);
  swap(a.attackShipEffect, b.attackShipEffect);
  swap(a.noramlEffect, b.noramlEffect);
  swap(a.normalSpeed, b.normalSpeed);
  swap(a.speedInLine, b.speedInLine);
  swap(a.shootOnceIntervalTime, b.shootOnceIntervalTime);
  swap(a.shootMoreIntervalTime, b.shootMoreIntervalTime);
  swap(a.offsetByOther, b.offsetByOther);
  swap(a.lifeCycle, b.lifeCycle);
  swap(a.__isset, b.__isset);
}

BulletConfig::BulletConfig(const BulletConfig& other28) {
  id = other28.id;
  name = other28.name;
  category = other28.category;
  comPrefab = other28.comPrefab;
  atk = other28.atk;
  sourceName = other28.sourceName;
  attackShipEffect = other28.attackShipEffect;
  noramlEffect = other28.noramlEffect;
  normalSpeed = other28.normalSpeed;
  speedInLine = other28.speedInLine;
  shootOnceIntervalTime = other28.shootOnceIntervalTime;
  shootMoreIntervalTime = other28.shootMoreIntervalTime;
  offsetByOther = other28.offsetByOther;
  lifeCycle = other28.lifeCycle;
  __isset = other28.__isset;
}
BulletConfig& BulletConfig::operator=(const BulletConfig& other29) {
  id = other29.id;
  name = other29.name;
  category = other29.category;
  comPrefab = other29.comPrefab;
  atk = other29.atk;
  sourceName = other29.sourceName;
  attackShipEffect = other29.attackShipEffect;
  noramlEffect = other29.noramlEffect;
  normalSpeed = other29.normalSpeed;
  speedInLine = other29.speedInLine;
  shootOnceIntervalTime = other29.shootOnceIntervalTime;
  shootMoreIntervalTime = other29.shootMoreIntervalTime;
  offsetByOther = other29.offsetByOther;
  lifeCycle = other29.lifeCycle;
  __isset = other29.__isset;
  return *this;
}
void BulletConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulletConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "category=" << to_string(category);
  out << ", " << "comPrefab=" << to_string(comPrefab);
  out << ", " << "atk=" << to_string(atk);
  out << ", " << "sourceName=" << to_string(sourceName);
  out << ", " << "attackShipEffect=" << to_string(attackShipEffect);
  out << ", " << "noramlEffect=" << to_string(noramlEffect);
  out << ", " << "normalSpeed=" << to_string(normalSpeed);
  out << ", " << "speedInLine=" << to_string(speedInLine);
  out << ", " << "shootOnceIntervalTime=" << to_string(shootOnceIntervalTime);
  out << ", " << "shootMoreIntervalTime=" << to_string(shootMoreIntervalTime);
  out << ", " << "offsetByOther=" << to_string(offsetByOther);
  out << ", " << "lifeCycle=" << to_string(lifeCycle);
  out << ")";
}


BulletConfigTable::~BulletConfigTable() throw() {
}


void BulletConfigTable::__set_bulletConfigMap(const std::map<int32_t, BulletConfig> & val) {
  this->bulletConfigMap = val;
}

uint32_t BulletConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->bulletConfigMap.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _ktype31;
            ::apache::thrift::protocol::TType _vtype32;
            xfer += iprot->readMapBegin(_ktype31, _vtype32, _size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              int32_t _key35;
              xfer += iprot->readI32(_key35);
              BulletConfig& _val36 = this->bulletConfigMap[_key35];
              xfer += _val36.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.bulletConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulletConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulletConfigTable");

  xfer += oprot->writeFieldBegin("bulletConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bulletConfigMap.size()));
    std::map<int32_t, BulletConfig> ::const_iterator _iter37;
    for (_iter37 = this->bulletConfigMap.begin(); _iter37 != this->bulletConfigMap.end(); ++_iter37)
    {
      xfer += oprot->writeI32(_iter37->first);
      xfer += _iter37->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulletConfigTable &a, BulletConfigTable &b) {
  using ::std::swap;
  swap(a.bulletConfigMap, b.bulletConfigMap);
  swap(a.__isset, b.__isset);
}

BulletConfigTable::BulletConfigTable(const BulletConfigTable& other38) {
  bulletConfigMap = other38.bulletConfigMap;
  __isset = other38.__isset;
}
BulletConfigTable& BulletConfigTable::operator=(const BulletConfigTable& other39) {
  bulletConfigMap = other39.bulletConfigMap;
  __isset = other39.__isset;
  return *this;
}
void BulletConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulletConfigTable(";
  out << "bulletConfigMap=" << to_string(bulletConfigMap);
  out << ")";
}


NPCConfig::~NPCConfig() throw() {
}


void NPCConfig::__set_id(const int32_t val) {
  this->id = val;
}

void NPCConfig::__set_name(const std::string& val) {
  this->name = val;
}

void NPCConfig::__set_category(const int32_t val) {
  this->category = val;
}

void NPCConfig::__set_comPrefab(const std::string& val) {
  this->comPrefab = val;
}

void NPCConfig::__set_sourceName(const std::string& val) {
  this->sourceName = val;
}

void NPCConfig::__set_maxHp(const int32_t val) {
  this->maxHp = val;
}

void NPCConfig::__set_defence(const int32_t val) {
  this->defence = val;
}

void NPCConfig::__set_attack(const int32_t val) {
  this->attack = val;
}

void NPCConfig::__set_attackFrequency(const int32_t val) {
  this->attackFrequency = val;
}

void NPCConfig::__set_attackRadius(const int32_t val) {
  this->attackRadius = val;
}

void NPCConfig::__set_normalSpeed(const int32_t val) {
  this->normalSpeed = val;
}

void NPCConfig::__set_normalRadius(const int32_t val) {
  this->normalRadius = val;
}

void NPCConfig::__set_chaseSpeed(const int32_t val) {
  this->chaseSpeed = val;
}

void NPCConfig::__set_escapeSpeed(const int32_t val) {
  this->escapeSpeed = val;
}

void NPCConfig::__set_tourSpeed(const int32_t val) {
  this->tourSpeed = val;
}

void NPCConfig::__set_tourRadius(const int32_t val) {
  this->tourRadius = val;
}

void NPCConfig::__set_backRadius(const int32_t val) {
  this->backRadius = val;
}

void NPCConfig::__set_backSpeed(const int32_t val) {
  this->backSpeed = val;
}

void NPCConfig::__set_score(const int32_t val) {
  this->score = val;
}

void NPCConfig::__set_dropId(const int32_t val) {
  this->dropId = val;
}

void NPCConfig::__set_deathTime(const int32_t val) {
  this->deathTime = val;
}

void NPCConfig::__set_dropRate(const int32_t val) {
  this->dropRate = val;
}

void NPCConfig::__set_dropType(const int32_t val) {
  this->dropType = val;
}

void NPCConfig::__set_norRenLv(const int32_t val) {
  this->norRenLv = val;
}

uint32_t NPCConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comPrefab);
          this->__isset.comPrefab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceName);
          this->__isset.sourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHp);
          this->__isset.maxHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->defence);
          this->__isset.defence = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attack);
          this->__isset.attack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attackFrequency);
          this->__isset.attackFrequency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attackRadius);
          this->__isset.attackRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->normalSpeed);
          this->__isset.normalSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->normalRadius);
          this->__isset.normalRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->chaseSpeed);
          this->__isset.chaseSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 140:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->escapeSpeed);
          this->__isset.escapeSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 150:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tourSpeed);
          this->__isset.tourSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 160:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tourRadius);
          this->__isset.tourRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 170:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backRadius);
          this->__isset.backRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 180:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backSpeed);
          this->__isset.backSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 190:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->score);
          this->__isset.score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 200:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dropId);
          this->__isset.dropId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 210:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deathTime);
          this->__isset.deathTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 220:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dropRate);
          this->__isset.dropRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 230:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dropType);
          this->__isset.dropType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 240:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->norRenLv);
          this->__isset.norRenLv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NPCConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NPCConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comPrefab", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->comPrefab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceName", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->sourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxHp", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->maxHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defence", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->defence);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attack", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->attack);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackFrequency", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->attackFrequency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackRadius", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->attackRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("normalSpeed", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->normalSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("normalRadius", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->normalRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chaseSpeed", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32(this->chaseSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("escapeSpeed", ::apache::thrift::protocol::T_I32, 140);
  xfer += oprot->writeI32(this->escapeSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tourSpeed", ::apache::thrift::protocol::T_I32, 150);
  xfer += oprot->writeI32(this->tourSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tourRadius", ::apache::thrift::protocol::T_I32, 160);
  xfer += oprot->writeI32(this->tourRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backRadius", ::apache::thrift::protocol::T_I32, 170);
  xfer += oprot->writeI32(this->backRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backSpeed", ::apache::thrift::protocol::T_I32, 180);
  xfer += oprot->writeI32(this->backSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_I32, 190);
  xfer += oprot->writeI32(this->score);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropId", ::apache::thrift::protocol::T_I32, 200);
  xfer += oprot->writeI32(this->dropId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deathTime", ::apache::thrift::protocol::T_I32, 210);
  xfer += oprot->writeI32(this->deathTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropRate", ::apache::thrift::protocol::T_I32, 220);
  xfer += oprot->writeI32(this->dropRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropType", ::apache::thrift::protocol::T_I32, 230);
  xfer += oprot->writeI32(this->dropType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("norRenLv", ::apache::thrift::protocol::T_I32, 240);
  xfer += oprot->writeI32(this->norRenLv);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NPCConfig &a, NPCConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.category, b.category);
  swap(a.comPrefab, b.comPrefab);
  swap(a.sourceName, b.sourceName);
  swap(a.maxHp, b.maxHp);
  swap(a.defence, b.defence);
  swap(a.attack, b.attack);
  swap(a.attackFrequency, b.attackFrequency);
  swap(a.attackRadius, b.attackRadius);
  swap(a.normalSpeed, b.normalSpeed);
  swap(a.normalRadius, b.normalRadius);
  swap(a.chaseSpeed, b.chaseSpeed);
  swap(a.escapeSpeed, b.escapeSpeed);
  swap(a.tourSpeed, b.tourSpeed);
  swap(a.tourRadius, b.tourRadius);
  swap(a.backRadius, b.backRadius);
  swap(a.backSpeed, b.backSpeed);
  swap(a.score, b.score);
  swap(a.dropId, b.dropId);
  swap(a.deathTime, b.deathTime);
  swap(a.dropRate, b.dropRate);
  swap(a.dropType, b.dropType);
  swap(a.norRenLv, b.norRenLv);
  swap(a.__isset, b.__isset);
}

NPCConfig::NPCConfig(const NPCConfig& other40) {
  id = other40.id;
  name = other40.name;
  category = other40.category;
  comPrefab = other40.comPrefab;
  sourceName = other40.sourceName;
  maxHp = other40.maxHp;
  defence = other40.defence;
  attack = other40.attack;
  attackFrequency = other40.attackFrequency;
  attackRadius = other40.attackRadius;
  normalSpeed = other40.normalSpeed;
  normalRadius = other40.normalRadius;
  chaseSpeed = other40.chaseSpeed;
  escapeSpeed = other40.escapeSpeed;
  tourSpeed = other40.tourSpeed;
  tourRadius = other40.tourRadius;
  backRadius = other40.backRadius;
  backSpeed = other40.backSpeed;
  score = other40.score;
  dropId = other40.dropId;
  deathTime = other40.deathTime;
  dropRate = other40.dropRate;
  dropType = other40.dropType;
  norRenLv = other40.norRenLv;
  __isset = other40.__isset;
}
NPCConfig& NPCConfig::operator=(const NPCConfig& other41) {
  id = other41.id;
  name = other41.name;
  category = other41.category;
  comPrefab = other41.comPrefab;
  sourceName = other41.sourceName;
  maxHp = other41.maxHp;
  defence = other41.defence;
  attack = other41.attack;
  attackFrequency = other41.attackFrequency;
  attackRadius = other41.attackRadius;
  normalSpeed = other41.normalSpeed;
  normalRadius = other41.normalRadius;
  chaseSpeed = other41.chaseSpeed;
  escapeSpeed = other41.escapeSpeed;
  tourSpeed = other41.tourSpeed;
  tourRadius = other41.tourRadius;
  backRadius = other41.backRadius;
  backSpeed = other41.backSpeed;
  score = other41.score;
  dropId = other41.dropId;
  deathTime = other41.deathTime;
  dropRate = other41.dropRate;
  dropType = other41.dropType;
  norRenLv = other41.norRenLv;
  __isset = other41.__isset;
  return *this;
}
void NPCConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NPCConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "category=" << to_string(category);
  out << ", " << "comPrefab=" << to_string(comPrefab);
  out << ", " << "sourceName=" << to_string(sourceName);
  out << ", " << "maxHp=" << to_string(maxHp);
  out << ", " << "defence=" << to_string(defence);
  out << ", " << "attack=" << to_string(attack);
  out << ", " << "attackFrequency=" << to_string(attackFrequency);
  out << ", " << "attackRadius=" << to_string(attackRadius);
  out << ", " << "normalSpeed=" << to_string(normalSpeed);
  out << ", " << "normalRadius=" << to_string(normalRadius);
  out << ", " << "chaseSpeed=" << to_string(chaseSpeed);
  out << ", " << "escapeSpeed=" << to_string(escapeSpeed);
  out << ", " << "tourSpeed=" << to_string(tourSpeed);
  out << ", " << "tourRadius=" << to_string(tourRadius);
  out << ", " << "backRadius=" << to_string(backRadius);
  out << ", " << "backSpeed=" << to_string(backSpeed);
  out << ", " << "score=" << to_string(score);
  out << ", " << "dropId=" << to_string(dropId);
  out << ", " << "deathTime=" << to_string(deathTime);
  out << ", " << "dropRate=" << to_string(dropRate);
  out << ", " << "dropType=" << to_string(dropType);
  out << ", " << "norRenLv=" << to_string(norRenLv);
  out << ")";
}


NPCConfigTable::~NPCConfigTable() throw() {
}


void NPCConfigTable::__set_npcConfigMap(const std::map<int32_t, NPCConfig> & val) {
  this->npcConfigMap = val;
}

uint32_t NPCConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->npcConfigMap.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _ktype43;
            ::apache::thrift::protocol::TType _vtype44;
            xfer += iprot->readMapBegin(_ktype43, _vtype44, _size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              int32_t _key47;
              xfer += iprot->readI32(_key47);
              NPCConfig& _val48 = this->npcConfigMap[_key47];
              xfer += _val48.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.npcConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NPCConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NPCConfigTable");

  xfer += oprot->writeFieldBegin("npcConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->npcConfigMap.size()));
    std::map<int32_t, NPCConfig> ::const_iterator _iter49;
    for (_iter49 = this->npcConfigMap.begin(); _iter49 != this->npcConfigMap.end(); ++_iter49)
    {
      xfer += oprot->writeI32(_iter49->first);
      xfer += _iter49->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NPCConfigTable &a, NPCConfigTable &b) {
  using ::std::swap;
  swap(a.npcConfigMap, b.npcConfigMap);
  swap(a.__isset, b.__isset);
}

NPCConfigTable::NPCConfigTable(const NPCConfigTable& other50) {
  npcConfigMap = other50.npcConfigMap;
  __isset = other50.__isset;
}
NPCConfigTable& NPCConfigTable::operator=(const NPCConfigTable& other51) {
  npcConfigMap = other51.npcConfigMap;
  __isset = other51.__isset;
  return *this;
}
void NPCConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NPCConfigTable(";
  out << "npcConfigMap=" << to_string(npcConfigMap);
  out << ")";
}


SoundPath::~SoundPath() throw() {
}


void SoundPath::__set_type(const std::string& val) {
  this->type = val;
}

void SoundPath::__set_path(const std::string& val) {
  this->path = val;
}

uint32_t SoundPath::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SoundPath::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SoundPath");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SoundPath &a, SoundPath &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

SoundPath::SoundPath(const SoundPath& other52) {
  type = other52.type;
  path = other52.path;
  __isset = other52.__isset;
}
SoundPath& SoundPath::operator=(const SoundPath& other53) {
  type = other53.type;
  path = other53.path;
  __isset = other53.__isset;
  return *this;
}
void SoundPath::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SoundPath(";
  out << "type=" << to_string(type);
  out << ", " << "path=" << to_string(path);
  out << ")";
}


SoundPathMap::~SoundPathMap() throw() {
}


void SoundPathMap::__set_soundPathMap(const std::map<std::string, SoundPath> & val) {
  this->soundPathMap = val;
}

uint32_t SoundPathMap::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->soundPathMap.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _ktype55;
            ::apache::thrift::protocol::TType _vtype56;
            xfer += iprot->readMapBegin(_ktype55, _vtype56, _size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              std::string _key59;
              xfer += iprot->readString(_key59);
              SoundPath& _val60 = this->soundPathMap[_key59];
              xfer += _val60.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.soundPathMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SoundPathMap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SoundPathMap");

  xfer += oprot->writeFieldBegin("soundPathMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->soundPathMap.size()));
    std::map<std::string, SoundPath> ::const_iterator _iter61;
    for (_iter61 = this->soundPathMap.begin(); _iter61 != this->soundPathMap.end(); ++_iter61)
    {
      xfer += oprot->writeString(_iter61->first);
      xfer += _iter61->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SoundPathMap &a, SoundPathMap &b) {
  using ::std::swap;
  swap(a.soundPathMap, b.soundPathMap);
  swap(a.__isset, b.__isset);
}

SoundPathMap::SoundPathMap(const SoundPathMap& other62) {
  soundPathMap = other62.soundPathMap;
  __isset = other62.__isset;
}
SoundPathMap& SoundPathMap::operator=(const SoundPathMap& other63) {
  soundPathMap = other63.soundPathMap;
  __isset = other63.__isset;
  return *this;
}
void SoundPathMap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SoundPathMap(";
  out << "soundPathMap=" << to_string(soundPathMap);
  out << ")";
}


BattleItemConfig::~BattleItemConfig() throw() {
}


void BattleItemConfig::__set_id(const int32_t val) {
  this->id = val;
}

void BattleItemConfig::__set_resource(const std::string& val) {
  this->resource = val;
}

void BattleItemConfig::__set_limitId(const int32_t val) {
  this->limitId = val;
}

void BattleItemConfig::__set_funcId(const int32_t val) {
  this->funcId = val;
}

void BattleItemConfig::__set_dieEffect(const std::string& val) {
  this->dieEffect = val;
}

void BattleItemConfig::__set_category(const int32_t val) {
  this->category = val;
}

void BattleItemConfig::__set_comPrefab(const std::string& val) {
  this->comPrefab = val;
}

void BattleItemConfig::__set_lifeCycle(const int32_t val) {
  this->lifeCycle = val;
}

void BattleItemConfig::__set_triggerValidity(const bool val) {
  this->triggerValidity = val;
}

void BattleItemConfig::__set_renderLevel(const int32_t val) {
  this->renderLevel = val;
}

uint32_t BattleItemConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource);
          this->__isset.resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limitId);
          this->__isset.limitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->funcId);
          this->__isset.funcId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dieEffect);
          this->__isset.dieEffect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comPrefab);
          this->__isset.comPrefab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lifeCycle);
          this->__isset.lifeCycle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->triggerValidity);
          this->__isset.triggerValidity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->renderLevel);
          this->__isset.renderLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BattleItemConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BattleItemConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->resource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limitId", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->limitId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("funcId", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->funcId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dieEffect", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->dieEffect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comPrefab", ::apache::thrift::protocol::T_STRING, 70);
  xfer += oprot->writeString(this->comPrefab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lifeCycle", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->lifeCycle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerValidity", ::apache::thrift::protocol::T_BOOL, 90);
  xfer += oprot->writeBool(this->triggerValidity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("renderLevel", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->renderLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BattleItemConfig &a, BattleItemConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.resource, b.resource);
  swap(a.limitId, b.limitId);
  swap(a.funcId, b.funcId);
  swap(a.dieEffect, b.dieEffect);
  swap(a.category, b.category);
  swap(a.comPrefab, b.comPrefab);
  swap(a.lifeCycle, b.lifeCycle);
  swap(a.triggerValidity, b.triggerValidity);
  swap(a.renderLevel, b.renderLevel);
  swap(a.__isset, b.__isset);
}

BattleItemConfig::BattleItemConfig(const BattleItemConfig& other64) {
  id = other64.id;
  resource = other64.resource;
  limitId = other64.limitId;
  funcId = other64.funcId;
  dieEffect = other64.dieEffect;
  category = other64.category;
  comPrefab = other64.comPrefab;
  lifeCycle = other64.lifeCycle;
  triggerValidity = other64.triggerValidity;
  renderLevel = other64.renderLevel;
  __isset = other64.__isset;
}
BattleItemConfig& BattleItemConfig::operator=(const BattleItemConfig& other65) {
  id = other65.id;
  resource = other65.resource;
  limitId = other65.limitId;
  funcId = other65.funcId;
  dieEffect = other65.dieEffect;
  category = other65.category;
  comPrefab = other65.comPrefab;
  lifeCycle = other65.lifeCycle;
  triggerValidity = other65.triggerValidity;
  renderLevel = other65.renderLevel;
  __isset = other65.__isset;
  return *this;
}
void BattleItemConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BattleItemConfig(";
  out << "id=" << to_string(id);
  out << ", " << "resource=" << to_string(resource);
  out << ", " << "limitId=" << to_string(limitId);
  out << ", " << "funcId=" << to_string(funcId);
  out << ", " << "dieEffect=" << to_string(dieEffect);
  out << ", " << "category=" << to_string(category);
  out << ", " << "comPrefab=" << to_string(comPrefab);
  out << ", " << "lifeCycle=" << to_string(lifeCycle);
  out << ", " << "triggerValidity=" << to_string(triggerValidity);
  out << ", " << "renderLevel=" << to_string(renderLevel);
  out << ")";
}


BattleItemConfigTable::~BattleItemConfigTable() throw() {
}


void BattleItemConfigTable::__set_itemConfigMap(const std::map<int32_t, BattleItemConfig> & val) {
  this->itemConfigMap = val;
}

uint32_t BattleItemConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->itemConfigMap.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              int32_t _key71;
              xfer += iprot->readI32(_key71);
              BattleItemConfig& _val72 = this->itemConfigMap[_key71];
              xfer += _val72.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.itemConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BattleItemConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BattleItemConfigTable");

  xfer += oprot->writeFieldBegin("itemConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->itemConfigMap.size()));
    std::map<int32_t, BattleItemConfig> ::const_iterator _iter73;
    for (_iter73 = this->itemConfigMap.begin(); _iter73 != this->itemConfigMap.end(); ++_iter73)
    {
      xfer += oprot->writeI32(_iter73->first);
      xfer += _iter73->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BattleItemConfigTable &a, BattleItemConfigTable &b) {
  using ::std::swap;
  swap(a.itemConfigMap, b.itemConfigMap);
  swap(a.__isset, b.__isset);
}

BattleItemConfigTable::BattleItemConfigTable(const BattleItemConfigTable& other74) {
  itemConfigMap = other74.itemConfigMap;
  __isset = other74.__isset;
}
BattleItemConfigTable& BattleItemConfigTable::operator=(const BattleItemConfigTable& other75) {
  itemConfigMap = other75.itemConfigMap;
  __isset = other75.__isset;
  return *this;
}
void BattleItemConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BattleItemConfigTable(";
  out << "itemConfigMap=" << to_string(itemConfigMap);
  out << ")";
}


DropItem::~DropItem() throw() {
}


void DropItem::__set_itemId(const int32_t val) {
  this->itemId = val;
}

void DropItem::__set_minCount(const int32_t val) {
  this->minCount = val;
}

void DropItem::__set_maxCount(const int32_t val) {
  this->maxCount = val;
}

void DropItem::__set_weight(const int32_t val) {
  this->weight = val;
}

uint32_t DropItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemId);
          this->__isset.itemId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minCount);
          this->__isset.minCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCount);
          this->__isset.maxCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropItem");

  xfer += oprot->writeFieldBegin("itemId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->itemId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minCount", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->minCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCount", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->maxCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropItem &a, DropItem &b) {
  using ::std::swap;
  swap(a.itemId, b.itemId);
  swap(a.minCount, b.minCount);
  swap(a.maxCount, b.maxCount);
  swap(a.weight, b.weight);
  swap(a.__isset, b.__isset);
}

DropItem::DropItem(const DropItem& other76) {
  itemId = other76.itemId;
  minCount = other76.minCount;
  maxCount = other76.maxCount;
  weight = other76.weight;
  __isset = other76.__isset;
}
DropItem& DropItem::operator=(const DropItem& other77) {
  itemId = other77.itemId;
  minCount = other77.minCount;
  maxCount = other77.maxCount;
  weight = other77.weight;
  __isset = other77.__isset;
  return *this;
}
void DropItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropItem(";
  out << "itemId=" << to_string(itemId);
  out << ", " << "minCount=" << to_string(minCount);
  out << ", " << "maxCount=" << to_string(maxCount);
  out << ", " << "weight=" << to_string(weight);
  out << ")";
}


DropListConfig::~DropListConfig() throw() {
}


void DropListConfig::__set_dropListId(const int32_t val) {
  this->dropListId = val;
}

void DropListConfig::__set_dropItemList(const std::vector<DropItem> & val) {
  this->dropItemList = val;
}

uint32_t DropListConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dropListId);
          this->__isset.dropListId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dropItemList.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->dropItemList.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->dropItemList[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dropItemList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropListConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropListConfig");

  xfer += oprot->writeFieldBegin("dropListId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->dropListId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropItemList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dropItemList.size()));
    std::vector<DropItem> ::const_iterator _iter83;
    for (_iter83 = this->dropItemList.begin(); _iter83 != this->dropItemList.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropListConfig &a, DropListConfig &b) {
  using ::std::swap;
  swap(a.dropListId, b.dropListId);
  swap(a.dropItemList, b.dropItemList);
  swap(a.__isset, b.__isset);
}

DropListConfig::DropListConfig(const DropListConfig& other84) {
  dropListId = other84.dropListId;
  dropItemList = other84.dropItemList;
  __isset = other84.__isset;
}
DropListConfig& DropListConfig::operator=(const DropListConfig& other85) {
  dropListId = other85.dropListId;
  dropItemList = other85.dropItemList;
  __isset = other85.__isset;
  return *this;
}
void DropListConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropListConfig(";
  out << "dropListId=" << to_string(dropListId);
  out << ", " << "dropItemList=" << to_string(dropItemList);
  out << ")";
}


DropListConfigTable::~DropListConfigTable() throw() {
}


void DropListConfigTable::__set_dropListConfigMap(const std::map<int32_t, DropListConfig> & val) {
  this->dropListConfigMap = val;
}

uint32_t DropListConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->dropListConfigMap.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _ktype87;
            ::apache::thrift::protocol::TType _vtype88;
            xfer += iprot->readMapBegin(_ktype87, _vtype88, _size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              int32_t _key91;
              xfer += iprot->readI32(_key91);
              DropListConfig& _val92 = this->dropListConfigMap[_key91];
              xfer += _val92.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.dropListConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropListConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropListConfigTable");

  xfer += oprot->writeFieldBegin("dropListConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dropListConfigMap.size()));
    std::map<int32_t, DropListConfig> ::const_iterator _iter93;
    for (_iter93 = this->dropListConfigMap.begin(); _iter93 != this->dropListConfigMap.end(); ++_iter93)
    {
      xfer += oprot->writeI32(_iter93->first);
      xfer += _iter93->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropListConfigTable &a, DropListConfigTable &b) {
  using ::std::swap;
  swap(a.dropListConfigMap, b.dropListConfigMap);
  swap(a.__isset, b.__isset);
}

DropListConfigTable::DropListConfigTable(const DropListConfigTable& other94) {
  dropListConfigMap = other94.dropListConfigMap;
  __isset = other94.__isset;
}
DropListConfigTable& DropListConfigTable::operator=(const DropListConfigTable& other95) {
  dropListConfigMap = other95.dropListConfigMap;
  __isset = other95.__isset;
  return *this;
}
void DropListConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropListConfigTable(";
  out << "dropListConfigMap=" << to_string(dropListConfigMap);
  out << ")";
}


VersionConfig::~VersionConfig() throw() {
}


void VersionConfig::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t VersionConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VersionConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VersionConfig");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VersionConfig &a, VersionConfig &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

VersionConfig::VersionConfig(const VersionConfig& other96) {
  name = other96.name;
  __isset = other96.__isset;
}
VersionConfig& VersionConfig::operator=(const VersionConfig& other97) {
  name = other97.name;
  __isset = other97.__isset;
  return *this;
}
void VersionConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VersionConfig(";
  out << "name=" << to_string(name);
  out << ")";
}


LimitData::~LimitData() throw() {
}


void LimitData::__set_id(const int32_t val) {
  this->id = val;
}

void LimitData::__set_oper(const int8_t val) {
  this->oper = val;
}

void LimitData::__set_messageId(const int32_t val) {
  this->messageId = val;
}

void LimitData::__set_target(const int8_t val) {
  this->target = val;
}

void LimitData::__set_paramStringList(const std::vector<std::string> & val) {
  this->paramStringList = val;
}

void LimitData::__set_paramIntList(const std::vector<int32_t> & val) {
  this->paramIntList = val;
}

uint32_t LimitData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->oper);
          this->__isset.oper = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->messageId);
          this->__isset.messageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramStringList.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readListBegin(_etype101, _size98);
            this->paramStringList.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += iprot->readString(this->paramStringList[_i102]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramStringList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramIntList.clear();
            uint32_t _size103;
            ::apache::thrift::protocol::TType _etype106;
            xfer += iprot->readListBegin(_etype106, _size103);
            this->paramIntList.resize(_size103);
            uint32_t _i107;
            for (_i107 = 0; _i107 < _size103; ++_i107)
            {
              xfer += iprot->readI32(this->paramIntList[_i107]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramIntList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LimitData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LimitData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oper", ::apache::thrift::protocol::T_BYTE, 20);
  xfer += oprot->writeByte(this->oper);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messageId", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->messageId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_BYTE, 40);
  xfer += oprot->writeByte(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramStringList", ::apache::thrift::protocol::T_LIST, 50);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paramStringList.size()));
    std::vector<std::string> ::const_iterator _iter108;
    for (_iter108 = this->paramStringList.begin(); _iter108 != this->paramStringList.end(); ++_iter108)
    {
      xfer += oprot->writeString((*_iter108));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramIntList", ::apache::thrift::protocol::T_LIST, 60);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->paramIntList.size()));
    std::vector<int32_t> ::const_iterator _iter109;
    for (_iter109 = this->paramIntList.begin(); _iter109 != this->paramIntList.end(); ++_iter109)
    {
      xfer += oprot->writeI32((*_iter109));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LimitData &a, LimitData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.oper, b.oper);
  swap(a.messageId, b.messageId);
  swap(a.target, b.target);
  swap(a.paramStringList, b.paramStringList);
  swap(a.paramIntList, b.paramIntList);
  swap(a.__isset, b.__isset);
}

LimitData::LimitData(const LimitData& other110) {
  id = other110.id;
  oper = other110.oper;
  messageId = other110.messageId;
  target = other110.target;
  paramStringList = other110.paramStringList;
  paramIntList = other110.paramIntList;
  __isset = other110.__isset;
}
LimitData& LimitData::operator=(const LimitData& other111) {
  id = other111.id;
  oper = other111.oper;
  messageId = other111.messageId;
  target = other111.target;
  paramStringList = other111.paramStringList;
  paramIntList = other111.paramIntList;
  __isset = other111.__isset;
  return *this;
}
void LimitData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LimitData(";
  out << "id=" << to_string(id);
  out << ", " << "oper=" << to_string(oper);
  out << ", " << "messageId=" << to_string(messageId);
  out << ", " << "target=" << to_string(target);
  out << ", " << "paramStringList=" << to_string(paramStringList);
  out << ", " << "paramIntList=" << to_string(paramIntList);
  out << ")";
}


LimitGroup::~LimitGroup() throw() {
}


void LimitGroup::__set_id(const int32_t val) {
  this->id = val;
}

void LimitGroup::__set_logic(const int8_t val) {
  this->logic = val;
}

void LimitGroup::__set_limitDataList(const std::vector<LimitData> & val) {
  this->limitDataList = val;
}

uint32_t LimitGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->logic);
          this->__isset.logic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->limitDataList.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->limitDataList.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += this->limitDataList[_i116].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.limitDataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LimitGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LimitGroup");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("logic", ::apache::thrift::protocol::T_BYTE, 20);
  xfer += oprot->writeByte(this->logic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limitDataList", ::apache::thrift::protocol::T_LIST, 30);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->limitDataList.size()));
    std::vector<LimitData> ::const_iterator _iter117;
    for (_iter117 = this->limitDataList.begin(); _iter117 != this->limitDataList.end(); ++_iter117)
    {
      xfer += (*_iter117).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LimitGroup &a, LimitGroup &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.logic, b.logic);
  swap(a.limitDataList, b.limitDataList);
  swap(a.__isset, b.__isset);
}

LimitGroup::LimitGroup(const LimitGroup& other118) {
  id = other118.id;
  logic = other118.logic;
  limitDataList = other118.limitDataList;
  __isset = other118.__isset;
}
LimitGroup& LimitGroup::operator=(const LimitGroup& other119) {
  id = other119.id;
  logic = other119.logic;
  limitDataList = other119.limitDataList;
  __isset = other119.__isset;
  return *this;
}
void LimitGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LimitGroup(";
  out << "id=" << to_string(id);
  out << ", " << "logic=" << to_string(logic);
  out << ", " << "limitDataList=" << to_string(limitDataList);
  out << ")";
}


FuncData::~FuncData() throw() {
}


void FuncData::__set_id(const int32_t val) {
  this->id = val;
}

void FuncData::__set_oper(const int8_t val) {
  this->oper = val;
}

void FuncData::__set_target(const int8_t val) {
  this->target = val;
}

void FuncData::__set_paramStringList(const std::vector<std::string> & val) {
  this->paramStringList = val;
}

void FuncData::__set_paramIntList(const std::vector<int32_t> & val) {
  this->paramIntList = val;
}

uint32_t FuncData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->oper);
          this->__isset.oper = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramStringList.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _etype123;
            xfer += iprot->readListBegin(_etype123, _size120);
            this->paramStringList.resize(_size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              xfer += iprot->readString(this->paramStringList[_i124]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramStringList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramIntList.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->paramIntList.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += iprot->readI32(this->paramIntList[_i129]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramIntList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FuncData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FuncData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oper", ::apache::thrift::protocol::T_BYTE, 20);
  xfer += oprot->writeByte(this->oper);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_BYTE, 30);
  xfer += oprot->writeByte(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramStringList", ::apache::thrift::protocol::T_LIST, 40);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paramStringList.size()));
    std::vector<std::string> ::const_iterator _iter130;
    for (_iter130 = this->paramStringList.begin(); _iter130 != this->paramStringList.end(); ++_iter130)
    {
      xfer += oprot->writeString((*_iter130));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramIntList", ::apache::thrift::protocol::T_LIST, 50);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->paramIntList.size()));
    std::vector<int32_t> ::const_iterator _iter131;
    for (_iter131 = this->paramIntList.begin(); _iter131 != this->paramIntList.end(); ++_iter131)
    {
      xfer += oprot->writeI32((*_iter131));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FuncData &a, FuncData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.oper, b.oper);
  swap(a.target, b.target);
  swap(a.paramStringList, b.paramStringList);
  swap(a.paramIntList, b.paramIntList);
  swap(a.__isset, b.__isset);
}

FuncData::FuncData(const FuncData& other132) {
  id = other132.id;
  oper = other132.oper;
  target = other132.target;
  paramStringList = other132.paramStringList;
  paramIntList = other132.paramIntList;
  __isset = other132.__isset;
}
FuncData& FuncData::operator=(const FuncData& other133) {
  id = other133.id;
  oper = other133.oper;
  target = other133.target;
  paramStringList = other133.paramStringList;
  paramIntList = other133.paramIntList;
  __isset = other133.__isset;
  return *this;
}
void FuncData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FuncData(";
  out << "id=" << to_string(id);
  out << ", " << "oper=" << to_string(oper);
  out << ", " << "target=" << to_string(target);
  out << ", " << "paramStringList=" << to_string(paramStringList);
  out << ", " << "paramIntList=" << to_string(paramIntList);
  out << ")";
}


FuncGroup::~FuncGroup() throw() {
}


void FuncGroup::__set_id(const int32_t val) {
  this->id = val;
}

void FuncGroup::__set_funcDataList(const std::vector<FuncData> & val) {
  this->funcDataList = val;
}

uint32_t FuncGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->funcDataList.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readListBegin(_etype137, _size134);
            this->funcDataList.resize(_size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              xfer += this->funcDataList[_i138].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.funcDataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FuncGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FuncGroup");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("funcDataList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->funcDataList.size()));
    std::vector<FuncData> ::const_iterator _iter139;
    for (_iter139 = this->funcDataList.begin(); _iter139 != this->funcDataList.end(); ++_iter139)
    {
      xfer += (*_iter139).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FuncGroup &a, FuncGroup &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.funcDataList, b.funcDataList);
  swap(a.__isset, b.__isset);
}

FuncGroup::FuncGroup(const FuncGroup& other140) {
  id = other140.id;
  funcDataList = other140.funcDataList;
  __isset = other140.__isset;
}
FuncGroup& FuncGroup::operator=(const FuncGroup& other141) {
  id = other141.id;
  funcDataList = other141.funcDataList;
  __isset = other141.__isset;
  return *this;
}
void FuncGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FuncGroup(";
  out << "id=" << to_string(id);
  out << ", " << "funcDataList=" << to_string(funcDataList);
  out << ")";
}


TargetData::~TargetData() throw() {
}


void TargetData::__set_targetId(const int32_t val) {
  this->targetId = val;
}

void TargetData::__set_paramStringList(const std::vector<std::string> & val) {
  this->paramStringList = val;
}

void TargetData::__set_paramIntList(const std::vector<int32_t> & val) {
  this->paramIntList = val;
}

uint32_t TargetData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetId);
          this->__isset.targetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramStringList.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readListBegin(_etype145, _size142);
            this->paramStringList.resize(_size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              xfer += iprot->readString(this->paramStringList[_i146]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramStringList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramIntList.clear();
            uint32_t _size147;
            ::apache::thrift::protocol::TType _etype150;
            xfer += iprot->readListBegin(_etype150, _size147);
            this->paramIntList.resize(_size147);
            uint32_t _i151;
            for (_i151 = 0; _i151 < _size147; ++_i151)
            {
              xfer += iprot->readI32(this->paramIntList[_i151]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramIntList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TargetData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TargetData");

  xfer += oprot->writeFieldBegin("targetId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->targetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramStringList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paramStringList.size()));
    std::vector<std::string> ::const_iterator _iter152;
    for (_iter152 = this->paramStringList.begin(); _iter152 != this->paramStringList.end(); ++_iter152)
    {
      xfer += oprot->writeString((*_iter152));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramIntList", ::apache::thrift::protocol::T_LIST, 30);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->paramIntList.size()));
    std::vector<int32_t> ::const_iterator _iter153;
    for (_iter153 = this->paramIntList.begin(); _iter153 != this->paramIntList.end(); ++_iter153)
    {
      xfer += oprot->writeI32((*_iter153));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TargetData &a, TargetData &b) {
  using ::std::swap;
  swap(a.targetId, b.targetId);
  swap(a.paramStringList, b.paramStringList);
  swap(a.paramIntList, b.paramIntList);
  swap(a.__isset, b.__isset);
}

TargetData::TargetData(const TargetData& other154) {
  targetId = other154.targetId;
  paramStringList = other154.paramStringList;
  paramIntList = other154.paramIntList;
  __isset = other154.__isset;
}
TargetData& TargetData::operator=(const TargetData& other155) {
  targetId = other155.targetId;
  paramStringList = other155.paramStringList;
  paramIntList = other155.paramIntList;
  __isset = other155.__isset;
  return *this;
}
void TargetData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TargetData(";
  out << "targetId=" << to_string(targetId);
  out << ", " << "paramStringList=" << to_string(paramStringList);
  out << ", " << "paramIntList=" << to_string(paramIntList);
  out << ")";
}


TargetGroup::~TargetGroup() throw() {
}


void TargetGroup::__set_id(const int32_t val) {
  this->id = val;
}

void TargetGroup::__set_targetDataList(const std::vector<TargetData> & val) {
  this->targetDataList = val;
}

uint32_t TargetGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targetDataList.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _etype159;
            xfer += iprot->readListBegin(_etype159, _size156);
            this->targetDataList.resize(_size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              xfer += this->targetDataList[_i160].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.targetDataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TargetGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TargetGroup");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetDataList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->targetDataList.size()));
    std::vector<TargetData> ::const_iterator _iter161;
    for (_iter161 = this->targetDataList.begin(); _iter161 != this->targetDataList.end(); ++_iter161)
    {
      xfer += (*_iter161).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TargetGroup &a, TargetGroup &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targetDataList, b.targetDataList);
  swap(a.__isset, b.__isset);
}

TargetGroup::TargetGroup(const TargetGroup& other162) {
  id = other162.id;
  targetDataList = other162.targetDataList;
  __isset = other162.__isset;
}
TargetGroup& TargetGroup::operator=(const TargetGroup& other163) {
  id = other163.id;
  targetDataList = other163.targetDataList;
  __isset = other163.__isset;
  return *this;
}
void TargetGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TargetGroup(";
  out << "id=" << to_string(id);
  out << ", " << "targetDataList=" << to_string(targetDataList);
  out << ")";
}


LimitFuncSceneConfig::~LimitFuncSceneConfig() throw() {
}


void LimitFuncSceneConfig::__set_limitId(const int32_t val) {
  this->limitId = val;
}

void LimitFuncSceneConfig::__set_funcId(const int32_t val) {
  this->funcId = val;
}

void LimitFuncSceneConfig::__set_targetId(const int32_t val) {
  this->targetId = val;
}

uint32_t LimitFuncSceneConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limitId);
          this->__isset.limitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->funcId);
          this->__isset.funcId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetId);
          this->__isset.targetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LimitFuncSceneConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LimitFuncSceneConfig");

  xfer += oprot->writeFieldBegin("limitId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->limitId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("funcId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->funcId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetId", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->targetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LimitFuncSceneConfig &a, LimitFuncSceneConfig &b) {
  using ::std::swap;
  swap(a.limitId, b.limitId);
  swap(a.funcId, b.funcId);
  swap(a.targetId, b.targetId);
  swap(a.__isset, b.__isset);
}

LimitFuncSceneConfig::LimitFuncSceneConfig(const LimitFuncSceneConfig& other164) {
  limitId = other164.limitId;
  funcId = other164.funcId;
  targetId = other164.targetId;
  __isset = other164.__isset;
}
LimitFuncSceneConfig& LimitFuncSceneConfig::operator=(const LimitFuncSceneConfig& other165) {
  limitId = other165.limitId;
  funcId = other165.funcId;
  targetId = other165.targetId;
  __isset = other165.__isset;
  return *this;
}
void LimitFuncSceneConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LimitFuncSceneConfig(";
  out << "limitId=" << to_string(limitId);
  out << ", " << "funcId=" << to_string(funcId);
  out << ", " << "targetId=" << to_string(targetId);
  out << ")";
}


LimitConfigTable::~LimitConfigTable() throw() {
}


void LimitConfigTable::__set_limitMap(const std::map<int32_t, LimitGroup> & val) {
  this->limitMap = val;
}

uint32_t LimitConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->limitMap.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _ktype167;
            ::apache::thrift::protocol::TType _vtype168;
            xfer += iprot->readMapBegin(_ktype167, _vtype168, _size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              int32_t _key171;
              xfer += iprot->readI32(_key171);
              LimitGroup& _val172 = this->limitMap[_key171];
              xfer += _val172.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.limitMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LimitConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LimitConfigTable");

  xfer += oprot->writeFieldBegin("limitMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->limitMap.size()));
    std::map<int32_t, LimitGroup> ::const_iterator _iter173;
    for (_iter173 = this->limitMap.begin(); _iter173 != this->limitMap.end(); ++_iter173)
    {
      xfer += oprot->writeI32(_iter173->first);
      xfer += _iter173->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LimitConfigTable &a, LimitConfigTable &b) {
  using ::std::swap;
  swap(a.limitMap, b.limitMap);
  swap(a.__isset, b.__isset);
}

LimitConfigTable::LimitConfigTable(const LimitConfigTable& other174) {
  limitMap = other174.limitMap;
  __isset = other174.__isset;
}
LimitConfigTable& LimitConfigTable::operator=(const LimitConfigTable& other175) {
  limitMap = other175.limitMap;
  __isset = other175.__isset;
  return *this;
}
void LimitConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LimitConfigTable(";
  out << "limitMap=" << to_string(limitMap);
  out << ")";
}


FuncConfigTable::~FuncConfigTable() throw() {
}


void FuncConfigTable::__set_funcMap(const std::map<int32_t, FuncGroup> & val) {
  this->funcMap = val;
}

uint32_t FuncConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->funcMap.clear();
            uint32_t _size176;
            ::apache::thrift::protocol::TType _ktype177;
            ::apache::thrift::protocol::TType _vtype178;
            xfer += iprot->readMapBegin(_ktype177, _vtype178, _size176);
            uint32_t _i180;
            for (_i180 = 0; _i180 < _size176; ++_i180)
            {
              int32_t _key181;
              xfer += iprot->readI32(_key181);
              FuncGroup& _val182 = this->funcMap[_key181];
              xfer += _val182.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.funcMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FuncConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FuncConfigTable");

  xfer += oprot->writeFieldBegin("funcMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->funcMap.size()));
    std::map<int32_t, FuncGroup> ::const_iterator _iter183;
    for (_iter183 = this->funcMap.begin(); _iter183 != this->funcMap.end(); ++_iter183)
    {
      xfer += oprot->writeI32(_iter183->first);
      xfer += _iter183->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FuncConfigTable &a, FuncConfigTable &b) {
  using ::std::swap;
  swap(a.funcMap, b.funcMap);
  swap(a.__isset, b.__isset);
}

FuncConfigTable::FuncConfigTable(const FuncConfigTable& other184) {
  funcMap = other184.funcMap;
  __isset = other184.__isset;
}
FuncConfigTable& FuncConfigTable::operator=(const FuncConfigTable& other185) {
  funcMap = other185.funcMap;
  __isset = other185.__isset;
  return *this;
}
void FuncConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FuncConfigTable(";
  out << "funcMap=" << to_string(funcMap);
  out << ")";
}


TargetConfigTable::~TargetConfigTable() throw() {
}


void TargetConfigTable::__set_targetMap(const std::map<int32_t, TargetGroup> & val) {
  this->targetMap = val;
}

uint32_t TargetConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->targetMap.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _ktype187;
            ::apache::thrift::protocol::TType _vtype188;
            xfer += iprot->readMapBegin(_ktype187, _vtype188, _size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              int32_t _key191;
              xfer += iprot->readI32(_key191);
              TargetGroup& _val192 = this->targetMap[_key191];
              xfer += _val192.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.targetMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TargetConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TargetConfigTable");

  xfer += oprot->writeFieldBegin("targetMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->targetMap.size()));
    std::map<int32_t, TargetGroup> ::const_iterator _iter193;
    for (_iter193 = this->targetMap.begin(); _iter193 != this->targetMap.end(); ++_iter193)
    {
      xfer += oprot->writeI32(_iter193->first);
      xfer += _iter193->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TargetConfigTable &a, TargetConfigTable &b) {
  using ::std::swap;
  swap(a.targetMap, b.targetMap);
  swap(a.__isset, b.__isset);
}

TargetConfigTable::TargetConfigTable(const TargetConfigTable& other194) {
  targetMap = other194.targetMap;
  __isset = other194.__isset;
}
TargetConfigTable& TargetConfigTable::operator=(const TargetConfigTable& other195) {
  targetMap = other195.targetMap;
  __isset = other195.__isset;
  return *this;
}
void TargetConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TargetConfigTable(";
  out << "targetMap=" << to_string(targetMap);
  out << ")";
}


LimitFuncSceneConfigTable::~LimitFuncSceneConfigTable() throw() {
}


void LimitFuncSceneConfigTable::__set_limitFuncSceneConfigMap(const std::map<int32_t, std::vector<LimitFuncSceneConfig> > & val) {
  this->limitFuncSceneConfigMap = val;
}

uint32_t LimitFuncSceneConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->limitFuncSceneConfigMap.clear();
            uint32_t _size196;
            ::apache::thrift::protocol::TType _ktype197;
            ::apache::thrift::protocol::TType _vtype198;
            xfer += iprot->readMapBegin(_ktype197, _vtype198, _size196);
            uint32_t _i200;
            for (_i200 = 0; _i200 < _size196; ++_i200)
            {
              int32_t _key201;
              xfer += iprot->readI32(_key201);
              std::vector<LimitFuncSceneConfig> & _val202 = this->limitFuncSceneConfigMap[_key201];
              {
                _val202.clear();
                uint32_t _size203;
                ::apache::thrift::protocol::TType _etype206;
                xfer += iprot->readListBegin(_etype206, _size203);
                _val202.resize(_size203);
                uint32_t _i207;
                for (_i207 = 0; _i207 < _size203; ++_i207)
                {
                  xfer += _val202[_i207].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.limitFuncSceneConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LimitFuncSceneConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LimitFuncSceneConfigTable");

  xfer += oprot->writeFieldBegin("limitFuncSceneConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->limitFuncSceneConfigMap.size()));
    std::map<int32_t, std::vector<LimitFuncSceneConfig> > ::const_iterator _iter208;
    for (_iter208 = this->limitFuncSceneConfigMap.begin(); _iter208 != this->limitFuncSceneConfigMap.end(); ++_iter208)
    {
      xfer += oprot->writeI32(_iter208->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter208->second.size()));
        std::vector<LimitFuncSceneConfig> ::const_iterator _iter209;
        for (_iter209 = _iter208->second.begin(); _iter209 != _iter208->second.end(); ++_iter209)
        {
          xfer += (*_iter209).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LimitFuncSceneConfigTable &a, LimitFuncSceneConfigTable &b) {
  using ::std::swap;
  swap(a.limitFuncSceneConfigMap, b.limitFuncSceneConfigMap);
  swap(a.__isset, b.__isset);
}

LimitFuncSceneConfigTable::LimitFuncSceneConfigTable(const LimitFuncSceneConfigTable& other210) {
  limitFuncSceneConfigMap = other210.limitFuncSceneConfigMap;
  __isset = other210.__isset;
}
LimitFuncSceneConfigTable& LimitFuncSceneConfigTable::operator=(const LimitFuncSceneConfigTable& other211) {
  limitFuncSceneConfigMap = other211.limitFuncSceneConfigMap;
  __isset = other211.__isset;
  return *this;
}
void LimitFuncSceneConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LimitFuncSceneConfigTable(";
  out << "limitFuncSceneConfigMap=" << to_string(limitFuncSceneConfigMap);
  out << ")";
}


BattleBuffConfig::~BattleBuffConfig() throw() {
}


void BattleBuffConfig::__set_id(const int32_t val) {
  this->id = val;
}

void BattleBuffConfig::__set_type(const int32_t val) {
  this->type = val;
}

void BattleBuffConfig::__set_affectType(const int32_t val) {
  this->affectType = val;
}

void BattleBuffConfig::__set_icon(const std::string& val) {
  this->icon = val;
}

void BattleBuffConfig::__set_effectResource(const std::string& val) {
  this->effectResource = val;
}

void BattleBuffConfig::__set_bindPoint(const std::string& val) {
  this->bindPoint = val;
}

void BattleBuffConfig::__set_tickTime(const int32_t val) {
  this->tickTime = val;
}

void BattleBuffConfig::__set_continueTime(const int32_t val) {
  this->continueTime = val;
}

void BattleBuffConfig::__set_addTargetId(const int32_t val) {
  this->addTargetId = val;
}

void BattleBuffConfig::__set_addLimitId(const int32_t val) {
  this->addLimitId = val;
}

void BattleBuffConfig::__set_addFuncId(const int32_t val) {
  this->addFuncId = val;
}

void BattleBuffConfig::__set_tickTargetId(const int32_t val) {
  this->tickTargetId = val;
}

void BattleBuffConfig::__set_tickLimitId(const int32_t val) {
  this->tickLimitId = val;
}

void BattleBuffConfig::__set_tickFuncId(const int32_t val) {
  this->tickFuncId = val;
}

void BattleBuffConfig::__set_delTargetId(const int32_t val) {
  this->delTargetId = val;
}

void BattleBuffConfig::__set_delLimitId(const int32_t val) {
  this->delLimitId = val;
}

void BattleBuffConfig::__set_delFuncId(const int32_t val) {
  this->delFuncId = val;
}

uint32_t BattleBuffConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->affectType);
          this->__isset.affectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->icon);
          this->__isset.icon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->effectResource);
          this->__isset.effectResource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bindPoint);
          this->__isset.bindPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tickTime);
          this->__isset.tickTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->continueTime);
          this->__isset.continueTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->addTargetId);
          this->__isset.addTargetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->addLimitId);
          this->__isset.addLimitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->addFuncId);
          this->__isset.addFuncId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tickTargetId);
          this->__isset.tickTargetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tickLimitId);
          this->__isset.tickLimitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 140:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tickFuncId);
          this->__isset.tickFuncId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 150:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delTargetId);
          this->__isset.delTargetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 160:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delLimitId);
          this->__isset.delLimitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 170:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delFuncId);
          this->__isset.delFuncId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BattleBuffConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BattleBuffConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("affectType", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->affectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("icon", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->icon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("effectResource", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->effectResource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bindPoint", ::apache::thrift::protocol::T_STRING, 60);
  xfer += oprot->writeString(this->bindPoint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tickTime", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->tickTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("continueTime", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->continueTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addTargetId", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->addTargetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addLimitId", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->addLimitId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addFuncId", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->addFuncId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tickTargetId", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->tickTargetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tickLimitId", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32(this->tickLimitId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tickFuncId", ::apache::thrift::protocol::T_I32, 140);
  xfer += oprot->writeI32(this->tickFuncId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delTargetId", ::apache::thrift::protocol::T_I32, 150);
  xfer += oprot->writeI32(this->delTargetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delLimitId", ::apache::thrift::protocol::T_I32, 160);
  xfer += oprot->writeI32(this->delLimitId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delFuncId", ::apache::thrift::protocol::T_I32, 170);
  xfer += oprot->writeI32(this->delFuncId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BattleBuffConfig &a, BattleBuffConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.affectType, b.affectType);
  swap(a.icon, b.icon);
  swap(a.effectResource, b.effectResource);
  swap(a.bindPoint, b.bindPoint);
  swap(a.tickTime, b.tickTime);
  swap(a.continueTime, b.continueTime);
  swap(a.addTargetId, b.addTargetId);
  swap(a.addLimitId, b.addLimitId);
  swap(a.addFuncId, b.addFuncId);
  swap(a.tickTargetId, b.tickTargetId);
  swap(a.tickLimitId, b.tickLimitId);
  swap(a.tickFuncId, b.tickFuncId);
  swap(a.delTargetId, b.delTargetId);
  swap(a.delLimitId, b.delLimitId);
  swap(a.delFuncId, b.delFuncId);
  swap(a.__isset, b.__isset);
}

BattleBuffConfig::BattleBuffConfig(const BattleBuffConfig& other212) {
  id = other212.id;
  type = other212.type;
  affectType = other212.affectType;
  icon = other212.icon;
  effectResource = other212.effectResource;
  bindPoint = other212.bindPoint;
  tickTime = other212.tickTime;
  continueTime = other212.continueTime;
  addTargetId = other212.addTargetId;
  addLimitId = other212.addLimitId;
  addFuncId = other212.addFuncId;
  tickTargetId = other212.tickTargetId;
  tickLimitId = other212.tickLimitId;
  tickFuncId = other212.tickFuncId;
  delTargetId = other212.delTargetId;
  delLimitId = other212.delLimitId;
  delFuncId = other212.delFuncId;
  __isset = other212.__isset;
}
BattleBuffConfig& BattleBuffConfig::operator=(const BattleBuffConfig& other213) {
  id = other213.id;
  type = other213.type;
  affectType = other213.affectType;
  icon = other213.icon;
  effectResource = other213.effectResource;
  bindPoint = other213.bindPoint;
  tickTime = other213.tickTime;
  continueTime = other213.continueTime;
  addTargetId = other213.addTargetId;
  addLimitId = other213.addLimitId;
  addFuncId = other213.addFuncId;
  tickTargetId = other213.tickTargetId;
  tickLimitId = other213.tickLimitId;
  tickFuncId = other213.tickFuncId;
  delTargetId = other213.delTargetId;
  delLimitId = other213.delLimitId;
  delFuncId = other213.delFuncId;
  __isset = other213.__isset;
  return *this;
}
void BattleBuffConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BattleBuffConfig(";
  out << "id=" << to_string(id);
  out << ", " << "type=" << to_string(type);
  out << ", " << "affectType=" << to_string(affectType);
  out << ", " << "icon=" << to_string(icon);
  out << ", " << "effectResource=" << to_string(effectResource);
  out << ", " << "bindPoint=" << to_string(bindPoint);
  out << ", " << "tickTime=" << to_string(tickTime);
  out << ", " << "continueTime=" << to_string(continueTime);
  out << ", " << "addTargetId=" << to_string(addTargetId);
  out << ", " << "addLimitId=" << to_string(addLimitId);
  out << ", " << "addFuncId=" << to_string(addFuncId);
  out << ", " << "tickTargetId=" << to_string(tickTargetId);
  out << ", " << "tickLimitId=" << to_string(tickLimitId);
  out << ", " << "tickFuncId=" << to_string(tickFuncId);
  out << ", " << "delTargetId=" << to_string(delTargetId);
  out << ", " << "delLimitId=" << to_string(delLimitId);
  out << ", " << "delFuncId=" << to_string(delFuncId);
  out << ")";
}


BattleBuffConfigTable::~BattleBuffConfigTable() throw() {
}


void BattleBuffConfigTable::__set_buffConfigMap(const std::map<int32_t, BattleBuffConfig> & val) {
  this->buffConfigMap = val;
}

uint32_t BattleBuffConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->buffConfigMap.clear();
            uint32_t _size214;
            ::apache::thrift::protocol::TType _ktype215;
            ::apache::thrift::protocol::TType _vtype216;
            xfer += iprot->readMapBegin(_ktype215, _vtype216, _size214);
            uint32_t _i218;
            for (_i218 = 0; _i218 < _size214; ++_i218)
            {
              int32_t _key219;
              xfer += iprot->readI32(_key219);
              BattleBuffConfig& _val220 = this->buffConfigMap[_key219];
              xfer += _val220.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.buffConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BattleBuffConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BattleBuffConfigTable");

  xfer += oprot->writeFieldBegin("buffConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->buffConfigMap.size()));
    std::map<int32_t, BattleBuffConfig> ::const_iterator _iter221;
    for (_iter221 = this->buffConfigMap.begin(); _iter221 != this->buffConfigMap.end(); ++_iter221)
    {
      xfer += oprot->writeI32(_iter221->first);
      xfer += _iter221->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BattleBuffConfigTable &a, BattleBuffConfigTable &b) {
  using ::std::swap;
  swap(a.buffConfigMap, b.buffConfigMap);
  swap(a.__isset, b.__isset);
}

BattleBuffConfigTable::BattleBuffConfigTable(const BattleBuffConfigTable& other222) {
  buffConfigMap = other222.buffConfigMap;
  __isset = other222.__isset;
}
BattleBuffConfigTable& BattleBuffConfigTable::operator=(const BattleBuffConfigTable& other223) {
  buffConfigMap = other223.buffConfigMap;
  __isset = other223.__isset;
  return *this;
}
void BattleBuffConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BattleBuffConfigTable(";
  out << "buffConfigMap=" << to_string(buffConfigMap);
  out << ")";
}


SafetyRangePlayerConfig::~SafetyRangePlayerConfig() throw() {
}


void SafetyRangePlayerConfig::__set_id(const int32_t val) {
  this->id = val;
}

void SafetyRangePlayerConfig::__set_starTime(const int32_t val) {
  this->starTime = val;
}

void SafetyRangePlayerConfig::__set_radius(const int32_t val) {
  this->radius = val;
}

void SafetyRangePlayerConfig::__set_radio(const int32_t val) {
  this->radio = val;
}

void SafetyRangePlayerConfig::__set_changeCountDown(const int32_t val) {
  this->changeCountDown = val;
}

void SafetyRangePlayerConfig::__set_hurtIntervalTime(const int32_t val) {
  this->hurtIntervalTime = val;
}

uint32_t SafetyRangePlayerConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->starTime);
          this->__isset.starTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->radius);
          this->__isset.radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->radio);
          this->__isset.radio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->changeCountDown);
          this->__isset.changeCountDown = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hurtIntervalTime);
          this->__isset.hurtIntervalTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SafetyRangePlayerConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SafetyRangePlayerConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("starTime", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->starTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("radius", ::apache::thrift::protocol::T_I32, 25);
  xfer += oprot->writeI32(this->radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("radio", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->radio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changeCountDown", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->changeCountDown);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hurtIntervalTime", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->hurtIntervalTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SafetyRangePlayerConfig &a, SafetyRangePlayerConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.starTime, b.starTime);
  swap(a.radius, b.radius);
  swap(a.radio, b.radio);
  swap(a.changeCountDown, b.changeCountDown);
  swap(a.hurtIntervalTime, b.hurtIntervalTime);
  swap(a.__isset, b.__isset);
}

SafetyRangePlayerConfig::SafetyRangePlayerConfig(const SafetyRangePlayerConfig& other224) {
  id = other224.id;
  starTime = other224.starTime;
  radius = other224.radius;
  radio = other224.radio;
  changeCountDown = other224.changeCountDown;
  hurtIntervalTime = other224.hurtIntervalTime;
  __isset = other224.__isset;
}
SafetyRangePlayerConfig& SafetyRangePlayerConfig::operator=(const SafetyRangePlayerConfig& other225) {
  id = other225.id;
  starTime = other225.starTime;
  radius = other225.radius;
  radio = other225.radio;
  changeCountDown = other225.changeCountDown;
  hurtIntervalTime = other225.hurtIntervalTime;
  __isset = other225.__isset;
  return *this;
}
void SafetyRangePlayerConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SafetyRangePlayerConfig(";
  out << "id=" << to_string(id);
  out << ", " << "starTime=" << to_string(starTime);
  out << ", " << "radius=" << to_string(radius);
  out << ", " << "radio=" << to_string(radio);
  out << ", " << "changeCountDown=" << to_string(changeCountDown);
  out << ", " << "hurtIntervalTime=" << to_string(hurtIntervalTime);
  out << ")";
}


SafetyRangePlayerConfigTable::~SafetyRangePlayerConfigTable() throw() {
}


void SafetyRangePlayerConfigTable::__set_safetyRangePlayerConfigMap(const std::map<int32_t, SafetyRangePlayerConfig> & val) {
  this->safetyRangePlayerConfigMap = val;
}

uint32_t SafetyRangePlayerConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->safetyRangePlayerConfigMap.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _ktype227;
            ::apache::thrift::protocol::TType _vtype228;
            xfer += iprot->readMapBegin(_ktype227, _vtype228, _size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              int32_t _key231;
              xfer += iprot->readI32(_key231);
              SafetyRangePlayerConfig& _val232 = this->safetyRangePlayerConfigMap[_key231];
              xfer += _val232.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.safetyRangePlayerConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SafetyRangePlayerConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SafetyRangePlayerConfigTable");

  xfer += oprot->writeFieldBegin("safetyRangePlayerConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->safetyRangePlayerConfigMap.size()));
    std::map<int32_t, SafetyRangePlayerConfig> ::const_iterator _iter233;
    for (_iter233 = this->safetyRangePlayerConfigMap.begin(); _iter233 != this->safetyRangePlayerConfigMap.end(); ++_iter233)
    {
      xfer += oprot->writeI32(_iter233->first);
      xfer += _iter233->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SafetyRangePlayerConfigTable &a, SafetyRangePlayerConfigTable &b) {
  using ::std::swap;
  swap(a.safetyRangePlayerConfigMap, b.safetyRangePlayerConfigMap);
  swap(a.__isset, b.__isset);
}

SafetyRangePlayerConfigTable::SafetyRangePlayerConfigTable(const SafetyRangePlayerConfigTable& other234) {
  safetyRangePlayerConfigMap = other234.safetyRangePlayerConfigMap;
  __isset = other234.__isset;
}
SafetyRangePlayerConfigTable& SafetyRangePlayerConfigTable::operator=(const SafetyRangePlayerConfigTable& other235) {
  safetyRangePlayerConfigMap = other235.safetyRangePlayerConfigMap;
  __isset = other235.__isset;
  return *this;
}
void SafetyRangePlayerConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SafetyRangePlayerConfigTable(";
  out << "safetyRangePlayerConfigMap=" << to_string(safetyRangePlayerConfigMap);
  out << ")";
}


DrawCageConfig::~DrawCageConfig() throw() {
}


void DrawCageConfig::__set_drawRadius(const int32_t val) {
  this->drawRadius = val;
}

void DrawCageConfig::__set_captureRadius(const double val) {
  this->captureRadius = val;
}

void DrawCageConfig::__set_captureTime(const double val) {
  this->captureTime = val;
}

void DrawCageConfig::__set_cost(const int32_t val) {
  this->cost = val;
}

uint32_t DrawCageConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->drawRadius);
          this->__isset.drawRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->captureRadius);
          this->__isset.captureRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->captureTime);
          this->__isset.captureTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cost);
          this->__isset.cost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DrawCageConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DrawCageConfig");

  xfer += oprot->writeFieldBegin("drawRadius", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->drawRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("captureRadius", ::apache::thrift::protocol::T_DOUBLE, 20);
  xfer += oprot->writeDouble(this->captureRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("captureTime", ::apache::thrift::protocol::T_DOUBLE, 30);
  xfer += oprot->writeDouble(this->captureTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cost", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->cost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DrawCageConfig &a, DrawCageConfig &b) {
  using ::std::swap;
  swap(a.drawRadius, b.drawRadius);
  swap(a.captureRadius, b.captureRadius);
  swap(a.captureTime, b.captureTime);
  swap(a.cost, b.cost);
  swap(a.__isset, b.__isset);
}

DrawCageConfig::DrawCageConfig(const DrawCageConfig& other236) {
  drawRadius = other236.drawRadius;
  captureRadius = other236.captureRadius;
  captureTime = other236.captureTime;
  cost = other236.cost;
  __isset = other236.__isset;
}
DrawCageConfig& DrawCageConfig::operator=(const DrawCageConfig& other237) {
  drawRadius = other237.drawRadius;
  captureRadius = other237.captureRadius;
  captureTime = other237.captureTime;
  cost = other237.cost;
  __isset = other237.__isset;
  return *this;
}
void DrawCageConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DrawCageConfig(";
  out << "drawRadius=" << to_string(drawRadius);
  out << ", " << "captureRadius=" << to_string(captureRadius);
  out << ", " << "captureTime=" << to_string(captureTime);
  out << ", " << "cost=" << to_string(cost);
  out << ")";
}


DrawCageConfigTable::~DrawCageConfigTable() throw() {
}


void DrawCageConfigTable::__set_drawCageMap(const std::map<int32_t, DrawCageConfig> & val) {
  this->drawCageMap = val;
}

uint32_t DrawCageConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->drawCageMap.clear();
            uint32_t _size238;
            ::apache::thrift::protocol::TType _ktype239;
            ::apache::thrift::protocol::TType _vtype240;
            xfer += iprot->readMapBegin(_ktype239, _vtype240, _size238);
            uint32_t _i242;
            for (_i242 = 0; _i242 < _size238; ++_i242)
            {
              int32_t _key243;
              xfer += iprot->readI32(_key243);
              DrawCageConfig& _val244 = this->drawCageMap[_key243];
              xfer += _val244.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.drawCageMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DrawCageConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DrawCageConfigTable");

  xfer += oprot->writeFieldBegin("drawCageMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->drawCageMap.size()));
    std::map<int32_t, DrawCageConfig> ::const_iterator _iter245;
    for (_iter245 = this->drawCageMap.begin(); _iter245 != this->drawCageMap.end(); ++_iter245)
    {
      xfer += oprot->writeI32(_iter245->first);
      xfer += _iter245->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DrawCageConfigTable &a, DrawCageConfigTable &b) {
  using ::std::swap;
  swap(a.drawCageMap, b.drawCageMap);
  swap(a.__isset, b.__isset);
}

DrawCageConfigTable::DrawCageConfigTable(const DrawCageConfigTable& other246) {
  drawCageMap = other246.drawCageMap;
  __isset = other246.__isset;
}
DrawCageConfigTable& DrawCageConfigTable::operator=(const DrawCageConfigTable& other247) {
  drawCageMap = other247.drawCageMap;
  __isset = other247.__isset;
  return *this;
}
void DrawCageConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DrawCageConfigTable(";
  out << "drawCageMap=" << to_string(drawCageMap);
  out << ")";
}


DrawWallConfig::~DrawWallConfig() throw() {
}


void DrawWallConfig::__set_id(const int32_t val) {
  this->id = val;
}

void DrawWallConfig::__set_stage(const double val) {
  this->stage = val;
}

void DrawWallConfig::__set_color(const std::string& val) {
  this->color = val;
}

void DrawWallConfig::__set_hp(const int32_t val) {
  this->hp = val;
}

void DrawWallConfig::__set_dropBlood(const int32_t val) {
  this->dropBlood = val;
}

void DrawWallConfig::__set_cost(const int32_t val) {
  this->cost = val;
}

uint32_t DrawWallConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->stage);
          this->__isset.stage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->color);
          this->__isset.color = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hp);
          this->__isset.hp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dropBlood);
          this->__isset.dropBlood = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cost);
          this->__isset.cost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DrawWallConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DrawWallConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stage", ::apache::thrift::protocol::T_DOUBLE, 20);
  xfer += oprot->writeDouble(this->stage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("color", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->color);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hp", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->hp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropBlood", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->dropBlood);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cost", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->cost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DrawWallConfig &a, DrawWallConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.stage, b.stage);
  swap(a.color, b.color);
  swap(a.hp, b.hp);
  swap(a.dropBlood, b.dropBlood);
  swap(a.cost, b.cost);
  swap(a.__isset, b.__isset);
}

DrawWallConfig::DrawWallConfig(const DrawWallConfig& other248) {
  id = other248.id;
  stage = other248.stage;
  color = other248.color;
  hp = other248.hp;
  dropBlood = other248.dropBlood;
  cost = other248.cost;
  __isset = other248.__isset;
}
DrawWallConfig& DrawWallConfig::operator=(const DrawWallConfig& other249) {
  id = other249.id;
  stage = other249.stage;
  color = other249.color;
  hp = other249.hp;
  dropBlood = other249.dropBlood;
  cost = other249.cost;
  __isset = other249.__isset;
  return *this;
}
void DrawWallConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DrawWallConfig(";
  out << "id=" << to_string(id);
  out << ", " << "stage=" << to_string(stage);
  out << ", " << "color=" << to_string(color);
  out << ", " << "hp=" << to_string(hp);
  out << ", " << "dropBlood=" << to_string(dropBlood);
  out << ", " << "cost=" << to_string(cost);
  out << ")";
}


DrawWallConfigTable::~DrawWallConfigTable() throw() {
}


void DrawWallConfigTable::__set_drawWallMap(const std::map<int32_t, DrawWallConfig> & val) {
  this->drawWallMap = val;
}

uint32_t DrawWallConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->drawWallMap.clear();
            uint32_t _size250;
            ::apache::thrift::protocol::TType _ktype251;
            ::apache::thrift::protocol::TType _vtype252;
            xfer += iprot->readMapBegin(_ktype251, _vtype252, _size250);
            uint32_t _i254;
            for (_i254 = 0; _i254 < _size250; ++_i254)
            {
              int32_t _key255;
              xfer += iprot->readI32(_key255);
              DrawWallConfig& _val256 = this->drawWallMap[_key255];
              xfer += _val256.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.drawWallMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DrawWallConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DrawWallConfigTable");

  xfer += oprot->writeFieldBegin("drawWallMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->drawWallMap.size()));
    std::map<int32_t, DrawWallConfig> ::const_iterator _iter257;
    for (_iter257 = this->drawWallMap.begin(); _iter257 != this->drawWallMap.end(); ++_iter257)
    {
      xfer += oprot->writeI32(_iter257->first);
      xfer += _iter257->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DrawWallConfigTable &a, DrawWallConfigTable &b) {
  using ::std::swap;
  swap(a.drawWallMap, b.drawWallMap);
  swap(a.__isset, b.__isset);
}

DrawWallConfigTable::DrawWallConfigTable(const DrawWallConfigTable& other258) {
  drawWallMap = other258.drawWallMap;
  __isset = other258.__isset;
}
DrawWallConfigTable& DrawWallConfigTable::operator=(const DrawWallConfigTable& other259) {
  drawWallMap = other259.drawWallMap;
  __isset = other259.__isset;
  return *this;
}
void DrawWallConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DrawWallConfigTable(";
  out << "drawWallMap=" << to_string(drawWallMap);
  out << ")";
}


SkillConfig::~SkillConfig() throw() {
}


void SkillConfig::__set_id(const int32_t val) {
  this->id = val;
}

void SkillConfig::__set_targetId(const int32_t val) {
  this->targetId = val;
}

void SkillConfig::__set_limitId(const int32_t val) {
  this->limitId = val;
}

void SkillConfig::__set_funcId(const int32_t val) {
  this->funcId = val;
}

void SkillConfig::__set_icon(const std::string& val) {
  this->icon = val;
}

void SkillConfig::__set_cdTime(const int32_t val) {
  this->cdTime = val;
}

void SkillConfig::__set_maxCount(const int32_t val) {
  this->maxCount = val;
}

void SkillConfig::__set_mpCost(const int32_t val) {
  this->mpCost = val;
}

void SkillConfig::__set_isAend(const bool val) {
  this->isAend = val;
}

void SkillConfig::__set_skillType(const int32_t val) {
  this->skillType = val;
}

void SkillConfig::__set_skillRadiusResource(const std::string& val) {
  this->skillRadiusResource = val;
}

void SkillConfig::__set_skillRadius(const int32_t val) {
  this->skillRadius = val;
}

uint32_t SkillConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetId);
          this->__isset.targetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limitId);
          this->__isset.limitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->funcId);
          this->__isset.funcId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->icon);
          this->__isset.icon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cdTime);
          this->__isset.cdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxCount);
          this->__isset.maxCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mpCost);
          this->__isset.mpCost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAend);
          this->__isset.isAend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->skillType);
          this->__isset.skillType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->skillRadiusResource);
          this->__isset.skillRadiusResource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->skillRadius);
          this->__isset.skillRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SkillConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SkillConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetId", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->targetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limitId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->limitId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("funcId", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->funcId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("icon", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->icon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cdTime", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->cdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxCount", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->maxCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mpCost", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->mpCost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAend", ::apache::thrift::protocol::T_BOOL, 80);
  xfer += oprot->writeBool(this->isAend);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillType", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->skillType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillRadiusResource", ::apache::thrift::protocol::T_STRING, 100);
  xfer += oprot->writeString(this->skillRadiusResource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillRadius", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->skillRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SkillConfig &a, SkillConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targetId, b.targetId);
  swap(a.limitId, b.limitId);
  swap(a.funcId, b.funcId);
  swap(a.icon, b.icon);
  swap(a.cdTime, b.cdTime);
  swap(a.maxCount, b.maxCount);
  swap(a.mpCost, b.mpCost);
  swap(a.isAend, b.isAend);
  swap(a.skillType, b.skillType);
  swap(a.skillRadiusResource, b.skillRadiusResource);
  swap(a.skillRadius, b.skillRadius);
  swap(a.__isset, b.__isset);
}

SkillConfig::SkillConfig(const SkillConfig& other260) {
  id = other260.id;
  targetId = other260.targetId;
  limitId = other260.limitId;
  funcId = other260.funcId;
  icon = other260.icon;
  cdTime = other260.cdTime;
  maxCount = other260.maxCount;
  mpCost = other260.mpCost;
  isAend = other260.isAend;
  skillType = other260.skillType;
  skillRadiusResource = other260.skillRadiusResource;
  skillRadius = other260.skillRadius;
  __isset = other260.__isset;
}
SkillConfig& SkillConfig::operator=(const SkillConfig& other261) {
  id = other261.id;
  targetId = other261.targetId;
  limitId = other261.limitId;
  funcId = other261.funcId;
  icon = other261.icon;
  cdTime = other261.cdTime;
  maxCount = other261.maxCount;
  mpCost = other261.mpCost;
  isAend = other261.isAend;
  skillType = other261.skillType;
  skillRadiusResource = other261.skillRadiusResource;
  skillRadius = other261.skillRadius;
  __isset = other261.__isset;
  return *this;
}
void SkillConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SkillConfig(";
  out << "id=" << to_string(id);
  out << ", " << "targetId=" << to_string(targetId);
  out << ", " << "limitId=" << to_string(limitId);
  out << ", " << "funcId=" << to_string(funcId);
  out << ", " << "icon=" << to_string(icon);
  out << ", " << "cdTime=" << to_string(cdTime);
  out << ", " << "maxCount=" << to_string(maxCount);
  out << ", " << "mpCost=" << to_string(mpCost);
  out << ", " << "isAend=" << to_string(isAend);
  out << ", " << "skillType=" << to_string(skillType);
  out << ", " << "skillRadiusResource=" << to_string(skillRadiusResource);
  out << ", " << "skillRadius=" << to_string(skillRadius);
  out << ")";
}


SkillConfigTable::~SkillConfigTable() throw() {
}


void SkillConfigTable::__set_skillMap(const std::map<int32_t, SkillConfig> & val) {
  this->skillMap = val;
}

uint32_t SkillConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->skillMap.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _ktype263;
            ::apache::thrift::protocol::TType _vtype264;
            xfer += iprot->readMapBegin(_ktype263, _vtype264, _size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              int32_t _key267;
              xfer += iprot->readI32(_key267);
              SkillConfig& _val268 = this->skillMap[_key267];
              xfer += _val268.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.skillMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SkillConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SkillConfigTable");

  xfer += oprot->writeFieldBegin("skillMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->skillMap.size()));
    std::map<int32_t, SkillConfig> ::const_iterator _iter269;
    for (_iter269 = this->skillMap.begin(); _iter269 != this->skillMap.end(); ++_iter269)
    {
      xfer += oprot->writeI32(_iter269->first);
      xfer += _iter269->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SkillConfigTable &a, SkillConfigTable &b) {
  using ::std::swap;
  swap(a.skillMap, b.skillMap);
  swap(a.__isset, b.__isset);
}

SkillConfigTable::SkillConfigTable(const SkillConfigTable& other270) {
  skillMap = other270.skillMap;
  __isset = other270.__isset;
}
SkillConfigTable& SkillConfigTable::operator=(const SkillConfigTable& other271) {
  skillMap = other271.skillMap;
  __isset = other271.__isset;
  return *this;
}
void SkillConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SkillConfigTable(";
  out << "skillMap=" << to_string(skillMap);
  out << ")";
}


InitSkillConfig::~InitSkillConfig() throw() {
}


void InitSkillConfig::__set_id(const int32_t val) {
  this->id = val;
}

void InitSkillConfig::__set_count(const int32_t val) {
  this->count = val;
}

uint32_t InitSkillConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InitSkillConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitSkillConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitSkillConfig &a, InitSkillConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

InitSkillConfig::InitSkillConfig(const InitSkillConfig& other272) {
  id = other272.id;
  count = other272.count;
  __isset = other272.__isset;
}
InitSkillConfig& InitSkillConfig::operator=(const InitSkillConfig& other273) {
  id = other273.id;
  count = other273.count;
  __isset = other273.__isset;
  return *this;
}
void InitSkillConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitSkillConfig(";
  out << "id=" << to_string(id);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


InitSkillConfigTable::~InitSkillConfigTable() throw() {
}


void InitSkillConfigTable::__set_initSkillMap(const std::map<int32_t, InitSkillConfig> & val) {
  this->initSkillMap = val;
}

uint32_t InitSkillConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->initSkillMap.clear();
            uint32_t _size274;
            ::apache::thrift::protocol::TType _ktype275;
            ::apache::thrift::protocol::TType _vtype276;
            xfer += iprot->readMapBegin(_ktype275, _vtype276, _size274);
            uint32_t _i278;
            for (_i278 = 0; _i278 < _size274; ++_i278)
            {
              int32_t _key279;
              xfer += iprot->readI32(_key279);
              InitSkillConfig& _val280 = this->initSkillMap[_key279];
              xfer += _val280.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.initSkillMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InitSkillConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitSkillConfigTable");

  xfer += oprot->writeFieldBegin("initSkillMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->initSkillMap.size()));
    std::map<int32_t, InitSkillConfig> ::const_iterator _iter281;
    for (_iter281 = this->initSkillMap.begin(); _iter281 != this->initSkillMap.end(); ++_iter281)
    {
      xfer += oprot->writeI32(_iter281->first);
      xfer += _iter281->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitSkillConfigTable &a, InitSkillConfigTable &b) {
  using ::std::swap;
  swap(a.initSkillMap, b.initSkillMap);
  swap(a.__isset, b.__isset);
}

InitSkillConfigTable::InitSkillConfigTable(const InitSkillConfigTable& other282) {
  initSkillMap = other282.initSkillMap;
  __isset = other282.__isset;
}
InitSkillConfigTable& InitSkillConfigTable::operator=(const InitSkillConfigTable& other283) {
  initSkillMap = other283.initSkillMap;
  __isset = other283.__isset;
  return *this;
}
void InitSkillConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitSkillConfigTable(";
  out << "initSkillMap=" << to_string(initSkillMap);
  out << ")";
}


MagicConfig::~MagicConfig() throw() {
}


void MagicConfig::__set_id(const int32_t val) {
  this->id = val;
}

void MagicConfig::__set_model(const std::string& val) {
  this->model = val;
}

void MagicConfig::__set_comPrefab(const std::string& val) {
  this->comPrefab = val;
}

void MagicConfig::__set_dieEffect(const std::string& val) {
  this->dieEffect = val;
}

void MagicConfig::__set_maxHp(const int32_t val) {
  this->maxHp = val;
}

void MagicConfig::__set_initSpeed(const int32_t val) {
  this->initSpeed = val;
}

void MagicConfig::__set_initFuncId(const int32_t val) {
  this->initFuncId = val;
}

void MagicConfig::__set_triggerLimitId(const int32_t val) {
  this->triggerLimitId = val;
}

void MagicConfig::__set_triggerFuncId(const int32_t val) {
  this->triggerFuncId = val;
}

void MagicConfig::__set_execTargetId(const int32_t val) {
  this->execTargetId = val;
}

void MagicConfig::__set_execLimitId(const int32_t val) {
  this->execLimitId = val;
}

void MagicConfig::__set_execFuncId(const int32_t val) {
  this->execFuncId = val;
}

void MagicConfig::__set_category(const int32_t val) {
  this->category = val;
}

void MagicConfig::__set_lifeCycle(const int32_t val) {
  this->lifeCycle = val;
}

void MagicConfig::__set_isTracing(const bool val) {
  this->isTracing = val;
}

void MagicConfig::__set_magicClassType(const std::string& val) {
  this->magicClassType = val;
}

uint32_t MagicConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comPrefab);
          this->__isset.comPrefab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dieEffect);
          this->__isset.dieEffect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHp);
          this->__isset.maxHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->initSpeed);
          this->__isset.initSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->initFuncId);
          this->__isset.initFuncId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->triggerLimitId);
          this->__isset.triggerLimitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->triggerFuncId);
          this->__isset.triggerFuncId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->execTargetId);
          this->__isset.execTargetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->execLimitId);
          this->__isset.execLimitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->execFuncId);
          this->__isset.execFuncId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lifeCycle);
          this->__isset.lifeCycle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isTracing);
          this->__isset.isTracing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->magicClassType);
          this->__isset.magicClassType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MagicConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MagicConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->model);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comPrefab", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->comPrefab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dieEffect", ::apache::thrift::protocol::T_STRING, 35);
  xfer += oprot->writeString(this->dieEffect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxHp", ::apache::thrift::protocol::T_I32, 36);
  xfer += oprot->writeI32(this->maxHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initSpeed", ::apache::thrift::protocol::T_I32, 38);
  xfer += oprot->writeI32(this->initSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initFuncId", ::apache::thrift::protocol::T_I32, 39);
  xfer += oprot->writeI32(this->initFuncId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerLimitId", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->triggerLimitId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerFuncId", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->triggerFuncId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execTargetId", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->execTargetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execLimitId", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->execLimitId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("execFuncId", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->execFuncId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lifeCycle", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->lifeCycle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isTracing", ::apache::thrift::protocol::T_BOOL, 110);
  xfer += oprot->writeBool(this->isTracing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("magicClassType", ::apache::thrift::protocol::T_STRING, 120);
  xfer += oprot->writeString(this->magicClassType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MagicConfig &a, MagicConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.model, b.model);
  swap(a.comPrefab, b.comPrefab);
  swap(a.dieEffect, b.dieEffect);
  swap(a.maxHp, b.maxHp);
  swap(a.initSpeed, b.initSpeed);
  swap(a.initFuncId, b.initFuncId);
  swap(a.triggerLimitId, b.triggerLimitId);
  swap(a.triggerFuncId, b.triggerFuncId);
  swap(a.execTargetId, b.execTargetId);
  swap(a.execLimitId, b.execLimitId);
  swap(a.execFuncId, b.execFuncId);
  swap(a.category, b.category);
  swap(a.lifeCycle, b.lifeCycle);
  swap(a.isTracing, b.isTracing);
  swap(a.magicClassType, b.magicClassType);
  swap(a.__isset, b.__isset);
}

MagicConfig::MagicConfig(const MagicConfig& other284) {
  id = other284.id;
  model = other284.model;
  comPrefab = other284.comPrefab;
  dieEffect = other284.dieEffect;
  maxHp = other284.maxHp;
  initSpeed = other284.initSpeed;
  initFuncId = other284.initFuncId;
  triggerLimitId = other284.triggerLimitId;
  triggerFuncId = other284.triggerFuncId;
  execTargetId = other284.execTargetId;
  execLimitId = other284.execLimitId;
  execFuncId = other284.execFuncId;
  category = other284.category;
  lifeCycle = other284.lifeCycle;
  isTracing = other284.isTracing;
  magicClassType = other284.magicClassType;
  __isset = other284.__isset;
}
MagicConfig& MagicConfig::operator=(const MagicConfig& other285) {
  id = other285.id;
  model = other285.model;
  comPrefab = other285.comPrefab;
  dieEffect = other285.dieEffect;
  maxHp = other285.maxHp;
  initSpeed = other285.initSpeed;
  initFuncId = other285.initFuncId;
  triggerLimitId = other285.triggerLimitId;
  triggerFuncId = other285.triggerFuncId;
  execTargetId = other285.execTargetId;
  execLimitId = other285.execLimitId;
  execFuncId = other285.execFuncId;
  category = other285.category;
  lifeCycle = other285.lifeCycle;
  isTracing = other285.isTracing;
  magicClassType = other285.magicClassType;
  __isset = other285.__isset;
  return *this;
}
void MagicConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MagicConfig(";
  out << "id=" << to_string(id);
  out << ", " << "model=" << to_string(model);
  out << ", " << "comPrefab=" << to_string(comPrefab);
  out << ", " << "dieEffect=" << to_string(dieEffect);
  out << ", " << "maxHp=" << to_string(maxHp);
  out << ", " << "initSpeed=" << to_string(initSpeed);
  out << ", " << "initFuncId=" << to_string(initFuncId);
  out << ", " << "triggerLimitId=" << to_string(triggerLimitId);
  out << ", " << "triggerFuncId=" << to_string(triggerFuncId);
  out << ", " << "execTargetId=" << to_string(execTargetId);
  out << ", " << "execLimitId=" << to_string(execLimitId);
  out << ", " << "execFuncId=" << to_string(execFuncId);
  out << ", " << "category=" << to_string(category);
  out << ", " << "lifeCycle=" << to_string(lifeCycle);
  out << ", " << "isTracing=" << to_string(isTracing);
  out << ", " << "magicClassType=" << to_string(magicClassType);
  out << ")";
}


MagicConfigTable::~MagicConfigTable() throw() {
}


void MagicConfigTable::__set_magicMap(const std::map<int32_t, MagicConfig> & val) {
  this->magicMap = val;
}

uint32_t MagicConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->magicMap.clear();
            uint32_t _size286;
            ::apache::thrift::protocol::TType _ktype287;
            ::apache::thrift::protocol::TType _vtype288;
            xfer += iprot->readMapBegin(_ktype287, _vtype288, _size286);
            uint32_t _i290;
            for (_i290 = 0; _i290 < _size286; ++_i290)
            {
              int32_t _key291;
              xfer += iprot->readI32(_key291);
              MagicConfig& _val292 = this->magicMap[_key291];
              xfer += _val292.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.magicMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MagicConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MagicConfigTable");

  xfer += oprot->writeFieldBegin("magicMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->magicMap.size()));
    std::map<int32_t, MagicConfig> ::const_iterator _iter293;
    for (_iter293 = this->magicMap.begin(); _iter293 != this->magicMap.end(); ++_iter293)
    {
      xfer += oprot->writeI32(_iter293->first);
      xfer += _iter293->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MagicConfigTable &a, MagicConfigTable &b) {
  using ::std::swap;
  swap(a.magicMap, b.magicMap);
  swap(a.__isset, b.__isset);
}

MagicConfigTable::MagicConfigTable(const MagicConfigTable& other294) {
  magicMap = other294.magicMap;
  __isset = other294.__isset;
}
MagicConfigTable& MagicConfigTable::operator=(const MagicConfigTable& other295) {
  magicMap = other295.magicMap;
  __isset = other295.__isset;
  return *this;
}
void MagicConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MagicConfigTable(";
  out << "magicMap=" << to_string(magicMap);
  out << ")";
}


CategoriesConfig::~CategoriesConfig() throw() {
}


void CategoriesConfig::__set_id(const int32_t val) {
  this->id = val;
}

void CategoriesConfig::__set_type(const int32_t val) {
  this->type = val;
}

uint32_t CategoriesConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CategoriesConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CategoriesConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CategoriesConfig &a, CategoriesConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

CategoriesConfig::CategoriesConfig(const CategoriesConfig& other296) {
  id = other296.id;
  type = other296.type;
  __isset = other296.__isset;
}
CategoriesConfig& CategoriesConfig::operator=(const CategoriesConfig& other297) {
  id = other297.id;
  type = other297.type;
  __isset = other297.__isset;
  return *this;
}
void CategoriesConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CategoriesConfig(";
  out << "id=" << to_string(id);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


CategoriesConfigTable::~CategoriesConfigTable() throw() {
}


void CategoriesConfigTable::__set_categoriesMap(const std::map<int32_t, CategoriesConfig> & val) {
  this->categoriesMap = val;
}

uint32_t CategoriesConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->categoriesMap.clear();
            uint32_t _size298;
            ::apache::thrift::protocol::TType _ktype299;
            ::apache::thrift::protocol::TType _vtype300;
            xfer += iprot->readMapBegin(_ktype299, _vtype300, _size298);
            uint32_t _i302;
            for (_i302 = 0; _i302 < _size298; ++_i302)
            {
              int32_t _key303;
              xfer += iprot->readI32(_key303);
              CategoriesConfig& _val304 = this->categoriesMap[_key303];
              xfer += _val304.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.categoriesMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CategoriesConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CategoriesConfigTable");

  xfer += oprot->writeFieldBegin("categoriesMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->categoriesMap.size()));
    std::map<int32_t, CategoriesConfig> ::const_iterator _iter305;
    for (_iter305 = this->categoriesMap.begin(); _iter305 != this->categoriesMap.end(); ++_iter305)
    {
      xfer += oprot->writeI32(_iter305->first);
      xfer += _iter305->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CategoriesConfigTable &a, CategoriesConfigTable &b) {
  using ::std::swap;
  swap(a.categoriesMap, b.categoriesMap);
  swap(a.__isset, b.__isset);
}

CategoriesConfigTable::CategoriesConfigTable(const CategoriesConfigTable& other306) {
  categoriesMap = other306.categoriesMap;
  __isset = other306.__isset;
}
CategoriesConfigTable& CategoriesConfigTable::operator=(const CategoriesConfigTable& other307) {
  categoriesMap = other307.categoriesMap;
  __isset = other307.__isset;
  return *this;
}
void CategoriesConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CategoriesConfigTable(";
  out << "categoriesMap=" << to_string(categoriesMap);
  out << ")";
}


ModelColliders::~ModelColliders() throw() {
}


void ModelColliders::__set_sizeRadius(const int32_t val) {
  this->sizeRadius = val;
}

void ModelColliders::__set_boxSize(const  ::TVector3& val) {
  this->boxSize = val;
}

void ModelColliders::__set_triggerRadius(const int32_t val) {
  this->triggerRadius = val;
}

void ModelColliders::__set_triggerSize(const  ::TVector3& val) {
  this->triggerSize = val;
}

uint32_t ModelColliders::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sizeRadius);
          this->__isset.sizeRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->boxSize.read(iprot);
          this->__isset.boxSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->triggerRadius);
          this->__isset.triggerRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->triggerSize.read(iprot);
          this->__isset.triggerSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelColliders::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelColliders");

  xfer += oprot->writeFieldBegin("sizeRadius", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->sizeRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("boxSize", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->boxSize.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerRadius", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->triggerRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerSize", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->triggerSize.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelColliders &a, ModelColliders &b) {
  using ::std::swap;
  swap(a.sizeRadius, b.sizeRadius);
  swap(a.boxSize, b.boxSize);
  swap(a.triggerRadius, b.triggerRadius);
  swap(a.triggerSize, b.triggerSize);
  swap(a.__isset, b.__isset);
}

ModelColliders::ModelColliders(const ModelColliders& other308) {
  sizeRadius = other308.sizeRadius;
  boxSize = other308.boxSize;
  triggerRadius = other308.triggerRadius;
  triggerSize = other308.triggerSize;
  __isset = other308.__isset;
}
ModelColliders& ModelColliders::operator=(const ModelColliders& other309) {
  sizeRadius = other309.sizeRadius;
  boxSize = other309.boxSize;
  triggerRadius = other309.triggerRadius;
  triggerSize = other309.triggerSize;
  __isset = other309.__isset;
  return *this;
}
void ModelColliders::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelColliders(";
  out << "sizeRadius=" << to_string(sizeRadius);
  out << ", " << "boxSize=" << to_string(boxSize);
  out << ", " << "triggerRadius=" << to_string(triggerRadius);
  out << ", " << "triggerSize=" << to_string(triggerSize);
  out << ")";
}


ModelCollidersConfig::~ModelCollidersConfig() throw() {
}


void ModelCollidersConfig::__set_modelColliderMap(const std::map<int32_t, ModelColliders> & val) {
  this->modelColliderMap = val;
}

uint32_t ModelCollidersConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->modelColliderMap.clear();
            uint32_t _size310;
            ::apache::thrift::protocol::TType _ktype311;
            ::apache::thrift::protocol::TType _vtype312;
            xfer += iprot->readMapBegin(_ktype311, _vtype312, _size310);
            uint32_t _i314;
            for (_i314 = 0; _i314 < _size310; ++_i314)
            {
              int32_t _key315;
              xfer += iprot->readI32(_key315);
              ModelColliders& _val316 = this->modelColliderMap[_key315];
              xfer += _val316.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.modelColliderMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModelCollidersConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModelCollidersConfig");

  xfer += oprot->writeFieldBegin("modelColliderMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->modelColliderMap.size()));
    std::map<int32_t, ModelColliders> ::const_iterator _iter317;
    for (_iter317 = this->modelColliderMap.begin(); _iter317 != this->modelColliderMap.end(); ++_iter317)
    {
      xfer += oprot->writeI32(_iter317->first);
      xfer += _iter317->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModelCollidersConfig &a, ModelCollidersConfig &b) {
  using ::std::swap;
  swap(a.modelColliderMap, b.modelColliderMap);
  swap(a.__isset, b.__isset);
}

ModelCollidersConfig::ModelCollidersConfig(const ModelCollidersConfig& other318) {
  modelColliderMap = other318.modelColliderMap;
  __isset = other318.__isset;
}
ModelCollidersConfig& ModelCollidersConfig::operator=(const ModelCollidersConfig& other319) {
  modelColliderMap = other319.modelColliderMap;
  __isset = other319.__isset;
  return *this;
}
void ModelCollidersConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModelCollidersConfig(";
  out << "modelColliderMap=" << to_string(modelColliderMap);
  out << ")";
}


ShipConfig::~ShipConfig() throw() {
}


void ShipConfig::__set_id(const int32_t val) {
  this->id = val;
}

void ShipConfig::__set_shipName(const std::string& val) {
  this->shipName = val;
}

void ShipConfig::__set_shipIcon(const std::string& val) {
  this->shipIcon = val;
}

void ShipConfig::__set_level(const int32_t val) {
  this->level = val;
}

void ShipConfig::__set_icon(const std::string& val) {
  this->icon = val;
}

void ShipConfig::__set_speed(const int32_t val) {
  this->speed = val;
}

void ShipConfig::__set_driverSlotCount(const int32_t val) {
  this->driverSlotCount = val;
}

void ShipConfig::__set_shooterSlotCount(const int32_t val) {
  this->shooterSlotCount = val;
}

void ShipConfig::__set_uniqueSkillCount(const int32_t val) {
  this->uniqueSkillCount = val;
}

void ShipConfig::__set_uniqueSkillIds(const std::vector<int32_t> & val) {
  this->uniqueSkillIds = val;
}

void ShipConfig::__set_attack(const int32_t val) {
  this->attack = val;
}

void ShipConfig::__set_shootRate(const int32_t val) {
  this->shootRate = val;
}

void ShipConfig::__set_maxMp(const int32_t val) {
  this->maxMp = val;
}

void ShipConfig::__set_mpExpend(const int32_t val) {
  this->mpExpend = val;
}

void ShipConfig::__set_bloodGrid(const int32_t val) {
  this->bloodGrid = val;
}

void ShipConfig::__set_timeLimit(const int32_t val) {
  this->timeLimit = val;
}

void ShipConfig::__set_maxHp(const int32_t val) {
  this->maxHp = val;
}

void ShipConfig::__set_sight(const int32_t val) {
  this->sight = val;
}

void ShipConfig::__set_searchLightOffset(const int32_t val) {
  this->searchLightOffset = val;
}

void ShipConfig::__set_searchLightRadius(const int32_t val) {
  this->searchLightRadius = val;
}

void ShipConfig::__set_shooterRadarTime(const int32_t val) {
  this->shooterRadarTime = val;
}

void ShipConfig::__set_skillRadarTime(const int32_t val) {
  this->skillRadarTime = val;
}

void ShipConfig::__set_slayRadarTime(const int32_t val) {
  this->slayRadarTime = val;
}

void ShipConfig::__set_bulletSpeed(const int32_t val) {
  this->bulletSpeed = val;
}

void ShipConfig::__set_bulletSight(const int32_t val) {
  this->bulletSight = val;
}

void ShipConfig::__set_bulletCarry(const int32_t val) {
  this->bulletCarry = val;
}

void ShipConfig::__set_ChargeAngularSpeed(const int32_t val) {
  this->ChargeAngularSpeed = val;
}

void ShipConfig::__set_ChargeSpeed(const int32_t val) {
  this->ChargeSpeed = val;
}

void ShipConfig::__set_rotationSpeed(const int32_t val) {
  this->rotationSpeed = val;
}

void ShipConfig::__set_norRenLv(const int32_t val) {
  this->norRenLv = val;
}

void ShipConfig::__set_enemyAtkRenLv(const int32_t val) {
  this->enemyAtkRenLv = val;
}

void ShipConfig::__set_enemyRenLv(const int32_t val) {
  this->enemyRenLv = val;
}

uint32_t ShipConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->shipName);
          this->__isset.shipName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->shipIcon);
          this->__isset.shipIcon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->icon);
          this->__isset.icon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->speed);
          this->__isset.speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->driverSlotCount);
          this->__isset.driverSlotCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 45:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shooterSlotCount);
          this->__isset.shooterSlotCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uniqueSkillCount);
          this->__isset.uniqueSkillCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 55:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueSkillIds.clear();
            uint32_t _size320;
            ::apache::thrift::protocol::TType _etype323;
            xfer += iprot->readListBegin(_etype323, _size320);
            this->uniqueSkillIds.resize(_size320);
            uint32_t _i324;
            for (_i324 = 0; _i324 < _size320; ++_i324)
            {
              xfer += iprot->readI32(this->uniqueSkillIds[_i324]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.uniqueSkillIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attack);
          this->__isset.attack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shootRate);
          this->__isset.shootRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxMp);
          this->__isset.maxMp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 85:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mpExpend);
          this->__isset.mpExpend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bloodGrid);
          this->__isset.bloodGrid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 95:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeLimit);
          this->__isset.timeLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHp);
          this->__isset.maxHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sight);
          this->__isset.sight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->searchLightOffset);
          this->__isset.searchLightOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->searchLightRadius);
          this->__isset.searchLightRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 140:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shooterRadarTime);
          this->__isset.shooterRadarTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 150:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->skillRadarTime);
          this->__isset.skillRadarTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 160:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slayRadarTime);
          this->__isset.slayRadarTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 170:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bulletSpeed);
          this->__isset.bulletSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 180:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bulletSight);
          this->__isset.bulletSight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 190:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bulletCarry);
          this->__isset.bulletCarry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 220:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ChargeAngularSpeed);
          this->__isset.ChargeAngularSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 230:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ChargeSpeed);
          this->__isset.ChargeSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 240:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rotationSpeed);
          this->__isset.rotationSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 250:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->norRenLv);
          this->__isset.norRenLv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 260:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->enemyAtkRenLv);
          this->__isset.enemyAtkRenLv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 270:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->enemyRenLv);
          this->__isset.enemyRenLv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShipConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShipConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shipName", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->shipName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shipIcon", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->shipIcon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("icon", ::apache::thrift::protocol::T_STRING, 25);
  xfer += oprot->writeString(this->icon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speed", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("driverSlotCount", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->driverSlotCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shooterSlotCount", ::apache::thrift::protocol::T_I32, 45);
  xfer += oprot->writeI32(this->shooterSlotCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uniqueSkillCount", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->uniqueSkillCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uniqueSkillIds", ::apache::thrift::protocol::T_LIST, 55);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->uniqueSkillIds.size()));
    std::vector<int32_t> ::const_iterator _iter325;
    for (_iter325 = this->uniqueSkillIds.begin(); _iter325 != this->uniqueSkillIds.end(); ++_iter325)
    {
      xfer += oprot->writeI32((*_iter325));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attack", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->attack);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shootRate", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->shootRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxMp", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->maxMp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mpExpend", ::apache::thrift::protocol::T_I32, 85);
  xfer += oprot->writeI32(this->mpExpend);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bloodGrid", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->bloodGrid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeLimit", ::apache::thrift::protocol::T_I32, 95);
  xfer += oprot->writeI32(this->timeLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxHp", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->maxHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sight", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->sight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("searchLightOffset", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->searchLightOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("searchLightRadius", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32(this->searchLightRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shooterRadarTime", ::apache::thrift::protocol::T_I32, 140);
  xfer += oprot->writeI32(this->shooterRadarTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillRadarTime", ::apache::thrift::protocol::T_I32, 150);
  xfer += oprot->writeI32(this->skillRadarTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slayRadarTime", ::apache::thrift::protocol::T_I32, 160);
  xfer += oprot->writeI32(this->slayRadarTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulletSpeed", ::apache::thrift::protocol::T_I32, 170);
  xfer += oprot->writeI32(this->bulletSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulletSight", ::apache::thrift::protocol::T_I32, 180);
  xfer += oprot->writeI32(this->bulletSight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulletCarry", ::apache::thrift::protocol::T_I32, 190);
  xfer += oprot->writeI32(this->bulletCarry);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ChargeAngularSpeed", ::apache::thrift::protocol::T_I32, 220);
  xfer += oprot->writeI32(this->ChargeAngularSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ChargeSpeed", ::apache::thrift::protocol::T_I32, 230);
  xfer += oprot->writeI32(this->ChargeSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotationSpeed", ::apache::thrift::protocol::T_I32, 240);
  xfer += oprot->writeI32(this->rotationSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("norRenLv", ::apache::thrift::protocol::T_I32, 250);
  xfer += oprot->writeI32(this->norRenLv);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enemyAtkRenLv", ::apache::thrift::protocol::T_I32, 260);
  xfer += oprot->writeI32(this->enemyAtkRenLv);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enemyRenLv", ::apache::thrift::protocol::T_I32, 270);
  xfer += oprot->writeI32(this->enemyRenLv);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShipConfig &a, ShipConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.shipName, b.shipName);
  swap(a.shipIcon, b.shipIcon);
  swap(a.level, b.level);
  swap(a.icon, b.icon);
  swap(a.speed, b.speed);
  swap(a.driverSlotCount, b.driverSlotCount);
  swap(a.shooterSlotCount, b.shooterSlotCount);
  swap(a.uniqueSkillCount, b.uniqueSkillCount);
  swap(a.uniqueSkillIds, b.uniqueSkillIds);
  swap(a.attack, b.attack);
  swap(a.shootRate, b.shootRate);
  swap(a.maxMp, b.maxMp);
  swap(a.mpExpend, b.mpExpend);
  swap(a.bloodGrid, b.bloodGrid);
  swap(a.timeLimit, b.timeLimit);
  swap(a.maxHp, b.maxHp);
  swap(a.sight, b.sight);
  swap(a.searchLightOffset, b.searchLightOffset);
  swap(a.searchLightRadius, b.searchLightRadius);
  swap(a.shooterRadarTime, b.shooterRadarTime);
  swap(a.skillRadarTime, b.skillRadarTime);
  swap(a.slayRadarTime, b.slayRadarTime);
  swap(a.bulletSpeed, b.bulletSpeed);
  swap(a.bulletSight, b.bulletSight);
  swap(a.bulletCarry, b.bulletCarry);
  swap(a.ChargeAngularSpeed, b.ChargeAngularSpeed);
  swap(a.ChargeSpeed, b.ChargeSpeed);
  swap(a.rotationSpeed, b.rotationSpeed);
  swap(a.norRenLv, b.norRenLv);
  swap(a.enemyAtkRenLv, b.enemyAtkRenLv);
  swap(a.enemyRenLv, b.enemyRenLv);
  swap(a.__isset, b.__isset);
}

ShipConfig::ShipConfig(const ShipConfig& other326) {
  id = other326.id;
  shipName = other326.shipName;
  shipIcon = other326.shipIcon;
  level = other326.level;
  icon = other326.icon;
  speed = other326.speed;
  driverSlotCount = other326.driverSlotCount;
  shooterSlotCount = other326.shooterSlotCount;
  uniqueSkillCount = other326.uniqueSkillCount;
  uniqueSkillIds = other326.uniqueSkillIds;
  attack = other326.attack;
  shootRate = other326.shootRate;
  maxMp = other326.maxMp;
  mpExpend = other326.mpExpend;
  bloodGrid = other326.bloodGrid;
  timeLimit = other326.timeLimit;
  maxHp = other326.maxHp;
  sight = other326.sight;
  searchLightOffset = other326.searchLightOffset;
  searchLightRadius = other326.searchLightRadius;
  shooterRadarTime = other326.shooterRadarTime;
  skillRadarTime = other326.skillRadarTime;
  slayRadarTime = other326.slayRadarTime;
  bulletSpeed = other326.bulletSpeed;
  bulletSight = other326.bulletSight;
  bulletCarry = other326.bulletCarry;
  ChargeAngularSpeed = other326.ChargeAngularSpeed;
  ChargeSpeed = other326.ChargeSpeed;
  rotationSpeed = other326.rotationSpeed;
  norRenLv = other326.norRenLv;
  enemyAtkRenLv = other326.enemyAtkRenLv;
  enemyRenLv = other326.enemyRenLv;
  __isset = other326.__isset;
}
ShipConfig& ShipConfig::operator=(const ShipConfig& other327) {
  id = other327.id;
  shipName = other327.shipName;
  shipIcon = other327.shipIcon;
  level = other327.level;
  icon = other327.icon;
  speed = other327.speed;
  driverSlotCount = other327.driverSlotCount;
  shooterSlotCount = other327.shooterSlotCount;
  uniqueSkillCount = other327.uniqueSkillCount;
  uniqueSkillIds = other327.uniqueSkillIds;
  attack = other327.attack;
  shootRate = other327.shootRate;
  maxMp = other327.maxMp;
  mpExpend = other327.mpExpend;
  bloodGrid = other327.bloodGrid;
  timeLimit = other327.timeLimit;
  maxHp = other327.maxHp;
  sight = other327.sight;
  searchLightOffset = other327.searchLightOffset;
  searchLightRadius = other327.searchLightRadius;
  shooterRadarTime = other327.shooterRadarTime;
  skillRadarTime = other327.skillRadarTime;
  slayRadarTime = other327.slayRadarTime;
  bulletSpeed = other327.bulletSpeed;
  bulletSight = other327.bulletSight;
  bulletCarry = other327.bulletCarry;
  ChargeAngularSpeed = other327.ChargeAngularSpeed;
  ChargeSpeed = other327.ChargeSpeed;
  rotationSpeed = other327.rotationSpeed;
  norRenLv = other327.norRenLv;
  enemyAtkRenLv = other327.enemyAtkRenLv;
  enemyRenLv = other327.enemyRenLv;
  __isset = other327.__isset;
  return *this;
}
void ShipConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShipConfig(";
  out << "id=" << to_string(id);
  out << ", " << "shipName=" << to_string(shipName);
  out << ", " << "shipIcon=" << to_string(shipIcon);
  out << ", " << "level=" << to_string(level);
  out << ", " << "icon=" << to_string(icon);
  out << ", " << "speed=" << to_string(speed);
  out << ", " << "driverSlotCount=" << to_string(driverSlotCount);
  out << ", " << "shooterSlotCount=" << to_string(shooterSlotCount);
  out << ", " << "uniqueSkillCount=" << to_string(uniqueSkillCount);
  out << ", " << "uniqueSkillIds=" << to_string(uniqueSkillIds);
  out << ", " << "attack=" << to_string(attack);
  out << ", " << "shootRate=" << to_string(shootRate);
  out << ", " << "maxMp=" << to_string(maxMp);
  out << ", " << "mpExpend=" << to_string(mpExpend);
  out << ", " << "bloodGrid=" << to_string(bloodGrid);
  out << ", " << "timeLimit=" << to_string(timeLimit);
  out << ", " << "maxHp=" << to_string(maxHp);
  out << ", " << "sight=" << to_string(sight);
  out << ", " << "searchLightOffset=" << to_string(searchLightOffset);
  out << ", " << "searchLightRadius=" << to_string(searchLightRadius);
  out << ", " << "shooterRadarTime=" << to_string(shooterRadarTime);
  out << ", " << "skillRadarTime=" << to_string(skillRadarTime);
  out << ", " << "slayRadarTime=" << to_string(slayRadarTime);
  out << ", " << "bulletSpeed=" << to_string(bulletSpeed);
  out << ", " << "bulletSight=" << to_string(bulletSight);
  out << ", " << "bulletCarry=" << to_string(bulletCarry);
  out << ", " << "ChargeAngularSpeed=" << to_string(ChargeAngularSpeed);
  out << ", " << "ChargeSpeed=" << to_string(ChargeSpeed);
  out << ", " << "rotationSpeed=" << to_string(rotationSpeed);
  out << ", " << "norRenLv=" << to_string(norRenLv);
  out << ", " << "enemyAtkRenLv=" << to_string(enemyAtkRenLv);
  out << ", " << "enemyRenLv=" << to_string(enemyRenLv);
  out << ")";
}


ShipConfigTable::~ShipConfigTable() throw() {
}


void ShipConfigTable::__set_shipMap(const std::map<int32_t, ShipConfig> & val) {
  this->shipMap = val;
}

uint32_t ShipConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->shipMap.clear();
            uint32_t _size328;
            ::apache::thrift::protocol::TType _ktype329;
            ::apache::thrift::protocol::TType _vtype330;
            xfer += iprot->readMapBegin(_ktype329, _vtype330, _size328);
            uint32_t _i332;
            for (_i332 = 0; _i332 < _size328; ++_i332)
            {
              int32_t _key333;
              xfer += iprot->readI32(_key333);
              ShipConfig& _val334 = this->shipMap[_key333];
              xfer += _val334.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.shipMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShipConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShipConfigTable");

  xfer += oprot->writeFieldBegin("shipMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->shipMap.size()));
    std::map<int32_t, ShipConfig> ::const_iterator _iter335;
    for (_iter335 = this->shipMap.begin(); _iter335 != this->shipMap.end(); ++_iter335)
    {
      xfer += oprot->writeI32(_iter335->first);
      xfer += _iter335->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShipConfigTable &a, ShipConfigTable &b) {
  using ::std::swap;
  swap(a.shipMap, b.shipMap);
  swap(a.__isset, b.__isset);
}

ShipConfigTable::ShipConfigTable(const ShipConfigTable& other336) {
  shipMap = other336.shipMap;
  __isset = other336.__isset;
}
ShipConfigTable& ShipConfigTable::operator=(const ShipConfigTable& other337) {
  shipMap = other337.shipMap;
  __isset = other337.__isset;
  return *this;
}
void ShipConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShipConfigTable(";
  out << "shipMap=" << to_string(shipMap);
  out << ")";
}


GameSetConfig::~GameSetConfig() throw() {
}


void GameSetConfig::__set_id(const int32_t val) {
  this->id = val;
}

void GameSetConfig::__set_plan(const int32_t val) {
  this->plan = val;
}

void GameSetConfig::__set_mapId(const int32_t val) {
  this->mapId = val;
}

void GameSetConfig::__set_rhythmFactor(const int32_t val) {
  this->rhythmFactor = val;
}

uint32_t GameSetConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->plan);
          this->__isset.plan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mapId);
          this->__isset.mapId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rhythmFactor);
          this->__isset.rhythmFactor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GameSetConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GameSetConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("plan", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->plan);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapId", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->mapId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rhythmFactor", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->rhythmFactor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GameSetConfig &a, GameSetConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.plan, b.plan);
  swap(a.mapId, b.mapId);
  swap(a.rhythmFactor, b.rhythmFactor);
  swap(a.__isset, b.__isset);
}

GameSetConfig::GameSetConfig(const GameSetConfig& other338) {
  id = other338.id;
  plan = other338.plan;
  mapId = other338.mapId;
  rhythmFactor = other338.rhythmFactor;
  __isset = other338.__isset;
}
GameSetConfig& GameSetConfig::operator=(const GameSetConfig& other339) {
  id = other339.id;
  plan = other339.plan;
  mapId = other339.mapId;
  rhythmFactor = other339.rhythmFactor;
  __isset = other339.__isset;
  return *this;
}
void GameSetConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GameSetConfig(";
  out << "id=" << to_string(id);
  out << ", " << "plan=" << to_string(plan);
  out << ", " << "mapId=" << to_string(mapId);
  out << ", " << "rhythmFactor=" << to_string(rhythmFactor);
  out << ")";
}


GameSetConfigTable::~GameSetConfigTable() throw() {
}


void GameSetConfigTable::__set_gameSetMap(const std::map<int32_t, GameSetConfig> & val) {
  this->gameSetMap = val;
}

uint32_t GameSetConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->gameSetMap.clear();
            uint32_t _size340;
            ::apache::thrift::protocol::TType _ktype341;
            ::apache::thrift::protocol::TType _vtype342;
            xfer += iprot->readMapBegin(_ktype341, _vtype342, _size340);
            uint32_t _i344;
            for (_i344 = 0; _i344 < _size340; ++_i344)
            {
              int32_t _key345;
              xfer += iprot->readI32(_key345);
              GameSetConfig& _val346 = this->gameSetMap[_key345];
              xfer += _val346.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.gameSetMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GameSetConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GameSetConfigTable");

  xfer += oprot->writeFieldBegin("gameSetMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->gameSetMap.size()));
    std::map<int32_t, GameSetConfig> ::const_iterator _iter347;
    for (_iter347 = this->gameSetMap.begin(); _iter347 != this->gameSetMap.end(); ++_iter347)
    {
      xfer += oprot->writeI32(_iter347->first);
      xfer += _iter347->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GameSetConfigTable &a, GameSetConfigTable &b) {
  using ::std::swap;
  swap(a.gameSetMap, b.gameSetMap);
  swap(a.__isset, b.__isset);
}

GameSetConfigTable::GameSetConfigTable(const GameSetConfigTable& other348) {
  gameSetMap = other348.gameSetMap;
  __isset = other348.__isset;
}
GameSetConfigTable& GameSetConfigTable::operator=(const GameSetConfigTable& other349) {
  gameSetMap = other349.gameSetMap;
  __isset = other349.__isset;
  return *this;
}
void GameSetConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GameSetConfigTable(";
  out << "gameSetMap=" << to_string(gameSetMap);
  out << ")";
}


HomeConfigTable::~HomeConfigTable() throw() {
}


void HomeConfigTable::__set_id(const int32_t val) {
  this->id = val;
}

void HomeConfigTable::__set_category(const int32_t val) {
  this->category = val;
}

void HomeConfigTable::__set_comPrefab(const std::string& val) {
  this->comPrefab = val;
}

void HomeConfigTable::__set_resource(const std::string& val) {
  this->resource = val;
}

void HomeConfigTable::__set_maxHp(const int32_t val) {
  this->maxHp = val;
}

uint32_t HomeConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comPrefab);
          this->__isset.comPrefab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource);
          this->__isset.resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHp);
          this->__isset.maxHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HomeConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HomeConfigTable");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comPrefab", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->comPrefab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->resource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxHp", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->maxHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HomeConfigTable &a, HomeConfigTable &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.category, b.category);
  swap(a.comPrefab, b.comPrefab);
  swap(a.resource, b.resource);
  swap(a.maxHp, b.maxHp);
  swap(a.__isset, b.__isset);
}

HomeConfigTable::HomeConfigTable(const HomeConfigTable& other350) {
  id = other350.id;
  category = other350.category;
  comPrefab = other350.comPrefab;
  resource = other350.resource;
  maxHp = other350.maxHp;
  __isset = other350.__isset;
}
HomeConfigTable& HomeConfigTable::operator=(const HomeConfigTable& other351) {
  id = other351.id;
  category = other351.category;
  comPrefab = other351.comPrefab;
  resource = other351.resource;
  maxHp = other351.maxHp;
  __isset = other351.__isset;
  return *this;
}
void HomeConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HomeConfigTable(";
  out << "id=" << to_string(id);
  out << ", " << "category=" << to_string(category);
  out << ", " << "comPrefab=" << to_string(comPrefab);
  out << ", " << "resource=" << to_string(resource);
  out << ", " << "maxHp=" << to_string(maxHp);
  out << ")";
}


DeBuffConfig::~DeBuffConfig() throw() {
}


void DeBuffConfig::__set_deBuffId(const int32_t val) {
  this->deBuffId = val;
}

void DeBuffConfig::__set_weight(const int32_t val) {
  this->weight = val;
}

uint32_t DeBuffConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deBuffId);
          this->__isset.deBuffId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeBuffConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeBuffConfig");

  xfer += oprot->writeFieldBegin("deBuffId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->deBuffId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeBuffConfig &a, DeBuffConfig &b) {
  using ::std::swap;
  swap(a.deBuffId, b.deBuffId);
  swap(a.weight, b.weight);
  swap(a.__isset, b.__isset);
}

DeBuffConfig::DeBuffConfig(const DeBuffConfig& other352) {
  deBuffId = other352.deBuffId;
  weight = other352.weight;
  __isset = other352.__isset;
}
DeBuffConfig& DeBuffConfig::operator=(const DeBuffConfig& other353) {
  deBuffId = other353.deBuffId;
  weight = other353.weight;
  __isset = other353.__isset;
  return *this;
}
void DeBuffConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeBuffConfig(";
  out << "deBuffId=" << to_string(deBuffId);
  out << ", " << "weight=" << to_string(weight);
  out << ")";
}


DeBuffListConfig::~DeBuffListConfig() throw() {
}


void DeBuffListConfig::__set_deBuffConfigId(const int32_t val) {
  this->deBuffConfigId = val;
}

void DeBuffListConfig::__set_deBuffList(const std::vector<DeBuffConfig> & val) {
  this->deBuffList = val;
}

uint32_t DeBuffListConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deBuffConfigId);
          this->__isset.deBuffConfigId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deBuffList.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _etype357;
            xfer += iprot->readListBegin(_etype357, _size354);
            this->deBuffList.resize(_size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              xfer += this->deBuffList[_i358].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.deBuffList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeBuffListConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeBuffListConfig");

  xfer += oprot->writeFieldBegin("deBuffConfigId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->deBuffConfigId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deBuffList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deBuffList.size()));
    std::vector<DeBuffConfig> ::const_iterator _iter359;
    for (_iter359 = this->deBuffList.begin(); _iter359 != this->deBuffList.end(); ++_iter359)
    {
      xfer += (*_iter359).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeBuffListConfig &a, DeBuffListConfig &b) {
  using ::std::swap;
  swap(a.deBuffConfigId, b.deBuffConfigId);
  swap(a.deBuffList, b.deBuffList);
  swap(a.__isset, b.__isset);
}

DeBuffListConfig::DeBuffListConfig(const DeBuffListConfig& other360) {
  deBuffConfigId = other360.deBuffConfigId;
  deBuffList = other360.deBuffList;
  __isset = other360.__isset;
}
DeBuffListConfig& DeBuffListConfig::operator=(const DeBuffListConfig& other361) {
  deBuffConfigId = other361.deBuffConfigId;
  deBuffList = other361.deBuffList;
  __isset = other361.__isset;
  return *this;
}
void DeBuffListConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeBuffListConfig(";
  out << "deBuffConfigId=" << to_string(deBuffConfigId);
  out << ", " << "deBuffList=" << to_string(deBuffList);
  out << ")";
}


DeBuffConfigTable::~DeBuffConfigTable() throw() {
}


void DeBuffConfigTable::__set_deBuffMap(const std::map<int32_t, DeBuffListConfig> & val) {
  this->deBuffMap = val;
}

uint32_t DeBuffConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->deBuffMap.clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _ktype363;
            ::apache::thrift::protocol::TType _vtype364;
            xfer += iprot->readMapBegin(_ktype363, _vtype364, _size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              int32_t _key367;
              xfer += iprot->readI32(_key367);
              DeBuffListConfig& _val368 = this->deBuffMap[_key367];
              xfer += _val368.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.deBuffMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeBuffConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeBuffConfigTable");

  xfer += oprot->writeFieldBegin("deBuffMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->deBuffMap.size()));
    std::map<int32_t, DeBuffListConfig> ::const_iterator _iter369;
    for (_iter369 = this->deBuffMap.begin(); _iter369 != this->deBuffMap.end(); ++_iter369)
    {
      xfer += oprot->writeI32(_iter369->first);
      xfer += _iter369->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeBuffConfigTable &a, DeBuffConfigTable &b) {
  using ::std::swap;
  swap(a.deBuffMap, b.deBuffMap);
  swap(a.__isset, b.__isset);
}

DeBuffConfigTable::DeBuffConfigTable(const DeBuffConfigTable& other370) {
  deBuffMap = other370.deBuffMap;
  __isset = other370.__isset;
}
DeBuffConfigTable& DeBuffConfigTable::operator=(const DeBuffConfigTable& other371) {
  deBuffMap = other371.deBuffMap;
  __isset = other371.__isset;
  return *this;
}
void DeBuffConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeBuffConfigTable(";
  out << "deBuffMap=" << to_string(deBuffMap);
  out << ")";
}


UltLaserConfig::~UltLaserConfig() throw() {
}


void UltLaserConfig::__set_ultId(const int32_t val) {
  this->ultId = val;
}

void UltLaserConfig::__set_heigh(const int32_t val) {
  this->heigh = val;
}

void UltLaserConfig::__set_width(const int32_t val) {
  this->width = val;
}

void UltLaserConfig::__set_harm(const int32_t val) {
  this->harm = val;
}

void UltLaserConfig::__set_cd(const int32_t val) {
  this->cd = val;
}

void UltLaserConfig::__set_minChargeTime(const int32_t val) {
  this->minChargeTime = val;
}

void UltLaserConfig::__set_maxChargeTime(const int32_t val) {
  this->maxChargeTime = val;
}

uint32_t UltLaserConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ultId);
          this->__isset.ultId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->heigh);
          this->__isset.heigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->harm);
          this->__isset.harm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cd);
          this->__isset.cd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minChargeTime);
          this->__isset.minChargeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxChargeTime);
          this->__isset.maxChargeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UltLaserConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UltLaserConfig");

  xfer += oprot->writeFieldBegin("ultId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->ultId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("heigh", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->heigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("harm", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->harm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cd", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->cd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minChargeTime", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->minChargeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxChargeTime", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->maxChargeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UltLaserConfig &a, UltLaserConfig &b) {
  using ::std::swap;
  swap(a.ultId, b.ultId);
  swap(a.heigh, b.heigh);
  swap(a.width, b.width);
  swap(a.harm, b.harm);
  swap(a.cd, b.cd);
  swap(a.minChargeTime, b.minChargeTime);
  swap(a.maxChargeTime, b.maxChargeTime);
  swap(a.__isset, b.__isset);
}

UltLaserConfig::UltLaserConfig(const UltLaserConfig& other372) {
  ultId = other372.ultId;
  heigh = other372.heigh;
  width = other372.width;
  harm = other372.harm;
  cd = other372.cd;
  minChargeTime = other372.minChargeTime;
  maxChargeTime = other372.maxChargeTime;
  __isset = other372.__isset;
}
UltLaserConfig& UltLaserConfig::operator=(const UltLaserConfig& other373) {
  ultId = other373.ultId;
  heigh = other373.heigh;
  width = other373.width;
  harm = other373.harm;
  cd = other373.cd;
  minChargeTime = other373.minChargeTime;
  maxChargeTime = other373.maxChargeTime;
  __isset = other373.__isset;
  return *this;
}
void UltLaserConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UltLaserConfig(";
  out << "ultId=" << to_string(ultId);
  out << ", " << "heigh=" << to_string(heigh);
  out << ", " << "width=" << to_string(width);
  out << ", " << "harm=" << to_string(harm);
  out << ", " << "cd=" << to_string(cd);
  out << ", " << "minChargeTime=" << to_string(minChargeTime);
  out << ", " << "maxChargeTime=" << to_string(maxChargeTime);
  out << ")";
}


UltPelletConfig::~UltPelletConfig() throw() {
}


void UltPelletConfig::__set_id(const int32_t val) {
  this->id = val;
}

void UltPelletConfig::__set_ultId(const int32_t val) {
  this->ultId = val;
}

void UltPelletConfig::__set_harm(const int32_t val) {
  this->harm = val;
}

void UltPelletConfig::__set_autoHarm(const int32_t val) {
  this->autoHarm = val;
}

void UltPelletConfig::__set_autoHarmRadius(const int32_t val) {
  this->autoHarmRadius = val;
}

void UltPelletConfig::__set_expRadius(const int32_t val) {
  this->expRadius = val;
}

void UltPelletConfig::__set_expLightRadius(const int32_t val) {
  this->expLightRadius = val;
}

void UltPelletConfig::__set_expLightTime(const int32_t val) {
  this->expLightTime = val;
}

void UltPelletConfig::__set_speed(const int32_t val) {
  this->speed = val;
}

void UltPelletConfig::__set_expCountDown(const int32_t val) {
  this->expCountDown = val;
}

void UltPelletConfig::__set_shootCount(const int32_t val) {
  this->shootCount = val;
}

void UltPelletConfig::__set_cd(const int32_t val) {
  this->cd = val;
}

void UltPelletConfig::__set_minChargeTime(const int32_t val) {
  this->minChargeTime = val;
}

void UltPelletConfig::__set_maxChargeTime(const int32_t val) {
  this->maxChargeTime = val;
}

uint32_t UltPelletConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ultId);
          this->__isset.ultId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->harm);
          this->__isset.harm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->autoHarm);
          this->__isset.autoHarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->autoHarmRadius);
          this->__isset.autoHarmRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expRadius);
          this->__isset.expRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expLightRadius);
          this->__isset.expLightRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expLightTime);
          this->__isset.expLightTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->speed);
          this->__isset.speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expCountDown);
          this->__isset.expCountDown = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shootCount);
          this->__isset.shootCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cd);
          this->__isset.cd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minChargeTime);
          this->__isset.minChargeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 140:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxChargeTime);
          this->__isset.maxChargeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UltPelletConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UltPelletConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ultId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->ultId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("harm", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->harm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("autoHarm", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->autoHarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("autoHarmRadius", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->autoHarmRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expRadius", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->expRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expLightRadius", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->expLightRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expLightTime", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->expLightTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speed", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expCountDown", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->expCountDown);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shootCount", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->shootCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cd", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->cd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minChargeTime", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32(this->minChargeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxChargeTime", ::apache::thrift::protocol::T_I32, 140);
  xfer += oprot->writeI32(this->maxChargeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UltPelletConfig &a, UltPelletConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.ultId, b.ultId);
  swap(a.harm, b.harm);
  swap(a.autoHarm, b.autoHarm);
  swap(a.autoHarmRadius, b.autoHarmRadius);
  swap(a.expRadius, b.expRadius);
  swap(a.expLightRadius, b.expLightRadius);
  swap(a.expLightTime, b.expLightTime);
  swap(a.speed, b.speed);
  swap(a.expCountDown, b.expCountDown);
  swap(a.shootCount, b.shootCount);
  swap(a.cd, b.cd);
  swap(a.minChargeTime, b.minChargeTime);
  swap(a.maxChargeTime, b.maxChargeTime);
  swap(a.__isset, b.__isset);
}

UltPelletConfig::UltPelletConfig(const UltPelletConfig& other374) {
  id = other374.id;
  ultId = other374.ultId;
  harm = other374.harm;
  autoHarm = other374.autoHarm;
  autoHarmRadius = other374.autoHarmRadius;
  expRadius = other374.expRadius;
  expLightRadius = other374.expLightRadius;
  expLightTime = other374.expLightTime;
  speed = other374.speed;
  expCountDown = other374.expCountDown;
  shootCount = other374.shootCount;
  cd = other374.cd;
  minChargeTime = other374.minChargeTime;
  maxChargeTime = other374.maxChargeTime;
  __isset = other374.__isset;
}
UltPelletConfig& UltPelletConfig::operator=(const UltPelletConfig& other375) {
  id = other375.id;
  ultId = other375.ultId;
  harm = other375.harm;
  autoHarm = other375.autoHarm;
  autoHarmRadius = other375.autoHarmRadius;
  expRadius = other375.expRadius;
  expLightRadius = other375.expLightRadius;
  expLightTime = other375.expLightTime;
  speed = other375.speed;
  expCountDown = other375.expCountDown;
  shootCount = other375.shootCount;
  cd = other375.cd;
  minChargeTime = other375.minChargeTime;
  maxChargeTime = other375.maxChargeTime;
  __isset = other375.__isset;
  return *this;
}
void UltPelletConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UltPelletConfig(";
  out << "id=" << to_string(id);
  out << ", " << "ultId=" << to_string(ultId);
  out << ", " << "harm=" << to_string(harm);
  out << ", " << "autoHarm=" << to_string(autoHarm);
  out << ", " << "autoHarmRadius=" << to_string(autoHarmRadius);
  out << ", " << "expRadius=" << to_string(expRadius);
  out << ", " << "expLightRadius=" << to_string(expLightRadius);
  out << ", " << "expLightTime=" << to_string(expLightTime);
  out << ", " << "speed=" << to_string(speed);
  out << ", " << "expCountDown=" << to_string(expCountDown);
  out << ", " << "shootCount=" << to_string(shootCount);
  out << ", " << "cd=" << to_string(cd);
  out << ", " << "minChargeTime=" << to_string(minChargeTime);
  out << ", " << "maxChargeTime=" << to_string(maxChargeTime);
  out << ")";
}


UltTraceConfig::~UltTraceConfig() throw() {
}


void UltTraceConfig::__set_ultId(const int32_t val) {
  this->ultId = val;
}

void UltTraceConfig::__set_hp(const int32_t val) {
  this->hp = val;
}

void UltTraceConfig::__set_harm(const int32_t val) {
  this->harm = val;
}

void UltTraceConfig::__set_speed(const int32_t val) {
  this->speed = val;
}

void UltTraceConfig::__set_angularSpeed(const int32_t val) {
  this->angularSpeed = val;
}

void UltTraceConfig::__set_bulletInteractive(const bool val) {
  this->bulletInteractive = val;
}

void UltTraceConfig::__set_obstacleInteractive(const bool val) {
  this->obstacleInteractive = val;
}

void UltTraceConfig::__set_lightRadius(const int32_t val) {
  this->lightRadius = val;
}

void UltTraceConfig::__set_expRadius(const int32_t val) {
  this->expRadius = val;
}

void UltTraceConfig::__set_expLightRadius(const int32_t val) {
  this->expLightRadius = val;
}

void UltTraceConfig::__set_expLightTime(const int32_t val) {
  this->expLightTime = val;
}

void UltTraceConfig::__set_cd(const int32_t val) {
  this->cd = val;
}

void UltTraceConfig::__set_minChargeTime(const int32_t val) {
  this->minChargeTime = val;
}

void UltTraceConfig::__set_maxChargeTime(const int32_t val) {
  this->maxChargeTime = val;
}

uint32_t UltTraceConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ultId);
          this->__isset.ultId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hp);
          this->__isset.hp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->harm);
          this->__isset.harm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->speed);
          this->__isset.speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->angularSpeed);
          this->__isset.angularSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bulletInteractive);
          this->__isset.bulletInteractive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->obstacleInteractive);
          this->__isset.obstacleInteractive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lightRadius);
          this->__isset.lightRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expRadius);
          this->__isset.expRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expLightRadius);
          this->__isset.expLightRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expLightTime);
          this->__isset.expLightTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cd);
          this->__isset.cd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minChargeTime);
          this->__isset.minChargeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 140:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxChargeTime);
          this->__isset.maxChargeTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UltTraceConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UltTraceConfig");

  xfer += oprot->writeFieldBegin("ultId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->ultId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hp", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->hp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("harm", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->harm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speed", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angularSpeed", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->angularSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulletInteractive", ::apache::thrift::protocol::T_BOOL, 60);
  xfer += oprot->writeBool(this->bulletInteractive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("obstacleInteractive", ::apache::thrift::protocol::T_BOOL, 70);
  xfer += oprot->writeBool(this->obstacleInteractive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lightRadius", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->lightRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expRadius", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->expRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expLightRadius", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->expLightRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expLightTime", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->expLightTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cd", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->cd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minChargeTime", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32(this->minChargeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxChargeTime", ::apache::thrift::protocol::T_I32, 140);
  xfer += oprot->writeI32(this->maxChargeTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UltTraceConfig &a, UltTraceConfig &b) {
  using ::std::swap;
  swap(a.ultId, b.ultId);
  swap(a.hp, b.hp);
  swap(a.harm, b.harm);
  swap(a.speed, b.speed);
  swap(a.angularSpeed, b.angularSpeed);
  swap(a.bulletInteractive, b.bulletInteractive);
  swap(a.obstacleInteractive, b.obstacleInteractive);
  swap(a.lightRadius, b.lightRadius);
  swap(a.expRadius, b.expRadius);
  swap(a.expLightRadius, b.expLightRadius);
  swap(a.expLightTime, b.expLightTime);
  swap(a.cd, b.cd);
  swap(a.minChargeTime, b.minChargeTime);
  swap(a.maxChargeTime, b.maxChargeTime);
  swap(a.__isset, b.__isset);
}

UltTraceConfig::UltTraceConfig(const UltTraceConfig& other376) {
  ultId = other376.ultId;
  hp = other376.hp;
  harm = other376.harm;
  speed = other376.speed;
  angularSpeed = other376.angularSpeed;
  bulletInteractive = other376.bulletInteractive;
  obstacleInteractive = other376.obstacleInteractive;
  lightRadius = other376.lightRadius;
  expRadius = other376.expRadius;
  expLightRadius = other376.expLightRadius;
  expLightTime = other376.expLightTime;
  cd = other376.cd;
  minChargeTime = other376.minChargeTime;
  maxChargeTime = other376.maxChargeTime;
  __isset = other376.__isset;
}
UltTraceConfig& UltTraceConfig::operator=(const UltTraceConfig& other377) {
  ultId = other377.ultId;
  hp = other377.hp;
  harm = other377.harm;
  speed = other377.speed;
  angularSpeed = other377.angularSpeed;
  bulletInteractive = other377.bulletInteractive;
  obstacleInteractive = other377.obstacleInteractive;
  lightRadius = other377.lightRadius;
  expRadius = other377.expRadius;
  expLightRadius = other377.expLightRadius;
  expLightTime = other377.expLightTime;
  cd = other377.cd;
  minChargeTime = other377.minChargeTime;
  maxChargeTime = other377.maxChargeTime;
  __isset = other377.__isset;
  return *this;
}
void UltTraceConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UltTraceConfig(";
  out << "ultId=" << to_string(ultId);
  out << ", " << "hp=" << to_string(hp);
  out << ", " << "harm=" << to_string(harm);
  out << ", " << "speed=" << to_string(speed);
  out << ", " << "angularSpeed=" << to_string(angularSpeed);
  out << ", " << "bulletInteractive=" << to_string(bulletInteractive);
  out << ", " << "obstacleInteractive=" << to_string(obstacleInteractive);
  out << ", " << "lightRadius=" << to_string(lightRadius);
  out << ", " << "expRadius=" << to_string(expRadius);
  out << ", " << "expLightRadius=" << to_string(expLightRadius);
  out << ", " << "expLightTime=" << to_string(expLightTime);
  out << ", " << "cd=" << to_string(cd);
  out << ", " << "minChargeTime=" << to_string(minChargeTime);
  out << ", " << "maxChargeTime=" << to_string(maxChargeTime);
  out << ")";
}


UltSkillConfigTable::~UltSkillConfigTable() throw() {
}


void UltSkillConfigTable::__set_ultLaser(const UltLaserConfig& val) {
  this->ultLaser = val;
}

void UltSkillConfigTable::__set_ultPellet(const std::map<int32_t, UltPelletConfig> & val) {
  this->ultPellet = val;
}

void UltSkillConfigTable::__set_ultTrace(const UltTraceConfig& val) {
  this->ultTrace = val;
}

uint32_t UltSkillConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ultLaser.read(iprot);
          this->__isset.ultLaser = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ultPellet.clear();
            uint32_t _size378;
            ::apache::thrift::protocol::TType _ktype379;
            ::apache::thrift::protocol::TType _vtype380;
            xfer += iprot->readMapBegin(_ktype379, _vtype380, _size378);
            uint32_t _i382;
            for (_i382 = 0; _i382 < _size378; ++_i382)
            {
              int32_t _key383;
              xfer += iprot->readI32(_key383);
              UltPelletConfig& _val384 = this->ultPellet[_key383];
              xfer += _val384.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ultPellet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ultTrace.read(iprot);
          this->__isset.ultTrace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UltSkillConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UltSkillConfigTable");

  xfer += oprot->writeFieldBegin("ultLaser", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->ultLaser.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ultPellet", ::apache::thrift::protocol::T_MAP, 20);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ultPellet.size()));
    std::map<int32_t, UltPelletConfig> ::const_iterator _iter385;
    for (_iter385 = this->ultPellet.begin(); _iter385 != this->ultPellet.end(); ++_iter385)
    {
      xfer += oprot->writeI32(_iter385->first);
      xfer += _iter385->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ultTrace", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->ultTrace.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UltSkillConfigTable &a, UltSkillConfigTable &b) {
  using ::std::swap;
  swap(a.ultLaser, b.ultLaser);
  swap(a.ultPellet, b.ultPellet);
  swap(a.ultTrace, b.ultTrace);
  swap(a.__isset, b.__isset);
}

UltSkillConfigTable::UltSkillConfigTable(const UltSkillConfigTable& other386) {
  ultLaser = other386.ultLaser;
  ultPellet = other386.ultPellet;
  ultTrace = other386.ultTrace;
  __isset = other386.__isset;
}
UltSkillConfigTable& UltSkillConfigTable::operator=(const UltSkillConfigTable& other387) {
  ultLaser = other387.ultLaser;
  ultPellet = other387.ultPellet;
  ultTrace = other387.ultTrace;
  __isset = other387.__isset;
  return *this;
}
void UltSkillConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UltSkillConfigTable(";
  out << "ultLaser=" << to_string(ultLaser);
  out << ", " << "ultPellet=" << to_string(ultPellet);
  out << ", " << "ultTrace=" << to_string(ultTrace);
  out << ")";
}

} // namespace
