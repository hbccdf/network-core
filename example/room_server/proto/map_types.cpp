/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "map_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kRandomTypeValues[] = {
  RandomType::Random,
  RandomType::Fixed
};
const char* _kRandomTypeNames[] = {
  "Random",
  "Fixed"
};
const std::map<int, const char*> _RandomType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kRandomTypeValues, _kRandomTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


BoxCollider::~BoxCollider() throw() {
}


void BoxCollider::__set_center(const  ::TVector3& val) {
  this->center = val;
}

void BoxCollider::__set_size(const  ::TVector3& val) {
  this->size = val;
}

uint32_t BoxCollider::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->center.read(iprot);
          this->__isset.center = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->size.read(iprot);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BoxCollider::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BoxCollider");

  xfer += oprot->writeFieldBegin("center", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->center.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->size.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BoxCollider &a, BoxCollider &b) {
  using ::std::swap;
  swap(a.center, b.center);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

BoxCollider::BoxCollider(const BoxCollider& other0) {
  center = other0.center;
  size = other0.size;
  __isset = other0.__isset;
}
BoxCollider& BoxCollider::operator=(const BoxCollider& other1) {
  center = other1.center;
  size = other1.size;
  __isset = other1.__isset;
  return *this;
}
void BoxCollider::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BoxCollider(";
  out << "center=" << to_string(center);
  out << ", " << "size=" << to_string(size);
  out << ")";
}


ObstacleData::~ObstacleData() throw() {
}


void ObstacleData::__set_id(const int32_t val) {
  this->id = val;
}

void ObstacleData::__set_pos(const  ::TVector3& val) {
  this->pos = val;
}

void ObstacleData::__set_rot(const  ::TRotation& val) {
  this->rot = val;
}

void ObstacleData::__set_collider(const BoxCollider& val) {
  this->collider = val;
}

uint32_t ObstacleData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rot.read(iprot);
          this->__isset.rot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->collider.read(iprot);
          this->__isset.collider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ObstacleData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ObstacleData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rot", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->rot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("collider", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->collider.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ObstacleData &a, ObstacleData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.pos, b.pos);
  swap(a.rot, b.rot);
  swap(a.collider, b.collider);
  swap(a.__isset, b.__isset);
}

ObstacleData::ObstacleData(const ObstacleData& other2) {
  id = other2.id;
  pos = other2.pos;
  rot = other2.rot;
  collider = other2.collider;
  __isset = other2.__isset;
}
ObstacleData& ObstacleData::operator=(const ObstacleData& other3) {
  id = other3.id;
  pos = other3.pos;
  rot = other3.rot;
  collider = other3.collider;
  __isset = other3.__isset;
  return *this;
}
void ObstacleData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ObstacleData(";
  out << "id=" << to_string(id);
  out << ", " << "pos=" << to_string(pos);
  out << ", " << "rot=" << to_string(rot);
  out << ", " << "collider=" << to_string(collider);
  out << ")";
}


PlayerStartData::~PlayerStartData() throw() {
}


void PlayerStartData::__set_id(const int32_t val) {
  this->id = val;
}

void PlayerStartData::__set_pos(const  ::TVector3& val) {
  this->pos = val;
}

void PlayerStartData::__set_fectionType(const int32_t val) {
  this->fectionType = val;
}

uint32_t PlayerStartData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fectionType);
          this->__isset.fectionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerStartData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlayerStartData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fectionType", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->fectionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerStartData &a, PlayerStartData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.pos, b.pos);
  swap(a.fectionType, b.fectionType);
  swap(a.__isset, b.__isset);
}

PlayerStartData::PlayerStartData(const PlayerStartData& other4) {
  id = other4.id;
  pos = other4.pos;
  fectionType = other4.fectionType;
  __isset = other4.__isset;
}
PlayerStartData& PlayerStartData::operator=(const PlayerStartData& other5) {
  id = other5.id;
  pos = other5.pos;
  fectionType = other5.fectionType;
  __isset = other5.__isset;
  return *this;
}
void PlayerStartData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlayerStartData(";
  out << "id=" << to_string(id);
  out << ", " << "pos=" << to_string(pos);
  out << ", " << "fectionType=" << to_string(fectionType);
  out << ")";
}


ArenaMonsterData::~ArenaMonsterData() throw() {
}


void ArenaMonsterData::__set_id(const int32_t val) {
  this->id = val;
}

void ArenaMonsterData::__set_factionId(const int32_t val) {
  this->factionId = val;
}

void ArenaMonsterData::__set_monsterType(const  ::MonsterType::type val) {
  this->monsterType = val;
}

void ArenaMonsterData::__set_pos(const  ::TVector3& val) {
  this->pos = val;
}

void ArenaMonsterData::__set_size(const  ::TVector3& val) {
  this->size = val;
}

void ArenaMonsterData::__set_offset(const  ::TVector3& val) {
  this->offset = val;
}

uint32_t ArenaMonsterData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->factionId);
          this->__isset.factionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->monsterType = ( ::MonsterType::type)ecast6;
          this->__isset.monsterType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->size.read(iprot);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->offset.read(iprot);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ArenaMonsterData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ArenaMonsterData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("factionId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->factionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("monsterType", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32((int32_t)this->monsterType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_STRUCT, 50);
  xfer += this->size.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_STRUCT, 60);
  xfer += this->offset.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ArenaMonsterData &a, ArenaMonsterData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.factionId, b.factionId);
  swap(a.monsterType, b.monsterType);
  swap(a.pos, b.pos);
  swap(a.size, b.size);
  swap(a.offset, b.offset);
  swap(a.__isset, b.__isset);
}

ArenaMonsterData::ArenaMonsterData(const ArenaMonsterData& other7) {
  id = other7.id;
  factionId = other7.factionId;
  monsterType = other7.monsterType;
  pos = other7.pos;
  size = other7.size;
  offset = other7.offset;
  __isset = other7.__isset;
}
ArenaMonsterData& ArenaMonsterData::operator=(const ArenaMonsterData& other8) {
  id = other8.id;
  factionId = other8.factionId;
  monsterType = other8.monsterType;
  pos = other8.pos;
  size = other8.size;
  offset = other8.offset;
  __isset = other8.__isset;
  return *this;
}
void ArenaMonsterData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ArenaMonsterData(";
  out << "id=" << to_string(id);
  out << ", " << "factionId=" << to_string(factionId);
  out << ", " << "monsterType=" << to_string(monsterType);
  out << ", " << "pos=" << to_string(pos);
  out << ", " << "size=" << to_string(size);
  out << ", " << "offset=" << to_string(offset);
  out << ")";
}


ItemGeneratorData::~ItemGeneratorData() throw() {
}


void ItemGeneratorData::__set_id(const int32_t val) {
  this->id = val;
}

void ItemGeneratorData::__set_dropListId(const int32_t val) {
  this->dropListId = val;
}

void ItemGeneratorData::__set_beginDelayTime(const int32_t val) {
  this->beginDelayTime = val;
}

void ItemGeneratorData::__set_tickTime(const int32_t val) {
  this->tickTime = val;
}

void ItemGeneratorData::__set_count(const int32_t val) {
  this->count = val;
}

void ItemGeneratorData::__set_posList(const std::vector< ::TVector3> & val) {
  this->posList = val;
}

uint32_t ItemGeneratorData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dropListId);
          this->__isset.dropListId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->beginDelayTime);
          this->__isset.beginDelayTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tickTime);
          this->__isset.tickTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->posList.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->posList.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += this->posList[_i13].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.posList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemGeneratorData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemGeneratorData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropListId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->dropListId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("beginDelayTime", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->beginDelayTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tickTime", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->tickTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("posList", ::apache::thrift::protocol::T_LIST, 60);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->posList.size()));
    std::vector< ::TVector3> ::const_iterator _iter14;
    for (_iter14 = this->posList.begin(); _iter14 != this->posList.end(); ++_iter14)
    {
      xfer += (*_iter14).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemGeneratorData &a, ItemGeneratorData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.dropListId, b.dropListId);
  swap(a.beginDelayTime, b.beginDelayTime);
  swap(a.tickTime, b.tickTime);
  swap(a.count, b.count);
  swap(a.posList, b.posList);
  swap(a.__isset, b.__isset);
}

ItemGeneratorData::ItemGeneratorData(const ItemGeneratorData& other15) {
  id = other15.id;
  dropListId = other15.dropListId;
  beginDelayTime = other15.beginDelayTime;
  tickTime = other15.tickTime;
  count = other15.count;
  posList = other15.posList;
  __isset = other15.__isset;
}
ItemGeneratorData& ItemGeneratorData::operator=(const ItemGeneratorData& other16) {
  id = other16.id;
  dropListId = other16.dropListId;
  beginDelayTime = other16.beginDelayTime;
  tickTime = other16.tickTime;
  count = other16.count;
  posList = other16.posList;
  __isset = other16.__isset;
  return *this;
}
void ItemGeneratorData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemGeneratorData(";
  out << "id=" << to_string(id);
  out << ", " << "dropListId=" << to_string(dropListId);
  out << ", " << "beginDelayTime=" << to_string(beginDelayTime);
  out << ", " << "tickTime=" << to_string(tickTime);
  out << ", " << "count=" << to_string(count);
  out << ", " << "posList=" << to_string(posList);
  out << ")";
}


BaseCenterData::~BaseCenterData() throw() {
}


void BaseCenterData::__set_id(const int32_t val) {
  this->id = val;
}

void BaseCenterData::__set_pos(const  ::TVector3& val) {
  this->pos = val;
}

void BaseCenterData::__set_rot(const  ::TRotation& val) {
  this->rot = val;
}

void BaseCenterData::__set_collider(const BoxCollider& val) {
  this->collider = val;
}

void BaseCenterData::__set_fectionType(const int32_t val) {
  this->fectionType = val;
}

uint32_t BaseCenterData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rot.read(iprot);
          this->__isset.rot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->collider.read(iprot);
          this->__isset.collider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fectionType);
          this->__isset.fectionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BaseCenterData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BaseCenterData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rot", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->rot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("collider", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->collider.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fectionType", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->fectionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaseCenterData &a, BaseCenterData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.pos, b.pos);
  swap(a.rot, b.rot);
  swap(a.collider, b.collider);
  swap(a.fectionType, b.fectionType);
  swap(a.__isset, b.__isset);
}

BaseCenterData::BaseCenterData(const BaseCenterData& other17) {
  id = other17.id;
  pos = other17.pos;
  rot = other17.rot;
  collider = other17.collider;
  fectionType = other17.fectionType;
  __isset = other17.__isset;
}
BaseCenterData& BaseCenterData::operator=(const BaseCenterData& other18) {
  id = other18.id;
  pos = other18.pos;
  rot = other18.rot;
  collider = other18.collider;
  fectionType = other18.fectionType;
  __isset = other18.__isset;
  return *this;
}
void BaseCenterData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BaseCenterData(";
  out << "id=" << to_string(id);
  out << ", " << "pos=" << to_string(pos);
  out << ", " << "rot=" << to_string(rot);
  out << ", " << "collider=" << to_string(collider);
  out << ", " << "fectionType=" << to_string(fectionType);
  out << ")";
}


CreateInMap::~CreateInMap() throw() {
}


void CreateInMap::__set_id(const int32_t val) {
  this->id = val;
}

void CreateInMap::__set_objType(const  ::ObjType::type val) {
  this->objType = val;
}

void CreateInMap::__set_randomType(const RandomType::type val) {
  this->randomType = val;
}

void CreateInMap::__set_pos(const  ::TVector3& val) {
  this->pos = val;
}

void CreateInMap::__set_rot(const  ::TRotation& val) {
  this->rot = val;
}

void CreateInMap::__set_collider(const BoxCollider& val) {
  this->collider = val;
}

void CreateInMap::__set_factionType(const  ::FactionType::type val) {
  this->factionType = val;
}

void CreateInMap::__set_dropListId(const int32_t val) {
  this->dropListId = val;
}

void CreateInMap::__set_beginDelayTime(const int32_t val) {
  this->beginDelayTime = val;
}

void CreateInMap::__set_tickTime(const int32_t val) {
  this->tickTime = val;
}

void CreateInMap::__set_count(const int32_t val) {
  this->count = val;
}

void CreateInMap::__set_refreshCountOnce(const int32_t val) {
  this->refreshCountOnce = val;
}

void CreateInMap::__set_posList(const std::vector< ::TVector3> & val) {
  this->posList = val;
}

void CreateInMap::__set_monsterType(const  ::MonsterType::type val) {
  this->monsterType = val;
}

void CreateInMap::__set_magicType(const  ::MagicType::type val) {
  this->magicType = val;
}

uint32_t CreateInMap::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->objType = ( ::ObjType::type)ecast19;
          this->__isset.objType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->randomType = (RandomType::type)ecast20;
          this->__isset.randomType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rot.read(iprot);
          this->__isset.rot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->collider.read(iprot);
          this->__isset.collider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->factionType = ( ::FactionType::type)ecast21;
          this->__isset.factionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dropListId);
          this->__isset.dropListId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->beginDelayTime);
          this->__isset.beginDelayTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tickTime);
          this->__isset.tickTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 111:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->refreshCountOnce);
          this->__isset.refreshCountOnce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->posList.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->posList.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->posList[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.posList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast27;
          xfer += iprot->readI32(ecast27);
          this->monsterType = ( ::MonsterType::type)ecast27;
          this->__isset.monsterType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 140:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast28;
          xfer += iprot->readI32(ecast28);
          this->magicType = ( ::MagicType::type)ecast28;
          this->__isset.magicType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateInMap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateInMap");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objType", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32((int32_t)this->objType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("randomType", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32((int32_t)this->randomType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rot", ::apache::thrift::protocol::T_STRUCT, 50);
  xfer += this->rot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("collider", ::apache::thrift::protocol::T_STRUCT, 60);
  xfer += this->collider.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("factionType", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32((int32_t)this->factionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dropListId", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->dropListId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("beginDelayTime", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->beginDelayTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tickTime", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->tickTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("refreshCountOnce", ::apache::thrift::protocol::T_I32, 111);
  xfer += oprot->writeI32(this->refreshCountOnce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("posList", ::apache::thrift::protocol::T_LIST, 120);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->posList.size()));
    std::vector< ::TVector3> ::const_iterator _iter29;
    for (_iter29 = this->posList.begin(); _iter29 != this->posList.end(); ++_iter29)
    {
      xfer += (*_iter29).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("monsterType", ::apache::thrift::protocol::T_I32, 130);
  xfer += oprot->writeI32((int32_t)this->monsterType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("magicType", ::apache::thrift::protocol::T_I32, 140);
  xfer += oprot->writeI32((int32_t)this->magicType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateInMap &a, CreateInMap &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.objType, b.objType);
  swap(a.randomType, b.randomType);
  swap(a.pos, b.pos);
  swap(a.rot, b.rot);
  swap(a.collider, b.collider);
  swap(a.factionType, b.factionType);
  swap(a.dropListId, b.dropListId);
  swap(a.beginDelayTime, b.beginDelayTime);
  swap(a.tickTime, b.tickTime);
  swap(a.count, b.count);
  swap(a.refreshCountOnce, b.refreshCountOnce);
  swap(a.posList, b.posList);
  swap(a.monsterType, b.monsterType);
  swap(a.magicType, b.magicType);
  swap(a.__isset, b.__isset);
}

CreateInMap::CreateInMap(const CreateInMap& other30) {
  id = other30.id;
  objType = other30.objType;
  randomType = other30.randomType;
  pos = other30.pos;
  rot = other30.rot;
  collider = other30.collider;
  factionType = other30.factionType;
  dropListId = other30.dropListId;
  beginDelayTime = other30.beginDelayTime;
  tickTime = other30.tickTime;
  count = other30.count;
  refreshCountOnce = other30.refreshCountOnce;
  posList = other30.posList;
  monsterType = other30.monsterType;
  magicType = other30.magicType;
  __isset = other30.__isset;
}
CreateInMap& CreateInMap::operator=(const CreateInMap& other31) {
  id = other31.id;
  objType = other31.objType;
  randomType = other31.randomType;
  pos = other31.pos;
  rot = other31.rot;
  collider = other31.collider;
  factionType = other31.factionType;
  dropListId = other31.dropListId;
  beginDelayTime = other31.beginDelayTime;
  tickTime = other31.tickTime;
  count = other31.count;
  refreshCountOnce = other31.refreshCountOnce;
  posList = other31.posList;
  monsterType = other31.monsterType;
  magicType = other31.magicType;
  __isset = other31.__isset;
  return *this;
}
void CreateInMap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateInMap(";
  out << "id=" << to_string(id);
  out << ", " << "objType=" << to_string(objType);
  out << ", " << "randomType=" << to_string(randomType);
  out << ", " << "pos=" << to_string(pos);
  out << ", " << "rot=" << to_string(rot);
  out << ", " << "collider=" << to_string(collider);
  out << ", " << "factionType=" << to_string(factionType);
  out << ", " << "dropListId=" << to_string(dropListId);
  out << ", " << "beginDelayTime=" << to_string(beginDelayTime);
  out << ", " << "tickTime=" << to_string(tickTime);
  out << ", " << "count=" << to_string(count);
  out << ", " << "refreshCountOnce=" << to_string(refreshCountOnce);
  out << ", " << "posList=" << to_string(posList);
  out << ", " << "monsterType=" << to_string(monsterType);
  out << ", " << "magicType=" << to_string(magicType);
  out << ")";
}


MapData::~MapData() throw() {
}


void MapData::__set_id(const int32_t val) {
  this->id = val;
}

void MapData::__set_mapName(const std::string& val) {
  this->mapName = val;
}

void MapData::__set_bounds(const  ::Bounds& val) {
  this->bounds = val;
}

void MapData::__set_obstacleList(const std::vector<ObstacleData> & val) {
  this->obstacleList = val;
}

void MapData::__set_playerStartList(const std::vector<PlayerStartData> & val) {
  this->playerStartList = val;
}

void MapData::__set_baseCenterList(const std::vector<BaseCenterData> & val) {
  this->baseCenterList = val;
}

void MapData::__set_monsterList(const std::vector<ArenaMonsterData> & val) {
  this->monsterList = val;
}

void MapData::__set_itemGeneratorList(const std::vector<ItemGeneratorData> & val) {
  this->itemGeneratorList = val;
}

void MapData::__set_modelSize(const std::map<int32_t,  ::TVector3> & val) {
  this->modelSize = val;
}

void MapData::__set_createInMap(const std::vector<CreateInMap> & val) {
  this->createInMap = val;
}

void MapData::__set_firstRefreshTime(const int32_t val) {
  this->firstRefreshTime = val;
}

uint32_t MapData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mapName);
          this->__isset.mapName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bounds.read(iprot);
          this->__isset.bounds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->obstacleList.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->obstacleList.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->obstacleList[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.obstacleList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->playerStartList.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->playerStartList.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->playerStartList[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.playerStartList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->baseCenterList.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->baseCenterList.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->baseCenterList[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.baseCenterList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->monsterList.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->monsterList.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->monsterList[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.monsterList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->itemGeneratorList.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->itemGeneratorList.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->itemGeneratorList[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.itemGeneratorList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->modelSize.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _ktype58;
            ::apache::thrift::protocol::TType _vtype59;
            xfer += iprot->readMapBegin(_ktype58, _vtype59, _size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              int32_t _key62;
              xfer += iprot->readI32(_key62);
               ::TVector3& _val63 = this->modelSize[_key62];
              xfer += _val63.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.modelSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->createInMap.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->createInMap.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += this->createInMap[_i68].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.createInMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->firstRefreshTime);
          this->__isset.firstRefreshTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapName", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->mapName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bounds", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->bounds.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("obstacleList", ::apache::thrift::protocol::T_LIST, 40);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->obstacleList.size()));
    std::vector<ObstacleData> ::const_iterator _iter69;
    for (_iter69 = this->obstacleList.begin(); _iter69 != this->obstacleList.end(); ++_iter69)
    {
      xfer += (*_iter69).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerStartList", ::apache::thrift::protocol::T_LIST, 50);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->playerStartList.size()));
    std::vector<PlayerStartData> ::const_iterator _iter70;
    for (_iter70 = this->playerStartList.begin(); _iter70 != this->playerStartList.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baseCenterList", ::apache::thrift::protocol::T_LIST, 60);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->baseCenterList.size()));
    std::vector<BaseCenterData> ::const_iterator _iter71;
    for (_iter71 = this->baseCenterList.begin(); _iter71 != this->baseCenterList.end(); ++_iter71)
    {
      xfer += (*_iter71).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("monsterList", ::apache::thrift::protocol::T_LIST, 70);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->monsterList.size()));
    std::vector<ArenaMonsterData> ::const_iterator _iter72;
    for (_iter72 = this->monsterList.begin(); _iter72 != this->monsterList.end(); ++_iter72)
    {
      xfer += (*_iter72).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemGeneratorList", ::apache::thrift::protocol::T_LIST, 80);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->itemGeneratorList.size()));
    std::vector<ItemGeneratorData> ::const_iterator _iter73;
    for (_iter73 = this->itemGeneratorList.begin(); _iter73 != this->itemGeneratorList.end(); ++_iter73)
    {
      xfer += (*_iter73).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modelSize", ::apache::thrift::protocol::T_MAP, 90);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->modelSize.size()));
    std::map<int32_t,  ::TVector3> ::const_iterator _iter74;
    for (_iter74 = this->modelSize.begin(); _iter74 != this->modelSize.end(); ++_iter74)
    {
      xfer += oprot->writeI32(_iter74->first);
      xfer += _iter74->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createInMap", ::apache::thrift::protocol::T_LIST, 100);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->createInMap.size()));
    std::vector<CreateInMap> ::const_iterator _iter75;
    for (_iter75 = this->createInMap.begin(); _iter75 != this->createInMap.end(); ++_iter75)
    {
      xfer += (*_iter75).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstRefreshTime", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->firstRefreshTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapData &a, MapData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.mapName, b.mapName);
  swap(a.bounds, b.bounds);
  swap(a.obstacleList, b.obstacleList);
  swap(a.playerStartList, b.playerStartList);
  swap(a.baseCenterList, b.baseCenterList);
  swap(a.monsterList, b.monsterList);
  swap(a.itemGeneratorList, b.itemGeneratorList);
  swap(a.modelSize, b.modelSize);
  swap(a.createInMap, b.createInMap);
  swap(a.firstRefreshTime, b.firstRefreshTime);
  swap(a.__isset, b.__isset);
}

MapData::MapData(const MapData& other76) {
  id = other76.id;
  mapName = other76.mapName;
  bounds = other76.bounds;
  obstacleList = other76.obstacleList;
  playerStartList = other76.playerStartList;
  baseCenterList = other76.baseCenterList;
  monsterList = other76.monsterList;
  itemGeneratorList = other76.itemGeneratorList;
  modelSize = other76.modelSize;
  createInMap = other76.createInMap;
  firstRefreshTime = other76.firstRefreshTime;
  __isset = other76.__isset;
}
MapData& MapData::operator=(const MapData& other77) {
  id = other77.id;
  mapName = other77.mapName;
  bounds = other77.bounds;
  obstacleList = other77.obstacleList;
  playerStartList = other77.playerStartList;
  baseCenterList = other77.baseCenterList;
  monsterList = other77.monsterList;
  itemGeneratorList = other77.itemGeneratorList;
  modelSize = other77.modelSize;
  createInMap = other77.createInMap;
  firstRefreshTime = other77.firstRefreshTime;
  __isset = other77.__isset;
  return *this;
}
void MapData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapData(";
  out << "id=" << to_string(id);
  out << ", " << "mapName=" << to_string(mapName);
  out << ", " << "bounds=" << to_string(bounds);
  out << ", " << "obstacleList=" << to_string(obstacleList);
  out << ", " << "playerStartList=" << to_string(playerStartList);
  out << ", " << "baseCenterList=" << to_string(baseCenterList);
  out << ", " << "monsterList=" << to_string(monsterList);
  out << ", " << "itemGeneratorList=" << to_string(itemGeneratorList);
  out << ", " << "modelSize=" << to_string(modelSize);
  out << ", " << "createInMap=" << to_string(createInMap);
  out << ", " << "firstRefreshTime=" << to_string(firstRefreshTime);
  out << ")";
}


MapDataConfigTable::~MapDataConfigTable() throw() {
}


void MapDataConfigTable::__set_mapList(const std::vector<MapData> & val) {
  this->mapList = val;
}

uint32_t MapDataConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mapList.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->mapList.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->mapList[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mapList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapDataConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapDataConfigTable");

  xfer += oprot->writeFieldBegin("mapList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mapList.size()));
    std::vector<MapData> ::const_iterator _iter83;
    for (_iter83 = this->mapList.begin(); _iter83 != this->mapList.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapDataConfigTable &a, MapDataConfigTable &b) {
  using ::std::swap;
  swap(a.mapList, b.mapList);
  swap(a.__isset, b.__isset);
}

MapDataConfigTable::MapDataConfigTable(const MapDataConfigTable& other84) {
  mapList = other84.mapList;
  __isset = other84.__isset;
}
MapDataConfigTable& MapDataConfigTable::operator=(const MapDataConfigTable& other85) {
  mapList = other85.mapList;
  __isset = other85.__isset;
  return *this;
}
void MapDataConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapDataConfigTable(";
  out << "mapList=" << to_string(mapList);
  out << ")";
}


