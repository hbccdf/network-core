/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "struct_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kBattlePatternValues[] = {
  BattlePattern::None,
  BattlePattern::Moba,
  BattlePattern::ThreeParty,
  BattlePattern::Royale
};
const char* _kBattlePatternNames[] = {
  "None",
  "Moba",
  "ThreeParty",
  "Royale"
};
const std::map<int, const char*> _BattlePattern_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kBattlePatternValues, _kBattlePatternNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOperateCmdTypeValues[] = {
  OperateCmdType::MOVE,
  OperateCmdType::MOVE_STOP,
  OperateCmdType::DRAW_LINE_START,
  OperateCmdType::DRAW_LINE,
  OperateCmdType::DRAW_LINE_END,
  OperateCmdType::CREATE_CAGE,
  OperateCmdType::DRAW_WALL_ENERGY_START,
  OperateCmdType::DRAW_WALL_ENERGY_CANCEL,
  OperateCmdType::DRAW_WALL_START,
  OperateCmdType::DRAW_WALL,
  OperateCmdType::DRAW_WALL_END,
  OperateCmdType::USE_SKILL_START,
  OperateCmdType::USE_SKILL_STOP,
  OperateCmdType::USE_SKILL_ONCE,
  OperateCmdType::DROP_SKILL,
  OperateCmdType::USE_ULT_SKILL_START,
  OperateCmdType::USE_ULT_SKILL_END,
  OperateCmdType::USE_ULT_SKILL_TRIGGER,
  OperateCmdType::ULT_CONTROL_MOVE,
  OperateCmdType::USE_TAG
};
const char* _kOperateCmdTypeNames[] = {
  "MOVE",
  "MOVE_STOP",
  "DRAW_LINE_START",
  "DRAW_LINE",
  "DRAW_LINE_END",
  "CREATE_CAGE",
  "DRAW_WALL_ENERGY_START",
  "DRAW_WALL_ENERGY_CANCEL",
  "DRAW_WALL_START",
  "DRAW_WALL",
  "DRAW_WALL_END",
  "USE_SKILL_START",
  "USE_SKILL_STOP",
  "USE_SKILL_ONCE",
  "DROP_SKILL",
  "USE_ULT_SKILL_START",
  "USE_ULT_SKILL_END",
  "USE_ULT_SKILL_TRIGGER",
  "ULT_CONTROL_MOVE",
  "USE_TAG"
};
const std::map<int, const char*> _OperateCmdType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kOperateCmdTypeValues, _kOperateCmdTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSyncDataTypeValues[] = {
  SyncDataType::STATUS,
  SyncDataType::MOVE,
  SyncDataType::MOVE_END,
  SyncDataType::USE_SKILL,
  SyncDataType::BE_KILLED,
  SyncDataType::BULLET,
  SyncDataType::LINE,
  SyncDataType::CAGE,
  SyncDataType::REVIVE,
  SyncDataType::GET_ITEM,
  SyncDataType::ADD_BUFF,
  SyncDataType::DEL_BUFF,
  SyncDataType::TRIGGER_MAGIC,
  SyncDataType::DROP_SKILL,
  SyncDataType::USE_ULT_SKILL_START,
  SyncDataType::USE_ULT_SKILL_SUCCESS,
  SyncDataType::USE_ULT_SKILL_FAILED,
  SyncDataType::USE_ULT_SKILL_CANCEL,
  SyncDataType::USE_ULT_SKILL_TRIGGER,
  SyncDataType::TAG_SUCCESS
};
const char* _kSyncDataTypeNames[] = {
  "STATUS",
  "MOVE",
  "MOVE_END",
  "USE_SKILL",
  "BE_KILLED",
  "BULLET",
  "LINE",
  "CAGE",
  "REVIVE",
  "GET_ITEM",
  "ADD_BUFF",
  "DEL_BUFF",
  "TRIGGER_MAGIC",
  "DROP_SKILL",
  "USE_ULT_SKILL_START",
  "USE_ULT_SKILL_SUCCESS",
  "USE_ULT_SKILL_FAILED",
  "USE_ULT_SKILL_CANCEL",
  "USE_ULT_SKILL_TRIGGER",
  "TAG_SUCCESS"
};
const std::map<int, const char*> _SyncDataType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kSyncDataTypeValues, _kSyncDataTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLineTypeValues[] = {
  LineType::DrawLine,
  LineType::DrawWall
};
const char* _kLineTypeNames[] = {
  "DrawLine",
  "DrawWall"
};
const std::map<int, const char*> _LineType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLineTypeValues, _kLineTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kClassTypeValues[] = {
  ClassType::DRIVER,
  ClassType::SHOOTER
};
const char* _kClassTypeNames[] = {
  "DRIVER",
  "SHOOTER"
};
const std::map<int, const char*> _ClassType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kClassTypeValues, _kClassTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kObjTypeValues[] = {
  ObjType::PLAYER,
  ObjType::MONSTER,
  ObjType::ITEM,
  ObjType::MAGIC,
  ObjType::WALL_PALYER,
  ObjType::BASECENTER
};
const char* _kObjTypeNames[] = {
  "PLAYER",
  "MONSTER",
  "ITEM",
  "MAGIC",
  "WALL_PALYER",
  "BASECENTER"
};
const std::map<int, const char*> _ObjType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kObjTypeValues, _kObjTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMonsterTypeValues[] = {
  MonsterType::None,
  MonsterType::ResShark,
  MonsterType::Whale,
  MonsterType::GuardShark,
  MonsterType::FaceFish,
  MonsterType::BottleItem,
  MonsterType::BottleItem2
};
const char* _kMonsterTypeNames[] = {
  "None",
  "ResShark",
  "Whale",
  "GuardShark",
  "FaceFish",
  "BottleItem",
  "BottleItem2"
};
const std::map<int, const char*> _MonsterType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMonsterTypeValues, _kMonsterTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMagicTypeValues[] = {
  MagicType::None,
  MagicType::ShuiLei,
  MagicType::PaoDan
};
const char* _kMagicTypeNames[] = {
  "None",
  "ShuiLei",
  "PaoDan"
};
const std::map<int, const char*> _MagicType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMagicTypeValues, _kMagicTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFactionTypeValues[] = {
  FactionType::None,
  FactionType::FactionA,
  FactionType::FactionB,
  FactionType::FactionC
};
const char* _kFactionTypeNames[] = {
  "None",
  "FactionA",
  "FactionB",
  "FactionC"
};
const std::map<int, const char*> _FactionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFactionTypeValues, _kFactionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TVector3::~TVector3() throw() {
}


void TVector3::__set_x(const int32_t val) {
  this->x = val;
}

void TVector3::__set_y(const int32_t val) {
  this->y = val;
}

void TVector3::__set_z(const int32_t val) {
  this->z = val;
}

uint32_t TVector3::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TVector3::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TVector3");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TVector3 &a, TVector3 &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.__isset, b.__isset);
}

TVector3::TVector3(const TVector3& other0) {
  x = other0.x;
  y = other0.y;
  z = other0.z;
  __isset = other0.__isset;
}
TVector3& TVector3::operator=(const TVector3& other1) {
  x = other1.x;
  y = other1.y;
  z = other1.z;
  __isset = other1.__isset;
  return *this;
}
void TVector3::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TVector3(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ")";
}


TRotation::~TRotation() throw() {
}


void TRotation::__set_x(const int32_t val) {
  this->x = val;
}

void TRotation::__set_y(const int32_t val) {
  this->y = val;
}

void TRotation::__set_z(const int32_t val) {
  this->z = val;
}

void TRotation::__set_w(const int32_t val) {
  this->w = val;
}

uint32_t TRotation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->w);
          this->__isset.w = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TRotation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRotation");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("w", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->w);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRotation &a, TRotation &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.w, b.w);
  swap(a.__isset, b.__isset);
}

TRotation::TRotation(const TRotation& other2) {
  x = other2.x;
  y = other2.y;
  z = other2.z;
  w = other2.w;
  __isset = other2.__isset;
}
TRotation& TRotation::operator=(const TRotation& other3) {
  x = other3.x;
  y = other3.y;
  z = other3.z;
  w = other3.w;
  __isset = other3.__isset;
  return *this;
}
void TRotation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRotation(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ", " << "w=" << to_string(w);
  out << ")";
}


Bounds::~Bounds() throw() {
}


void Bounds::__set_center(const TVector3& val) {
  this->center = val;
}

void Bounds::__set_size(const TVector3& val) {
  this->size = val;
}

uint32_t Bounds::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->center.read(iprot);
          this->__isset.center = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->size.read(iprot);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Bounds::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Bounds");

  xfer += oprot->writeFieldBegin("center", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->center.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->size.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Bounds &a, Bounds &b) {
  using ::std::swap;
  swap(a.center, b.center);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

Bounds::Bounds(const Bounds& other4) {
  center = other4.center;
  size = other4.size;
  __isset = other4.__isset;
}
Bounds& Bounds::operator=(const Bounds& other5) {
  center = other5.center;
  size = other5.size;
  __isset = other5.__isset;
  return *this;
}
void Bounds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Bounds(";
  out << "center=" << to_string(center);
  out << ", " << "size=" << to_string(size);
  out << ")";
}


PlayerOperateCommand::~PlayerOperateCommand() throw() {
}


void PlayerOperateCommand::__set_uid(const int32_t val) {
  this->uid = val;
}

void PlayerOperateCommand::__set_type(const OperateCmdType::type val) {
  this->type = val;
}

void PlayerOperateCommand::__set_moveDir(const TVector3& val) {
  this->moveDir = val;
}

void PlayerOperateCommand::__set_argv1(const int32_t val) {
  this->argv1 = val;
}

void PlayerOperateCommand::__set_argv2(const int32_t val) {
  this->argv2 = val;
}

void PlayerOperateCommand::__set_argv3(const int32_t val) {
  this->argv3 = val;
}

uint32_t PlayerOperateCommand::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->type = (OperateCmdType::type)ecast6;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->moveDir.read(iprot);
          this->__isset.moveDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->argv1);
          this->__isset.argv1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->argv2);
          this->__isset.argv2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->argv3);
          this->__isset.argv3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerOperateCommand::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlayerOperateCommand");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("moveDir", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->moveDir.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("argv1", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->argv1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("argv2", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->argv2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("argv3", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->argv3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerOperateCommand &a, PlayerOperateCommand &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.type, b.type);
  swap(a.moveDir, b.moveDir);
  swap(a.argv1, b.argv1);
  swap(a.argv2, b.argv2);
  swap(a.argv3, b.argv3);
  swap(a.__isset, b.__isset);
}

PlayerOperateCommand::PlayerOperateCommand(const PlayerOperateCommand& other7) {
  uid = other7.uid;
  type = other7.type;
  moveDir = other7.moveDir;
  argv1 = other7.argv1;
  argv2 = other7.argv2;
  argv3 = other7.argv3;
  __isset = other7.__isset;
}
PlayerOperateCommand& PlayerOperateCommand::operator=(const PlayerOperateCommand& other8) {
  uid = other8.uid;
  type = other8.type;
  moveDir = other8.moveDir;
  argv1 = other8.argv1;
  argv2 = other8.argv2;
  argv3 = other8.argv3;
  __isset = other8.__isset;
  return *this;
}
void PlayerOperateCommand::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlayerOperateCommand(";
  out << "uid=" << to_string(uid);
  out << ", " << "type=" << to_string(type);
  out << ", " << "moveDir=" << to_string(moveDir);
  out << ", " << "argv1=" << to_string(argv1);
  out << ", " << "argv2=" << to_string(argv2);
  out << ", " << "argv3=" << to_string(argv3);
  out << ")";
}


MovementData::~MovementData() throw() {
}


void MovementData::__set_moveDir(const TVector3& val) {
  this->moveDir = val;
}

void MovementData::__set_facingDir(const TVector3& val) {
  this->facingDir = val;
}

uint32_t MovementData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->moveDir.read(iprot);
          this->__isset.moveDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->facingDir.read(iprot);
          this->__isset.facingDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MovementData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MovementData");

  xfer += oprot->writeFieldBegin("moveDir", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->moveDir.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("facingDir", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->facingDir.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MovementData &a, MovementData &b) {
  using ::std::swap;
  swap(a.moveDir, b.moveDir);
  swap(a.facingDir, b.facingDir);
  swap(a.__isset, b.__isset);
}

MovementData::MovementData(const MovementData& other9) {
  moveDir = other9.moveDir;
  facingDir = other9.facingDir;
  __isset = other9.__isset;
}
MovementData& MovementData::operator=(const MovementData& other10) {
  moveDir = other10.moveDir;
  facingDir = other10.facingDir;
  __isset = other10.__isset;
  return *this;
}
void MovementData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MovementData(";
  out << "moveDir=" << to_string(moveDir);
  out << ", " << "facingDir=" << to_string(facingDir);
  out << ")";
}


StateMaps::~StateMaps() throw() {
}


void StateMaps::__set_bools(const std::map<int32_t, bool> & val) {
  this->bools = val;
}

void StateMaps::__set_ints(const std::map<int32_t, int32_t> & val) {
  this->ints = val;
}

void StateMaps::__set_decimals(const std::map<int32_t, double> & val) {
  this->decimals = val;
}

void StateMaps::__set_vectors(const std::map<int32_t, TVector3> & val) {
  this->vectors = val;
}

uint32_t StateMaps::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->bools.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              int32_t _key16;
              xfer += iprot->readI32(_key16);
              bool& _val17 = this->bools[_key16];
              xfer += iprot->readBool(_val17);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.bools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ints.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              int32_t _key23;
              xfer += iprot->readI32(_key23);
              int32_t& _val24 = this->ints[_key23];
              xfer += iprot->readI32(_val24);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->decimals.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _ktype26;
            ::apache::thrift::protocol::TType _vtype27;
            xfer += iprot->readMapBegin(_ktype26, _vtype27, _size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              int32_t _key30;
              xfer += iprot->readI32(_key30);
              double& _val31 = this->decimals[_key30];
              xfer += iprot->readDouble(_val31);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.decimals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vectors.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _ktype33;
            ::apache::thrift::protocol::TType _vtype34;
            xfer += iprot->readMapBegin(_ktype33, _vtype34, _size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              int32_t _key37;
              xfer += iprot->readI32(_key37);
              TVector3& _val38 = this->vectors[_key37];
              xfer += _val38.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StateMaps::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StateMaps");

  xfer += oprot->writeFieldBegin("bools", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->bools.size()));
    std::map<int32_t, bool> ::const_iterator _iter39;
    for (_iter39 = this->bools.begin(); _iter39 != this->bools.end(); ++_iter39)
    {
      xfer += oprot->writeI32(_iter39->first);
      xfer += oprot->writeBool(_iter39->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ints", ::apache::thrift::protocol::T_MAP, 20);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->ints.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter40;
    for (_iter40 = this->ints.begin(); _iter40 != this->ints.end(); ++_iter40)
    {
      xfer += oprot->writeI32(_iter40->first);
      xfer += oprot->writeI32(_iter40->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("decimals", ::apache::thrift::protocol::T_MAP, 30);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->decimals.size()));
    std::map<int32_t, double> ::const_iterator _iter41;
    for (_iter41 = this->decimals.begin(); _iter41 != this->decimals.end(); ++_iter41)
    {
      xfer += oprot->writeI32(_iter41->first);
      xfer += oprot->writeDouble(_iter41->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vectors", ::apache::thrift::protocol::T_MAP, 40);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vectors.size()));
    std::map<int32_t, TVector3> ::const_iterator _iter42;
    for (_iter42 = this->vectors.begin(); _iter42 != this->vectors.end(); ++_iter42)
    {
      xfer += oprot->writeI32(_iter42->first);
      xfer += _iter42->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StateMaps &a, StateMaps &b) {
  using ::std::swap;
  swap(a.bools, b.bools);
  swap(a.ints, b.ints);
  swap(a.decimals, b.decimals);
  swap(a.vectors, b.vectors);
  swap(a.__isset, b.__isset);
}

StateMaps::StateMaps(const StateMaps& other43) {
  bools = other43.bools;
  ints = other43.ints;
  decimals = other43.decimals;
  vectors = other43.vectors;
  __isset = other43.__isset;
}
StateMaps& StateMaps::operator=(const StateMaps& other44) {
  bools = other44.bools;
  ints = other44.ints;
  decimals = other44.decimals;
  vectors = other44.vectors;
  __isset = other44.__isset;
  return *this;
}
void StateMaps::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StateMaps(";
  out << "bools=" << to_string(bools);
  out << ", " << "ints=" << to_string(ints);
  out << ", " << "decimals=" << to_string(decimals);
  out << ", " << "vectors=" << to_string(vectors);
  out << ")";
}


UnitSyncData::~UnitSyncData() throw() {
}


void UnitSyncData::__set_states(const StateMaps& val) {
  this->states = val;
}

uint32_t UnitSyncData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->states.read(iprot);
          this->__isset.states = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnitSyncData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnitSyncData");

  xfer += oprot->writeFieldBegin("states", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->states.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnitSyncData &a, UnitSyncData &b) {
  using ::std::swap;
  swap(a.states, b.states);
  swap(a.__isset, b.__isset);
}

UnitSyncData::UnitSyncData(const UnitSyncData& other45) {
  states = other45.states;
  __isset = other45.__isset;
}
UnitSyncData& UnitSyncData::operator=(const UnitSyncData& other46) {
  states = other46.states;
  __isset = other46.__isset;
  return *this;
}
void UnitSyncData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnitSyncData(";
  out << "states=" << to_string(states);
  out << ")";
}


Move::~Move() throw() {
}


void Move::__set_pos(const TVector3& val) {
  this->pos = val;
}

void Move::__set_dir(const TVector3& val) {
  this->dir = val;
}

void Move::__set_rot(const TRotation& val) {
  this->rot = val;
}

uint32_t Move::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dir.read(iprot);
          this->__isset.dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rot.read(iprot);
          this->__isset.rot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Move::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Move");

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dir", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->dir.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rot", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->rot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Move &a, Move &b) {
  using ::std::swap;
  swap(a.pos, b.pos);
  swap(a.dir, b.dir);
  swap(a.rot, b.rot);
  swap(a.__isset, b.__isset);
}

Move::Move(const Move& other47) {
  pos = other47.pos;
  dir = other47.dir;
  rot = other47.rot;
  __isset = other47.__isset;
}
Move& Move::operator=(const Move& other48) {
  pos = other48.pos;
  dir = other48.dir;
  rot = other48.rot;
  __isset = other48.__isset;
  return *this;
}
void Move::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Move(";
  out << "pos=" << to_string(pos);
  out << ", " << "dir=" << to_string(dir);
  out << ", " << "rot=" << to_string(rot);
  out << ")";
}


MoveStop::~MoveStop() throw() {
}


void MoveStop::__set_pos(const TVector3& val) {
  this->pos = val;
}

void MoveStop::__set_rot(const TRotation& val) {
  this->rot = val;
}

uint32_t MoveStop::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rot.read(iprot);
          this->__isset.rot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MoveStop::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MoveStop");

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rot", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->rot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MoveStop &a, MoveStop &b) {
  using ::std::swap;
  swap(a.pos, b.pos);
  swap(a.rot, b.rot);
  swap(a.__isset, b.__isset);
}

MoveStop::MoveStop(const MoveStop& other49) {
  pos = other49.pos;
  rot = other49.rot;
  __isset = other49.__isset;
}
MoveStop& MoveStop::operator=(const MoveStop& other50) {
  pos = other50.pos;
  rot = other50.rot;
  __isset = other50.__isset;
  return *this;
}
void MoveStop::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MoveStop(";
  out << "pos=" << to_string(pos);
  out << ", " << "rot=" << to_string(rot);
  out << ")";
}


UseSkill::~UseSkill() throw() {
}


void UseSkill::__set_skillId(const int32_t val) {
  this->skillId = val;
}

void UseSkill::__set_targetIds(const std::vector<int32_t> & val) {
  this->targetIds = val;
}

uint32_t UseSkill::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->skillId);
          this->__isset.skillId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targetIds.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->targetIds.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += iprot->readI32(this->targetIds[_i55]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.targetIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseSkill::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UseSkill");

  xfer += oprot->writeFieldBegin("skillId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->skillId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetIds", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->targetIds.size()));
    std::vector<int32_t> ::const_iterator _iter56;
    for (_iter56 = this->targetIds.begin(); _iter56 != this->targetIds.end(); ++_iter56)
    {
      xfer += oprot->writeI32((*_iter56));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseSkill &a, UseSkill &b) {
  using ::std::swap;
  swap(a.skillId, b.skillId);
  swap(a.targetIds, b.targetIds);
  swap(a.__isset, b.__isset);
}

UseSkill::UseSkill(const UseSkill& other57) {
  skillId = other57.skillId;
  targetIds = other57.targetIds;
  __isset = other57.__isset;
}
UseSkill& UseSkill::operator=(const UseSkill& other58) {
  skillId = other58.skillId;
  targetIds = other58.targetIds;
  __isset = other58.__isset;
  return *this;
}
void UseSkill::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UseSkill(";
  out << "skillId=" << to_string(skillId);
  out << ", " << "targetIds=" << to_string(targetIds);
  out << ")";
}


KillDead::~KillDead() throw() {
}


void KillDead::__set_killerId(const int32_t val) {
  this->killerId = val;
}

uint32_t KillDead::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->killerId);
          this->__isset.killerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KillDead::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KillDead");

  xfer += oprot->writeFieldBegin("killerId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->killerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KillDead &a, KillDead &b) {
  using ::std::swap;
  swap(a.killerId, b.killerId);
  swap(a.__isset, b.__isset);
}

KillDead::KillDead(const KillDead& other59) {
  killerId = other59.killerId;
  __isset = other59.__isset;
}
KillDead& KillDead::operator=(const KillDead& other60) {
  killerId = other60.killerId;
  __isset = other60.__isset;
  return *this;
}
void KillDead::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KillDead(";
  out << "killerId=" << to_string(killerId);
  out << ")";
}


Bullet::~Bullet() throw() {
}


void Bullet::__set_uid(const int32_t val) {
  this->uid = val;
}

void Bullet::__set_casterId(const int32_t val) {
  this->casterId = val;
}

void Bullet::__set_pos(const TVector3& val) {
  this->pos = val;
}

void Bullet::__set_dir(const TVector3& val) {
  this->dir = val;
}

uint32_t Bullet::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->casterId);
          this->__isset.casterId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dir.read(iprot);
          this->__isset.dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Bullet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Bullet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("casterId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->casterId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dir", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->dir.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Bullet &a, Bullet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.casterId, b.casterId);
  swap(a.pos, b.pos);
  swap(a.dir, b.dir);
  swap(a.__isset, b.__isset);
}

Bullet::Bullet(const Bullet& other61) {
  uid = other61.uid;
  casterId = other61.casterId;
  pos = other61.pos;
  dir = other61.dir;
  __isset = other61.__isset;
}
Bullet& Bullet::operator=(const Bullet& other62) {
  uid = other62.uid;
  casterId = other62.casterId;
  pos = other62.pos;
  dir = other62.dir;
  __isset = other62.__isset;
  return *this;
}
void Bullet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Bullet(";
  out << "uid=" << to_string(uid);
  out << ", " << "casterId=" << to_string(casterId);
  out << ", " << "pos=" << to_string(pos);
  out << ", " << "dir=" << to_string(dir);
  out << ")";
}


SyncBullet::~SyncBullet() throw() {
}


void SyncBullet::__set_bulletList(const std::vector<Bullet> & val) {
  this->bulletList = val;
}

uint32_t SyncBullet::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bulletList.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->bulletList.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += this->bulletList[_i67].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bulletList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SyncBullet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SyncBullet");

  xfer += oprot->writeFieldBegin("bulletList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bulletList.size()));
    std::vector<Bullet> ::const_iterator _iter68;
    for (_iter68 = this->bulletList.begin(); _iter68 != this->bulletList.end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncBullet &a, SyncBullet &b) {
  using ::std::swap;
  swap(a.bulletList, b.bulletList);
  swap(a.__isset, b.__isset);
}

SyncBullet::SyncBullet(const SyncBullet& other69) {
  bulletList = other69.bulletList;
  __isset = other69.__isset;
}
SyncBullet& SyncBullet::operator=(const SyncBullet& other70) {
  bulletList = other70.bulletList;
  __isset = other70.__isset;
  return *this;
}
void SyncBullet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SyncBullet(";
  out << "bulletList=" << to_string(bulletList);
  out << ")";
}


Line::~Line() throw() {
}


void Line::__set_uid(const int32_t val) {
  this->uid = val;
}

void Line::__set_casterId(const int32_t val) {
  this->casterId = val;
}

void Line::__set_points(const std::vector<TVector3> & val) {
  this->points = val;
}

void Line::__set_isEnd(const bool val) {
  this->isEnd = val;
}

void Line::__set_lineType(const LineType::type val) {
  this->lineType = val;
}

uint32_t Line::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->casterId);
          this->__isset.casterId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->points.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += this->points[_i75].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isEnd);
          this->__isset.isEnd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          this->lineType = (LineType::type)ecast76;
          this->__isset.lineType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Line::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Line");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("casterId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->casterId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 30);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<TVector3> ::const_iterator _iter77;
    for (_iter77 = this->points.begin(); _iter77 != this->points.end(); ++_iter77)
    {
      xfer += (*_iter77).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isEnd", ::apache::thrift::protocol::T_BOOL, 40);
  xfer += oprot->writeBool(this->isEnd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lineType", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32((int32_t)this->lineType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Line &a, Line &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.casterId, b.casterId);
  swap(a.points, b.points);
  swap(a.isEnd, b.isEnd);
  swap(a.lineType, b.lineType);
  swap(a.__isset, b.__isset);
}

Line::Line(const Line& other78) {
  uid = other78.uid;
  casterId = other78.casterId;
  points = other78.points;
  isEnd = other78.isEnd;
  lineType = other78.lineType;
  __isset = other78.__isset;
}
Line& Line::operator=(const Line& other79) {
  uid = other79.uid;
  casterId = other79.casterId;
  points = other79.points;
  isEnd = other79.isEnd;
  lineType = other79.lineType;
  __isset = other79.__isset;
  return *this;
}
void Line::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Line(";
  out << "uid=" << to_string(uid);
  out << ", " << "casterId=" << to_string(casterId);
  out << ", " << "points=" << to_string(points);
  out << ", " << "isEnd=" << to_string(isEnd);
  out << ", " << "lineType=" << to_string(lineType);
  out << ")";
}


Cage::~Cage() throw() {
}


void Cage::__set_uid(const int32_t val) {
  this->uid = val;
}

void Cage::__set_center(const TVector3& val) {
  this->center = val;
}

void Cage::__set_radius(const int32_t val) {
  this->radius = val;
}

void Cage::__set_captureTime(const int32_t val) {
  this->captureTime = val;
}

uint32_t Cage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->center.read(iprot);
          this->__isset.center = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->radius);
          this->__isset.radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->captureTime);
          this->__isset.captureTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cage");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("center", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->center.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("radius", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("captureTime", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->captureTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cage &a, Cage &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.center, b.center);
  swap(a.radius, b.radius);
  swap(a.captureTime, b.captureTime);
  swap(a.__isset, b.__isset);
}

Cage::Cage(const Cage& other80) {
  uid = other80.uid;
  center = other80.center;
  radius = other80.radius;
  captureTime = other80.captureTime;
  __isset = other80.__isset;
}
Cage& Cage::operator=(const Cage& other81) {
  uid = other81.uid;
  center = other81.center;
  radius = other81.radius;
  captureTime = other81.captureTime;
  __isset = other81.__isset;
  return *this;
}
void Cage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cage(";
  out << "uid=" << to_string(uid);
  out << ", " << "center=" << to_string(center);
  out << ", " << "radius=" << to_string(radius);
  out << ", " << "captureTime=" << to_string(captureTime);
  out << ")";
}


Revive::~Revive() throw() {
}


void Revive::__set_bornId(const int32_t val) {
  this->bornId = val;
}

void Revive::__set_bornPos(const TVector3& val) {
  this->bornPos = val;
}

uint32_t Revive::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bornId);
          this->__isset.bornId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bornPos.read(iprot);
          this->__isset.bornPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Revive::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Revive");

  xfer += oprot->writeFieldBegin("bornId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->bornId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bornPos", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->bornPos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Revive &a, Revive &b) {
  using ::std::swap;
  swap(a.bornId, b.bornId);
  swap(a.bornPos, b.bornPos);
  swap(a.__isset, b.__isset);
}

Revive::Revive(const Revive& other82) {
  bornId = other82.bornId;
  bornPos = other82.bornPos;
  __isset = other82.__isset;
}
Revive& Revive::operator=(const Revive& other83) {
  bornId = other83.bornId;
  bornPos = other83.bornPos;
  __isset = other83.__isset;
  return *this;
}
void Revive::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Revive(";
  out << "bornId=" << to_string(bornId);
  out << ", " << "bornPos=" << to_string(bornPos);
  out << ")";
}


SyncLine::~SyncLine() throw() {
}


void SyncLine::__set_lineList(const std::vector<Line> & val) {
  this->lineList = val;
}

uint32_t SyncLine::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lineList.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->lineList.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->lineList[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lineList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SyncLine::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SyncLine");

  xfer += oprot->writeFieldBegin("lineList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lineList.size()));
    std::vector<Line> ::const_iterator _iter89;
    for (_iter89 = this->lineList.begin(); _iter89 != this->lineList.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncLine &a, SyncLine &b) {
  using ::std::swap;
  swap(a.lineList, b.lineList);
  swap(a.__isset, b.__isset);
}

SyncLine::SyncLine(const SyncLine& other90) {
  lineList = other90.lineList;
  __isset = other90.__isset;
}
SyncLine& SyncLine::operator=(const SyncLine& other91) {
  lineList = other91.lineList;
  __isset = other91.__isset;
  return *this;
}
void SyncLine::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SyncLine(";
  out << "lineList=" << to_string(lineList);
  out << ")";
}


GetItem::~GetItem() throw() {
}


void GetItem::__set_itemUid(const int32_t val) {
  this->itemUid = val;
}

uint32_t GetItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemUid);
          this->__isset.itemUid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetItem");

  xfer += oprot->writeFieldBegin("itemUid", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->itemUid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetItem &a, GetItem &b) {
  using ::std::swap;
  swap(a.itemUid, b.itemUid);
  swap(a.__isset, b.__isset);
}

GetItem::GetItem(const GetItem& other92) {
  itemUid = other92.itemUid;
  __isset = other92.__isset;
}
GetItem& GetItem::operator=(const GetItem& other93) {
  itemUid = other93.itemUid;
  __isset = other93.__isset;
  return *this;
}
void GetItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetItem(";
  out << "itemUid=" << to_string(itemUid);
  out << ")";
}


AddBuff::~AddBuff() throw() {
}


void AddBuff::__set_id(const int32_t val) {
  this->id = val;
}

uint32_t AddBuff::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddBuff::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddBuff");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddBuff &a, AddBuff &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

AddBuff::AddBuff(const AddBuff& other94) {
  id = other94.id;
  __isset = other94.__isset;
}
AddBuff& AddBuff::operator=(const AddBuff& other95) {
  id = other95.id;
  __isset = other95.__isset;
  return *this;
}
void AddBuff::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddBuff(";
  out << "id=" << to_string(id);
  out << ")";
}


DelBuff::~DelBuff() throw() {
}


void DelBuff::__set_id(const int32_t val) {
  this->id = val;
}

uint32_t DelBuff::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DelBuff::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DelBuff");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DelBuff &a, DelBuff &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

DelBuff::DelBuff(const DelBuff& other96) {
  id = other96.id;
  __isset = other96.__isset;
}
DelBuff& DelBuff::operator=(const DelBuff& other97) {
  id = other97.id;
  __isset = other97.__isset;
  return *this;
}
void DelBuff::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DelBuff(";
  out << "id=" << to_string(id);
  out << ")";
}


TriggerMagic::~TriggerMagic() throw() {
}


void TriggerMagic::__set_magicId(const int32_t val) {
  this->magicId = val;
}

uint32_t TriggerMagic::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->magicId);
          this->__isset.magicId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TriggerMagic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TriggerMagic");

  xfer += oprot->writeFieldBegin("magicId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->magicId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TriggerMagic &a, TriggerMagic &b) {
  using ::std::swap;
  swap(a.magicId, b.magicId);
  swap(a.__isset, b.__isset);
}

TriggerMagic::TriggerMagic(const TriggerMagic& other98) {
  magicId = other98.magicId;
  __isset = other98.__isset;
}
TriggerMagic& TriggerMagic::operator=(const TriggerMagic& other99) {
  magicId = other99.magicId;
  __isset = other99.__isset;
  return *this;
}
void TriggerMagic::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TriggerMagic(";
  out << "magicId=" << to_string(magicId);
  out << ")";
}


DropSkill::~DropSkill() throw() {
}


void DropSkill::__set_skillId(const int32_t val) {
  this->skillId = val;
}

void DropSkill::__set_isA(const bool val) {
  this->isA = val;
}

uint32_t DropSkill::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->skillId);
          this->__isset.skillId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isA);
          this->__isset.isA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropSkill::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropSkill");

  xfer += oprot->writeFieldBegin("skillId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->skillId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isA", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->isA);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropSkill &a, DropSkill &b) {
  using ::std::swap;
  swap(a.skillId, b.skillId);
  swap(a.isA, b.isA);
  swap(a.__isset, b.__isset);
}

DropSkill::DropSkill(const DropSkill& other100) {
  skillId = other100.skillId;
  isA = other100.isA;
  __isset = other100.__isset;
}
DropSkill& DropSkill::operator=(const DropSkill& other101) {
  skillId = other101.skillId;
  isA = other101.isA;
  __isset = other101.__isset;
  return *this;
}
void DropSkill::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropSkill(";
  out << "skillId=" << to_string(skillId);
  out << ", " << "isA=" << to_string(isA);
  out << ")";
}


UseUltSkillStart::~UseUltSkillStart() throw() {
}


void UseUltSkillStart::__set_id(const int32_t val) {
  this->id = val;
}

uint32_t UseUltSkillStart::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseUltSkillStart::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UseUltSkillStart");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseUltSkillStart &a, UseUltSkillStart &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

UseUltSkillStart::UseUltSkillStart(const UseUltSkillStart& other102) {
  id = other102.id;
  __isset = other102.__isset;
}
UseUltSkillStart& UseUltSkillStart::operator=(const UseUltSkillStart& other103) {
  id = other103.id;
  __isset = other103.__isset;
  return *this;
}
void UseUltSkillStart::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UseUltSkillStart(";
  out << "id=" << to_string(id);
  out << ")";
}


UseUltSkillSuccess::~UseUltSkillSuccess() throw() {
}


void UseUltSkillSuccess::__set_id(const int32_t val) {
  this->id = val;
}

void UseUltSkillSuccess::__set_power(const int32_t val) {
  this->power = val;
}

void UseUltSkillSuccess::__set_rot(const TRotation& val) {
  this->rot = val;
}

uint32_t UseUltSkillSuccess::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->power);
          this->__isset.power = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rot.read(iprot);
          this->__isset.rot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseUltSkillSuccess::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UseUltSkillSuccess");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("power", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->power);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rot", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->rot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseUltSkillSuccess &a, UseUltSkillSuccess &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.power, b.power);
  swap(a.rot, b.rot);
  swap(a.__isset, b.__isset);
}

UseUltSkillSuccess::UseUltSkillSuccess(const UseUltSkillSuccess& other104) {
  id = other104.id;
  power = other104.power;
  rot = other104.rot;
  __isset = other104.__isset;
}
UseUltSkillSuccess& UseUltSkillSuccess::operator=(const UseUltSkillSuccess& other105) {
  id = other105.id;
  power = other105.power;
  rot = other105.rot;
  __isset = other105.__isset;
  return *this;
}
void UseUltSkillSuccess::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UseUltSkillSuccess(";
  out << "id=" << to_string(id);
  out << ", " << "power=" << to_string(power);
  out << ", " << "rot=" << to_string(rot);
  out << ")";
}


UseUltSkillFailed::~UseUltSkillFailed() throw() {
}


void UseUltSkillFailed::__set_id(const int32_t val) {
  this->id = val;
}

uint32_t UseUltSkillFailed::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseUltSkillFailed::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UseUltSkillFailed");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseUltSkillFailed &a, UseUltSkillFailed &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

UseUltSkillFailed::UseUltSkillFailed(const UseUltSkillFailed& other106) {
  id = other106.id;
  __isset = other106.__isset;
}
UseUltSkillFailed& UseUltSkillFailed::operator=(const UseUltSkillFailed& other107) {
  id = other107.id;
  __isset = other107.__isset;
  return *this;
}
void UseUltSkillFailed::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UseUltSkillFailed(";
  out << "id=" << to_string(id);
  out << ")";
}


UseUltSkillCancel::~UseUltSkillCancel() throw() {
}


void UseUltSkillCancel::__set_id(const int32_t val) {
  this->id = val;
}

uint32_t UseUltSkillCancel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseUltSkillCancel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UseUltSkillCancel");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseUltSkillCancel &a, UseUltSkillCancel &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

UseUltSkillCancel::UseUltSkillCancel(const UseUltSkillCancel& other108) {
  id = other108.id;
  __isset = other108.__isset;
}
UseUltSkillCancel& UseUltSkillCancel::operator=(const UseUltSkillCancel& other109) {
  id = other109.id;
  __isset = other109.__isset;
  return *this;
}
void UseUltSkillCancel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UseUltSkillCancel(";
  out << "id=" << to_string(id);
  out << ")";
}


UseUltSkillTrigger::~UseUltSkillTrigger() throw() {
}


void UseUltSkillTrigger::__set_id(const int32_t val) {
  this->id = val;
}

void UseUltSkillTrigger::__set_stage(const int32_t val) {
  this->stage = val;
}

uint32_t UseUltSkillTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stage);
          this->__isset.stage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseUltSkillTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UseUltSkillTrigger");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stage", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->stage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseUltSkillTrigger &a, UseUltSkillTrigger &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.stage, b.stage);
  swap(a.__isset, b.__isset);
}

UseUltSkillTrigger::UseUltSkillTrigger(const UseUltSkillTrigger& other110) {
  id = other110.id;
  stage = other110.stage;
  __isset = other110.__isset;
}
UseUltSkillTrigger& UseUltSkillTrigger::operator=(const UseUltSkillTrigger& other111) {
  id = other111.id;
  stage = other111.stage;
  __isset = other111.__isset;
  return *this;
}
void UseUltSkillTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UseUltSkillTrigger(";
  out << "id=" << to_string(id);
  out << ", " << "stage=" << to_string(stage);
  out << ")";
}


TagSuccess::~TagSuccess() throw() {
}


void TagSuccess::__set_type(const int32_t val) {
  this->type = val;
}

void TagSuccess::__set_pos(const TVector3& val) {
  this->pos = val;
}

uint32_t TagSuccess::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TagSuccess::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TagSuccess");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TagSuccess &a, TagSuccess &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.pos, b.pos);
  swap(a.__isset, b.__isset);
}

TagSuccess::TagSuccess(const TagSuccess& other112) {
  type = other112.type;
  pos = other112.pos;
  __isset = other112.__isset;
}
TagSuccess& TagSuccess::operator=(const TagSuccess& other113) {
  type = other113.type;
  pos = other113.pos;
  __isset = other113.__isset;
  return *this;
}
void TagSuccess::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TagSuccess(";
  out << "type=" << to_string(type);
  out << ", " << "pos=" << to_string(pos);
  out << ")";
}


SyncData::~SyncData() throw() {
}


void SyncData::__set_uid(const int32_t val) {
  this->uid = val;
}

void SyncData::__set_syncType(const SyncDataType::type val) {
  this->syncType = val;
}

void SyncData::__set_unitStatus(const UnitSyncData& val) {
  this->unitStatus = val;
__isset.unitStatus = true;
}

void SyncData::__set_move(const Move& val) {
  this->move = val;
__isset.move = true;
}

void SyncData::__set_moveStop(const MoveStop& val) {
  this->moveStop = val;
__isset.moveStop = true;
}

void SyncData::__set_userSkill(const UseSkill& val) {
  this->userSkill = val;
__isset.userSkill = true;
}

void SyncData::__set_killDead(const KillDead& val) {
  this->killDead = val;
__isset.killDead = true;
}

void SyncData::__set_bullet(const SyncBullet& val) {
  this->bullet = val;
__isset.bullet = true;
}

void SyncData::__set_line(const SyncLine& val) {
  this->line = val;
__isset.line = true;
}

void SyncData::__set_cage(const Cage& val) {
  this->cage = val;
__isset.cage = true;
}

void SyncData::__set_revive(const Revive& val) {
  this->revive = val;
__isset.revive = true;
}

void SyncData::__set_getItem(const GetItem& val) {
  this->getItem = val;
__isset.getItem = true;
}

void SyncData::__set_addBuff(const AddBuff& val) {
  this->addBuff = val;
__isset.addBuff = true;
}

void SyncData::__set_delBuff(const DelBuff& val) {
  this->delBuff = val;
__isset.delBuff = true;
}

void SyncData::__set_triggerMagic(const TriggerMagic& val) {
  this->triggerMagic = val;
__isset.triggerMagic = true;
}

void SyncData::__set_dropSkill(const DropSkill& val) {
  this->dropSkill = val;
__isset.dropSkill = true;
}

void SyncData::__set_useUltSkillStart(const UseUltSkillStart& val) {
  this->useUltSkillStart = val;
__isset.useUltSkillStart = true;
}

void SyncData::__set_useUltSkillSuccess(const UseUltSkillSuccess& val) {
  this->useUltSkillSuccess = val;
__isset.useUltSkillSuccess = true;
}

void SyncData::__set_useUltSkillFailed(const UseUltSkillFailed& val) {
  this->useUltSkillFailed = val;
__isset.useUltSkillFailed = true;
}

void SyncData::__set_useUltSkillCancel(const UseUltSkillCancel& val) {
  this->useUltSkillCancel = val;
__isset.useUltSkillCancel = true;
}

void SyncData::__set_useUltSkillTrigger(const UseUltSkillTrigger& val) {
  this->useUltSkillTrigger = val;
__isset.useUltSkillTrigger = true;
}

void SyncData::__set_useTag(const TagSuccess& val) {
  this->useTag = val;
__isset.useTag = true;
}

uint32_t SyncData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast114;
          xfer += iprot->readI32(ecast114);
          this->syncType = (SyncDataType::type)ecast114;
          this->__isset.syncType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unitStatus.read(iprot);
          this->__isset.unitStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->move.read(iprot);
          this->__isset.move = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->moveStop.read(iprot);
          this->__isset.moveStop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userSkill.read(iprot);
          this->__isset.userSkill = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->killDead.read(iprot);
          this->__isset.killDead = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bullet.read(iprot);
          this->__isset.bullet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->line.read(iprot);
          this->__isset.line = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cage.read(iprot);
          this->__isset.cage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->revive.read(iprot);
          this->__isset.revive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->getItem.read(iprot);
          this->__isset.getItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->addBuff.read(iprot);
          this->__isset.addBuff = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 140:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->delBuff.read(iprot);
          this->__isset.delBuff = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 150:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->triggerMagic.read(iprot);
          this->__isset.triggerMagic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 160:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dropSkill.read(iprot);
          this->__isset.dropSkill = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 170:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->useUltSkillStart.read(iprot);
          this->__isset.useUltSkillStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 175:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->useUltSkillSuccess.read(iprot);
          this->__isset.useUltSkillSuccess = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 180:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->useUltSkillFailed.read(iprot);
          this->__isset.useUltSkillFailed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 190:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->useUltSkillCancel.read(iprot);
          this->__isset.useUltSkillCancel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 200:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->useUltSkillTrigger.read(iprot);
          this->__isset.useUltSkillTrigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 210:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->useTag.read(iprot);
          this->__isset.useTag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SyncData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SyncData");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syncType", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32((int32_t)this->syncType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.unitStatus) {
    xfer += oprot->writeFieldBegin("unitStatus", ::apache::thrift::protocol::T_STRUCT, 30);
    xfer += this->unitStatus.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.move) {
    xfer += oprot->writeFieldBegin("move", ::apache::thrift::protocol::T_STRUCT, 40);
    xfer += this->move.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.moveStop) {
    xfer += oprot->writeFieldBegin("moveStop", ::apache::thrift::protocol::T_STRUCT, 50);
    xfer += this->moveStop.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userSkill) {
    xfer += oprot->writeFieldBegin("userSkill", ::apache::thrift::protocol::T_STRUCT, 60);
    xfer += this->userSkill.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.killDead) {
    xfer += oprot->writeFieldBegin("killDead", ::apache::thrift::protocol::T_STRUCT, 70);
    xfer += this->killDead.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bullet) {
    xfer += oprot->writeFieldBegin("bullet", ::apache::thrift::protocol::T_STRUCT, 80);
    xfer += this->bullet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.line) {
    xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_STRUCT, 90);
    xfer += this->line.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cage) {
    xfer += oprot->writeFieldBegin("cage", ::apache::thrift::protocol::T_STRUCT, 100);
    xfer += this->cage.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revive) {
    xfer += oprot->writeFieldBegin("revive", ::apache::thrift::protocol::T_STRUCT, 110);
    xfer += this->revive.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.getItem) {
    xfer += oprot->writeFieldBegin("getItem", ::apache::thrift::protocol::T_STRUCT, 120);
    xfer += this->getItem.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.addBuff) {
    xfer += oprot->writeFieldBegin("addBuff", ::apache::thrift::protocol::T_STRUCT, 130);
    xfer += this->addBuff.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.delBuff) {
    xfer += oprot->writeFieldBegin("delBuff", ::apache::thrift::protocol::T_STRUCT, 140);
    xfer += this->delBuff.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggerMagic) {
    xfer += oprot->writeFieldBegin("triggerMagic", ::apache::thrift::protocol::T_STRUCT, 150);
    xfer += this->triggerMagic.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dropSkill) {
    xfer += oprot->writeFieldBegin("dropSkill", ::apache::thrift::protocol::T_STRUCT, 160);
    xfer += this->dropSkill.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.useUltSkillStart) {
    xfer += oprot->writeFieldBegin("useUltSkillStart", ::apache::thrift::protocol::T_STRUCT, 170);
    xfer += this->useUltSkillStart.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.useUltSkillSuccess) {
    xfer += oprot->writeFieldBegin("useUltSkillSuccess", ::apache::thrift::protocol::T_STRUCT, 175);
    xfer += this->useUltSkillSuccess.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.useUltSkillFailed) {
    xfer += oprot->writeFieldBegin("useUltSkillFailed", ::apache::thrift::protocol::T_STRUCT, 180);
    xfer += this->useUltSkillFailed.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.useUltSkillCancel) {
    xfer += oprot->writeFieldBegin("useUltSkillCancel", ::apache::thrift::protocol::T_STRUCT, 190);
    xfer += this->useUltSkillCancel.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.useUltSkillTrigger) {
    xfer += oprot->writeFieldBegin("useUltSkillTrigger", ::apache::thrift::protocol::T_STRUCT, 200);
    xfer += this->useUltSkillTrigger.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.useTag) {
    xfer += oprot->writeFieldBegin("useTag", ::apache::thrift::protocol::T_STRUCT, 210);
    xfer += this->useTag.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncData &a, SyncData &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.syncType, b.syncType);
  swap(a.unitStatus, b.unitStatus);
  swap(a.move, b.move);
  swap(a.moveStop, b.moveStop);
  swap(a.userSkill, b.userSkill);
  swap(a.killDead, b.killDead);
  swap(a.bullet, b.bullet);
  swap(a.line, b.line);
  swap(a.cage, b.cage);
  swap(a.revive, b.revive);
  swap(a.getItem, b.getItem);
  swap(a.addBuff, b.addBuff);
  swap(a.delBuff, b.delBuff);
  swap(a.triggerMagic, b.triggerMagic);
  swap(a.dropSkill, b.dropSkill);
  swap(a.useUltSkillStart, b.useUltSkillStart);
  swap(a.useUltSkillSuccess, b.useUltSkillSuccess);
  swap(a.useUltSkillFailed, b.useUltSkillFailed);
  swap(a.useUltSkillCancel, b.useUltSkillCancel);
  swap(a.useUltSkillTrigger, b.useUltSkillTrigger);
  swap(a.useTag, b.useTag);
  swap(a.__isset, b.__isset);
}

SyncData::SyncData(const SyncData& other115) {
  uid = other115.uid;
  syncType = other115.syncType;
  unitStatus = other115.unitStatus;
  move = other115.move;
  moveStop = other115.moveStop;
  userSkill = other115.userSkill;
  killDead = other115.killDead;
  bullet = other115.bullet;
  line = other115.line;
  cage = other115.cage;
  revive = other115.revive;
  getItem = other115.getItem;
  addBuff = other115.addBuff;
  delBuff = other115.delBuff;
  triggerMagic = other115.triggerMagic;
  dropSkill = other115.dropSkill;
  useUltSkillStart = other115.useUltSkillStart;
  useUltSkillSuccess = other115.useUltSkillSuccess;
  useUltSkillFailed = other115.useUltSkillFailed;
  useUltSkillCancel = other115.useUltSkillCancel;
  useUltSkillTrigger = other115.useUltSkillTrigger;
  useTag = other115.useTag;
  __isset = other115.__isset;
}
SyncData& SyncData::operator=(const SyncData& other116) {
  uid = other116.uid;
  syncType = other116.syncType;
  unitStatus = other116.unitStatus;
  move = other116.move;
  moveStop = other116.moveStop;
  userSkill = other116.userSkill;
  killDead = other116.killDead;
  bullet = other116.bullet;
  line = other116.line;
  cage = other116.cage;
  revive = other116.revive;
  getItem = other116.getItem;
  addBuff = other116.addBuff;
  delBuff = other116.delBuff;
  triggerMagic = other116.triggerMagic;
  dropSkill = other116.dropSkill;
  useUltSkillStart = other116.useUltSkillStart;
  useUltSkillSuccess = other116.useUltSkillSuccess;
  useUltSkillFailed = other116.useUltSkillFailed;
  useUltSkillCancel = other116.useUltSkillCancel;
  useUltSkillTrigger = other116.useUltSkillTrigger;
  useTag = other116.useTag;
  __isset = other116.__isset;
  return *this;
}
void SyncData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SyncData(";
  out << "uid=" << to_string(uid);
  out << ", " << "syncType=" << to_string(syncType);
  out << ", " << "unitStatus="; (__isset.unitStatus ? (out << to_string(unitStatus)) : (out << "<null>"));
  out << ", " << "move="; (__isset.move ? (out << to_string(move)) : (out << "<null>"));
  out << ", " << "moveStop="; (__isset.moveStop ? (out << to_string(moveStop)) : (out << "<null>"));
  out << ", " << "userSkill="; (__isset.userSkill ? (out << to_string(userSkill)) : (out << "<null>"));
  out << ", " << "killDead="; (__isset.killDead ? (out << to_string(killDead)) : (out << "<null>"));
  out << ", " << "bullet="; (__isset.bullet ? (out << to_string(bullet)) : (out << "<null>"));
  out << ", " << "line="; (__isset.line ? (out << to_string(line)) : (out << "<null>"));
  out << ", " << "cage="; (__isset.cage ? (out << to_string(cage)) : (out << "<null>"));
  out << ", " << "revive="; (__isset.revive ? (out << to_string(revive)) : (out << "<null>"));
  out << ", " << "getItem="; (__isset.getItem ? (out << to_string(getItem)) : (out << "<null>"));
  out << ", " << "addBuff="; (__isset.addBuff ? (out << to_string(addBuff)) : (out << "<null>"));
  out << ", " << "delBuff="; (__isset.delBuff ? (out << to_string(delBuff)) : (out << "<null>"));
  out << ", " << "triggerMagic="; (__isset.triggerMagic ? (out << to_string(triggerMagic)) : (out << "<null>"));
  out << ", " << "dropSkill="; (__isset.dropSkill ? (out << to_string(dropSkill)) : (out << "<null>"));
  out << ", " << "useUltSkillStart="; (__isset.useUltSkillStart ? (out << to_string(useUltSkillStart)) : (out << "<null>"));
  out << ", " << "useUltSkillSuccess="; (__isset.useUltSkillSuccess ? (out << to_string(useUltSkillSuccess)) : (out << "<null>"));
  out << ", " << "useUltSkillFailed="; (__isset.useUltSkillFailed ? (out << to_string(useUltSkillFailed)) : (out << "<null>"));
  out << ", " << "useUltSkillCancel="; (__isset.useUltSkillCancel ? (out << to_string(useUltSkillCancel)) : (out << "<null>"));
  out << ", " << "useUltSkillTrigger="; (__isset.useUltSkillTrigger ? (out << to_string(useUltSkillTrigger)) : (out << "<null>"));
  out << ", " << "useTag="; (__isset.useTag ? (out << to_string(useTag)) : (out << "<null>"));
  out << ")";
}


PlayerData::~PlayerData() throw() {
}


void PlayerData::__set_userId(const int32_t val) {
  this->userId = val;
}

void PlayerData::__set_nickname(const std::string& val) {
  this->nickname = val;
}

void PlayerData::__set_faction(const int32_t val) {
  this->faction = val;
}

void PlayerData::__set_classType(const ClassType::type val) {
  this->classType = val;
}

void PlayerData::__set_shipId(const int32_t val) {
  this->shipId = val;
}

void PlayerData::__set_position(const int32_t val) {
  this->position = val;
}

void PlayerData::__set_playerId(const int32_t val) {
  this->playerId = val;
}

void PlayerData::__set_shipLevel(const int32_t val) {
  this->shipLevel = val;
}

void PlayerData::__set_skillSlotCount(const int32_t val) {
  this->skillSlotCount = val;
}

void PlayerData::__set_uniqueSkills(const std::vector<int32_t> & val) {
  this->uniqueSkills = val;
}

void PlayerData::__set_bulletCount(const int32_t val) {
  this->bulletCount = val;
}

uint32_t PlayerData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->faction);
          this->__isset.faction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast117;
          xfer += iprot->readI32(ecast117);
          this->classType = (ClassType::type)ecast117;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shipId);
          this->__isset.shipId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->playerId);
          this->__isset.playerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shipLevel);
          this->__isset.shipLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->skillSlotCount);
          this->__isset.skillSlotCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueSkills.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->uniqueSkills.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += iprot->readI32(this->uniqueSkills[_i122]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.uniqueSkills = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bulletCount);
          this->__isset.bulletCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlayerData");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("faction", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->faction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shipId", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->shipId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->position);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerId", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->playerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shipLevel", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->shipLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillSlotCount", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->skillSlotCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uniqueSkills", ::apache::thrift::protocol::T_LIST, 100);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->uniqueSkills.size()));
    std::vector<int32_t> ::const_iterator _iter123;
    for (_iter123 = this->uniqueSkills.begin(); _iter123 != this->uniqueSkills.end(); ++_iter123)
    {
      xfer += oprot->writeI32((*_iter123));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulletCount", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->bulletCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerData &a, PlayerData &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.nickname, b.nickname);
  swap(a.faction, b.faction);
  swap(a.classType, b.classType);
  swap(a.shipId, b.shipId);
  swap(a.position, b.position);
  swap(a.playerId, b.playerId);
  swap(a.shipLevel, b.shipLevel);
  swap(a.skillSlotCount, b.skillSlotCount);
  swap(a.uniqueSkills, b.uniqueSkills);
  swap(a.bulletCount, b.bulletCount);
  swap(a.__isset, b.__isset);
}

PlayerData::PlayerData(const PlayerData& other124) {
  userId = other124.userId;
  nickname = other124.nickname;
  faction = other124.faction;
  classType = other124.classType;
  shipId = other124.shipId;
  position = other124.position;
  playerId = other124.playerId;
  shipLevel = other124.shipLevel;
  skillSlotCount = other124.skillSlotCount;
  uniqueSkills = other124.uniqueSkills;
  bulletCount = other124.bulletCount;
  __isset = other124.__isset;
}
PlayerData& PlayerData::operator=(const PlayerData& other125) {
  userId = other125.userId;
  nickname = other125.nickname;
  faction = other125.faction;
  classType = other125.classType;
  shipId = other125.shipId;
  position = other125.position;
  playerId = other125.playerId;
  shipLevel = other125.shipLevel;
  skillSlotCount = other125.skillSlotCount;
  uniqueSkills = other125.uniqueSkills;
  bulletCount = other125.bulletCount;
  __isset = other125.__isset;
  return *this;
}
void PlayerData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlayerData(";
  out << "userId=" << to_string(userId);
  out << ", " << "nickname=" << to_string(nickname);
  out << ", " << "faction=" << to_string(faction);
  out << ", " << "classType=" << to_string(classType);
  out << ", " << "shipId=" << to_string(shipId);
  out << ", " << "position=" << to_string(position);
  out << ", " << "playerId=" << to_string(playerId);
  out << ", " << "shipLevel=" << to_string(shipLevel);
  out << ", " << "skillSlotCount=" << to_string(skillSlotCount);
  out << ", " << "uniqueSkills=" << to_string(uniqueSkills);
  out << ", " << "bulletCount=" << to_string(bulletCount);
  out << ")";
}


RoleData::~RoleData() throw() {
}


void RoleData::__set_shipId(const int32_t val) {
  this->shipId = val;
}

void RoleData::__set_shipConfigId(const int32_t val) {
  this->shipConfigId = val;
}

uint32_t RoleData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shipId);
          this->__isset.shipId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shipConfigId);
          this->__isset.shipConfigId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RoleData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RoleData");

  xfer += oprot->writeFieldBegin("shipId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->shipId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shipConfigId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->shipConfigId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RoleData &a, RoleData &b) {
  using ::std::swap;
  swap(a.shipId, b.shipId);
  swap(a.shipConfigId, b.shipConfigId);
  swap(a.__isset, b.__isset);
}

RoleData::RoleData(const RoleData& other126) {
  shipId = other126.shipId;
  shipConfigId = other126.shipConfigId;
  __isset = other126.__isset;
}
RoleData& RoleData::operator=(const RoleData& other127) {
  shipId = other127.shipId;
  shipConfigId = other127.shipConfigId;
  __isset = other127.__isset;
  return *this;
}
void RoleData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RoleData(";
  out << "shipId=" << to_string(shipId);
  out << ", " << "shipConfigId=" << to_string(shipConfigId);
  out << ")";
}


UserData::~UserData() throw() {
}


void UserData::__set_userId(const int32_t val) {
  this->userId = val;
}

void UserData::__set_userAccount(const std::string& val) {
  this->userAccount = val;
}

void UserData::__set_userPassword(const std::string& val) {
  this->userPassword = val;
}

void UserData::__set_roleData(const RoleData& val) {
  this->roleData = val;
}

uint32_t UserData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userAccount);
          this->__isset.userAccount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userPassword);
          this->__isset.userPassword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->roleData.read(iprot);
          this->__isset.roleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserData");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userAccount", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->userAccount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userPassword", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->userPassword);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roleData", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->roleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserData &a, UserData &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.userAccount, b.userAccount);
  swap(a.userPassword, b.userPassword);
  swap(a.roleData, b.roleData);
  swap(a.__isset, b.__isset);
}

UserData::UserData(const UserData& other128) {
  userId = other128.userId;
  userAccount = other128.userAccount;
  userPassword = other128.userPassword;
  roleData = other128.roleData;
  __isset = other128.__isset;
}
UserData& UserData::operator=(const UserData& other129) {
  userId = other129.userId;
  userAccount = other129.userAccount;
  userPassword = other129.userPassword;
  roleData = other129.roleData;
  __isset = other129.__isset;
  return *this;
}
void UserData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserData(";
  out << "userId=" << to_string(userId);
  out << ", " << "userAccount=" << to_string(userAccount);
  out << ", " << "userPassword=" << to_string(userPassword);
  out << ", " << "roleData=" << to_string(roleData);
  out << ")";
}


AccountData::~AccountData() throw() {
}


void AccountData::__set_id(const int32_t val) {
  this->id = val;
}

void AccountData::__set_sessionKey(const std::string& val) {
  this->sessionKey = val;
}

void AccountData::__set_channel(const std::string& val) {
  this->channel = val;
}

void AccountData::__set_openId(const std::string& val) {
  this->openId = val;
}

void AccountData::__set_lastLoginTime(const int64_t val) {
  this->lastLoginTime = val;
}

uint32_t AccountData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionKey);
          this->__isset.sessionKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channel);
          this->__isset.channel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->openId);
          this->__isset.openId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastLoginTime);
          this->__isset.lastLoginTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccountData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AccountData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionKey", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->sessionKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channel", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->channel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("openId", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->openId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastLoginTime", ::apache::thrift::protocol::T_I64, 50);
  xfer += oprot->writeI64(this->lastLoginTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccountData &a, AccountData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.sessionKey, b.sessionKey);
  swap(a.channel, b.channel);
  swap(a.openId, b.openId);
  swap(a.lastLoginTime, b.lastLoginTime);
  swap(a.__isset, b.__isset);
}

AccountData::AccountData(const AccountData& other130) {
  id = other130.id;
  sessionKey = other130.sessionKey;
  channel = other130.channel;
  openId = other130.openId;
  lastLoginTime = other130.lastLoginTime;
  __isset = other130.__isset;
}
AccountData& AccountData::operator=(const AccountData& other131) {
  id = other131.id;
  sessionKey = other131.sessionKey;
  channel = other131.channel;
  openId = other131.openId;
  lastLoginTime = other131.lastLoginTime;
  __isset = other131.__isset;
  return *this;
}
void AccountData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AccountData(";
  out << "id=" << to_string(id);
  out << ", " << "sessionKey=" << to_string(sessionKey);
  out << ", " << "channel=" << to_string(channel);
  out << ", " << "openId=" << to_string(openId);
  out << ", " << "lastLoginTime=" << to_string(lastLoginTime);
  out << ")";
}


InstantiateData::~InstantiateData() throw() {
}


void InstantiateData::__set_uid(const int32_t val) {
  this->uid = val;
}

void InstantiateData::__set_creator(const int32_t val) {
  this->creator = val;
}

void InstantiateData::__set_type(const ObjType::type val) {
  this->type = val;
}

void InstantiateData::__set_pos(const TVector3& val) {
  this->pos = val;
}

void InstantiateData::__set_rot(const TRotation& val) {
  this->rot = val;
}

void InstantiateData::__set_argvs(const std::vector<int32_t> & val) {
  this->argvs = val;
}

void InstantiateData::__set_casterPos(const TVector3& val) {
  this->casterPos = val;
}

uint32_t InstantiateData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->creator);
          this->__isset.creator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast132;
          xfer += iprot->readI32(ecast132);
          this->type = (ObjType::type)ecast132;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rot.read(iprot);
          this->__isset.rot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->argvs.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->argvs.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += iprot->readI32(this->argvs[_i137]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.argvs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->casterPos.read(iprot);
          this->__isset.casterPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InstantiateData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InstantiateData");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("creator", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->creator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rot", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->rot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("argvs", ::apache::thrift::protocol::T_LIST, 50);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->argvs.size()));
    std::vector<int32_t> ::const_iterator _iter138;
    for (_iter138 = this->argvs.begin(); _iter138 != this->argvs.end(); ++_iter138)
    {
      xfer += oprot->writeI32((*_iter138));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("casterPos", ::apache::thrift::protocol::T_STRUCT, 60);
  xfer += this->casterPos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InstantiateData &a, InstantiateData &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.creator, b.creator);
  swap(a.type, b.type);
  swap(a.pos, b.pos);
  swap(a.rot, b.rot);
  swap(a.argvs, b.argvs);
  swap(a.casterPos, b.casterPos);
  swap(a.__isset, b.__isset);
}

InstantiateData::InstantiateData(const InstantiateData& other139) {
  uid = other139.uid;
  creator = other139.creator;
  type = other139.type;
  pos = other139.pos;
  rot = other139.rot;
  argvs = other139.argvs;
  casterPos = other139.casterPos;
  __isset = other139.__isset;
}
InstantiateData& InstantiateData::operator=(const InstantiateData& other140) {
  uid = other140.uid;
  creator = other140.creator;
  type = other140.type;
  pos = other140.pos;
  rot = other140.rot;
  argvs = other140.argvs;
  casterPos = other140.casterPos;
  __isset = other140.__isset;
  return *this;
}
void InstantiateData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InstantiateData(";
  out << "uid=" << to_string(uid);
  out << ", " << "creator=" << to_string(creator);
  out << ", " << "type=" << to_string(type);
  out << ", " << "pos=" << to_string(pos);
  out << ", " << "rot=" << to_string(rot);
  out << ", " << "argvs=" << to_string(argvs);
  out << ", " << "casterPos=" << to_string(casterPos);
  out << ")";
}


RoomData::~RoomData() throw() {
}


void RoomData::__set_id(const int32_t val) {
  this->id = val;
}

void RoomData::__set_name(const std::string& val) {
  this->name = val;
}

void RoomData::__set_pattern(const int32_t val) {
  this->pattern = val;
}

void RoomData::__set_playerCount(const int32_t val) {
  this->playerCount = val;
}

void RoomData::__set_playerMaxCount(const int32_t val) {
  this->playerMaxCount = val;
}

uint32_t RoomData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->playerCount);
          this->__isset.playerCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->playerMaxCount);
          this->__isset.playerMaxCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RoomData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RoomData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->pattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerCount", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->playerCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerMaxCount", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->playerMaxCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RoomData &a, RoomData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.pattern, b.pattern);
  swap(a.playerCount, b.playerCount);
  swap(a.playerMaxCount, b.playerMaxCount);
  swap(a.__isset, b.__isset);
}

RoomData::RoomData(const RoomData& other141) {
  id = other141.id;
  name = other141.name;
  pattern = other141.pattern;
  playerCount = other141.playerCount;
  playerMaxCount = other141.playerMaxCount;
  __isset = other141.__isset;
}
RoomData& RoomData::operator=(const RoomData& other142) {
  id = other142.id;
  name = other142.name;
  pattern = other142.pattern;
  playerCount = other142.playerCount;
  playerMaxCount = other142.playerMaxCount;
  __isset = other142.__isset;
  return *this;
}
void RoomData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RoomData(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "pattern=" << to_string(pattern);
  out << ", " << "playerCount=" << to_string(playerCount);
  out << ", " << "playerMaxCount=" << to_string(playerMaxCount);
  out << ")";
}


