/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "message_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kMessageIdValues[] = {
  MessageId::C_LoginGame,
  MessageId::S_LoginGame,
  MessageId::SC_Connect,
  MessageId::SC_DisConnect,
  MessageId::CS_CreateRoom,
  MessageId::SC_CreateRoom,
  MessageId::CS_JoinRoom,
  MessageId::SC_JoinRoom,
  MessageId::SC_RoomInfo,
  MessageId::CS_SwitchSeat,
  MessageId::SC_SwitchSeat,
  MessageId::CS_ExitRoom,
  MessageId::SC_ExitRoom,
  MessageId::SC_RoomDestroyed,
  MessageId::CS_StartBattle,
  MessageId::SC_BeginLoadResource,
  MessageId::CS_EndLoadResource,
  MessageId::SC_StartBattle,
  MessageId::SC_BattleResult,
  MessageId::CS_EndBattle,
  MessageId::SC_EndBattle,
  MessageId::SC_ServerInfo,
  MessageId::CS_RequestRoomList,
  MessageId::SC_RequestRoomList,
  MessageId::CS_SwitchShip,
  MessageId::SC_SwitchShip,
  MessageId::CS_SwitchSlot,
  MessageId::SC_SwitchSlot,
  MessageId::CS_PlayerInput,
  MessageId::SC_PlayerInput,
  MessageId::CS_SyncCommandMsg,
  MessageId::SC_SyncCommandMsg,
  MessageId::SC_Instantiate,
  MessageId::SC_FactionMsg,
  MessageId::CS_Ping,
  MessageId::SC_Ping
};
const char* _kMessageIdNames[] = {
  "C_LoginGame",
  "S_LoginGame",
  "SC_Connect",
  "SC_DisConnect",
  "CS_CreateRoom",
  "SC_CreateRoom",
  "CS_JoinRoom",
  "SC_JoinRoom",
  "SC_RoomInfo",
  "CS_SwitchSeat",
  "SC_SwitchSeat",
  "CS_ExitRoom",
  "SC_ExitRoom",
  "SC_RoomDestroyed",
  "CS_StartBattle",
  "SC_BeginLoadResource",
  "CS_EndLoadResource",
  "SC_StartBattle",
  "SC_BattleResult",
  "CS_EndBattle",
  "SC_EndBattle",
  "SC_ServerInfo",
  "CS_RequestRoomList",
  "SC_RequestRoomList",
  "CS_SwitchShip",
  "SC_SwitchShip",
  "CS_SwitchSlot",
  "SC_SwitchSlot",
  "CS_PlayerInput",
  "SC_PlayerInput",
  "CS_SyncCommandMsg",
  "SC_SyncCommandMsg",
  "SC_Instantiate",
  "SC_FactionMsg",
  "CS_Ping",
  "SC_Ping"
};
const std::map<int, const char*> _MessageId_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(36, _kMessageIdValues, _kMessageIdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


CLoginGame::~CLoginGame() throw() {
}


void CLoginGame::__set_accountId(const int32_t val) {
  this->accountId = val;
}

void CLoginGame::__set_sessionKey(const std::string& val) {
  this->sessionKey = val;
}

uint32_t CLoginGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->accountId);
          this->__isset.accountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionKey);
          this->__isset.sessionKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CLoginGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CLoginGame");

  xfer += oprot->writeFieldBegin("accountId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->accountId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionKey", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->sessionKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CLoginGame &a, CLoginGame &b) {
  using ::std::swap;
  swap(a.accountId, b.accountId);
  swap(a.sessionKey, b.sessionKey);
  swap(a.__isset, b.__isset);
}

CLoginGame::CLoginGame(const CLoginGame& other0) {
  accountId = other0.accountId;
  sessionKey = other0.sessionKey;
  __isset = other0.__isset;
}
CLoginGame& CLoginGame::operator=(const CLoginGame& other1) {
  accountId = other1.accountId;
  sessionKey = other1.sessionKey;
  __isset = other1.__isset;
  return *this;
}
void CLoginGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CLoginGame(";
  out << "accountId=" << to_string(accountId);
  out << ", " << "sessionKey=" << to_string(sessionKey);
  out << ")";
}


SLoginGame::~SLoginGame() throw() {
}


void SLoginGame::__set_state(const bool val) {
  this->state = val;
}

void SLoginGame::__set_error(const std::string& val) {
  this->error = val;
__isset.error = true;
}

void SLoginGame::__set_account(const  ::AccountData& val) {
  this->account = val;
__isset.account = true;
}

uint32_t SLoginGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->account.read(iprot);
          this->__isset.account = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SLoginGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SLoginGame");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.account) {
    xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRUCT, 30);
    xfer += this->account.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SLoginGame &a, SLoginGame &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.error, b.error);
  swap(a.account, b.account);
  swap(a.__isset, b.__isset);
}

SLoginGame::SLoginGame(const SLoginGame& other2) {
  state = other2.state;
  error = other2.error;
  account = other2.account;
  __isset = other2.__isset;
}
SLoginGame& SLoginGame::operator=(const SLoginGame& other3) {
  state = other3.state;
  error = other3.error;
  account = other3.account;
  __isset = other3.__isset;
  return *this;
}
void SLoginGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SLoginGame(";
  out << "state=" << to_string(state);
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "account="; (__isset.account ? (out << to_string(account)) : (out << "<null>"));
  out << ")";
}


CSCreateRoom::~CSCreateRoom() throw() {
}


void CSCreateRoom::__set_playerCount(const int32_t val) {
  this->playerCount = val;
}

void CSCreateRoom::__set_matchPattern(const int32_t val) {
  this->matchPattern = val;
}

uint32_t CSCreateRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->playerCount);
          this->__isset.playerCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->matchPattern);
          this->__isset.matchPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSCreateRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSCreateRoom");

  xfer += oprot->writeFieldBegin("playerCount", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->playerCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matchPattern", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->matchPattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSCreateRoom &a, CSCreateRoom &b) {
  using ::std::swap;
  swap(a.playerCount, b.playerCount);
  swap(a.matchPattern, b.matchPattern);
  swap(a.__isset, b.__isset);
}

CSCreateRoom::CSCreateRoom(const CSCreateRoom& other4) {
  playerCount = other4.playerCount;
  matchPattern = other4.matchPattern;
  __isset = other4.__isset;
}
CSCreateRoom& CSCreateRoom::operator=(const CSCreateRoom& other5) {
  playerCount = other5.playerCount;
  matchPattern = other5.matchPattern;
  __isset = other5.__isset;
  return *this;
}
void CSCreateRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSCreateRoom(";
  out << "playerCount=" << to_string(playerCount);
  out << ", " << "matchPattern=" << to_string(matchPattern);
  out << ")";
}


SCCreateRoom::~SCCreateRoom() throw() {
}


void SCCreateRoom::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCCreateRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCCreateRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCCreateRoom");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCCreateRoom &a, SCCreateRoom &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCCreateRoom::SCCreateRoom(const SCCreateRoom& other6) {
  result = other6.result;
  __isset = other6.__isset;
}
SCCreateRoom& SCCreateRoom::operator=(const SCCreateRoom& other7) {
  result = other7.result;
  __isset = other7.__isset;
  return *this;
}
void SCCreateRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCCreateRoom(";
  out << "result=" << to_string(result);
  out << ")";
}


CSRequestRoomList::~CSRequestRoomList() throw() {
}


void CSRequestRoomList::__set_pattern(const int32_t val) {
  this->pattern = val;
}

void CSRequestRoomList::__set_pageNum(const int32_t val) {
  this->pageNum = val;
}

void CSRequestRoomList::__set_countPerPage(const int32_t val) {
  this->countPerPage = val;
}

uint32_t CSRequestRoomList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pageNum);
          this->__isset.pageNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->countPerPage);
          this->__isset.countPerPage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRequestRoomList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRequestRoomList");

  xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->pattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pageNum", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->pageNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("countPerPage", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->countPerPage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRequestRoomList &a, CSRequestRoomList &b) {
  using ::std::swap;
  swap(a.pattern, b.pattern);
  swap(a.pageNum, b.pageNum);
  swap(a.countPerPage, b.countPerPage);
  swap(a.__isset, b.__isset);
}

CSRequestRoomList::CSRequestRoomList(const CSRequestRoomList& other8) {
  pattern = other8.pattern;
  pageNum = other8.pageNum;
  countPerPage = other8.countPerPage;
  __isset = other8.__isset;
}
CSRequestRoomList& CSRequestRoomList::operator=(const CSRequestRoomList& other9) {
  pattern = other9.pattern;
  pageNum = other9.pageNum;
  countPerPage = other9.countPerPage;
  __isset = other9.__isset;
  return *this;
}
void CSRequestRoomList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRequestRoomList(";
  out << "pattern=" << to_string(pattern);
  out << ", " << "pageNum=" << to_string(pageNum);
  out << ", " << "countPerPage=" << to_string(countPerPage);
  out << ")";
}


SCRequestRoomList::~SCRequestRoomList() throw() {
}


void SCRequestRoomList::__set_result(const int32_t val) {
  this->result = val;
}

void SCRequestRoomList::__set_roomCount(const int32_t val) {
  this->roomCount = val;
}

void SCRequestRoomList::__set_roomList(const std::vector< ::RoomData> & val) {
  this->roomList = val;
}

uint32_t SCRequestRoomList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomCount);
          this->__isset.roomCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->roomList.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->roomList.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->roomList[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.roomList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRequestRoomList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRequestRoomList");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roomCount", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->roomCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roomList", ::apache::thrift::protocol::T_LIST, 30);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->roomList.size()));
    std::vector< ::RoomData> ::const_iterator _iter15;
    for (_iter15 = this->roomList.begin(); _iter15 != this->roomList.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRequestRoomList &a, SCRequestRoomList &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.roomCount, b.roomCount);
  swap(a.roomList, b.roomList);
  swap(a.__isset, b.__isset);
}

SCRequestRoomList::SCRequestRoomList(const SCRequestRoomList& other16) {
  result = other16.result;
  roomCount = other16.roomCount;
  roomList = other16.roomList;
  __isset = other16.__isset;
}
SCRequestRoomList& SCRequestRoomList::operator=(const SCRequestRoomList& other17) {
  result = other17.result;
  roomCount = other17.roomCount;
  roomList = other17.roomList;
  __isset = other17.__isset;
  return *this;
}
void SCRequestRoomList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRequestRoomList(";
  out << "result=" << to_string(result);
  out << ", " << "roomCount=" << to_string(roomCount);
  out << ", " << "roomList=" << to_string(roomList);
  out << ")";
}


CSJoinRoom::~CSJoinRoom() throw() {
}


void CSJoinRoom::__set_roomId(const int32_t val) {
  this->roomId = val;
}

uint32_t CSJoinRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomId);
          this->__isset.roomId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSJoinRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSJoinRoom");

  xfer += oprot->writeFieldBegin("roomId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->roomId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSJoinRoom &a, CSJoinRoom &b) {
  using ::std::swap;
  swap(a.roomId, b.roomId);
  swap(a.__isset, b.__isset);
}

CSJoinRoom::CSJoinRoom(const CSJoinRoom& other18) {
  roomId = other18.roomId;
  __isset = other18.__isset;
}
CSJoinRoom& CSJoinRoom::operator=(const CSJoinRoom& other19) {
  roomId = other19.roomId;
  __isset = other19.__isset;
  return *this;
}
void CSJoinRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSJoinRoom(";
  out << "roomId=" << to_string(roomId);
  out << ")";
}


SCJoinRoom::~SCJoinRoom() throw() {
}


void SCJoinRoom::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCJoinRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCJoinRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCJoinRoom");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCJoinRoom &a, SCJoinRoom &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCJoinRoom::SCJoinRoom(const SCJoinRoom& other20) {
  result = other20.result;
  __isset = other20.__isset;
}
SCJoinRoom& SCJoinRoom::operator=(const SCJoinRoom& other21) {
  result = other21.result;
  __isset = other21.__isset;
  return *this;
}
void SCJoinRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCJoinRoom(";
  out << "result=" << to_string(result);
  out << ")";
}


SCRoomInfo::~SCRoomInfo() throw() {
}


void SCRoomInfo::__set_roomId(const int32_t val) {
  this->roomId = val;
}

void SCRoomInfo::__set_masterId(const int32_t val) {
  this->masterId = val;
}

void SCRoomInfo::__set_playerList(const std::vector< ::PlayerData> & val) {
  this->playerList = val;
}

void SCRoomInfo::__set_roomSize(const int32_t val) {
  this->roomSize = val;
}

void SCRoomInfo::__set_mathPattern(const int32_t val) {
  this->mathPattern = val;
}

uint32_t SCRoomInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomId);
          this->__isset.roomId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->masterId);
          this->__isset.masterId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->playerList.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->playerList.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->playerList[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.playerList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomSize);
          this->__isset.roomSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mathPattern);
          this->__isset.mathPattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRoomInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRoomInfo");

  xfer += oprot->writeFieldBegin("roomId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->roomId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("masterId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->masterId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerList", ::apache::thrift::protocol::T_LIST, 30);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->playerList.size()));
    std::vector< ::PlayerData> ::const_iterator _iter27;
    for (_iter27 = this->playerList.begin(); _iter27 != this->playerList.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roomSize", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->roomSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mathPattern", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->mathPattern);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRoomInfo &a, SCRoomInfo &b) {
  using ::std::swap;
  swap(a.roomId, b.roomId);
  swap(a.masterId, b.masterId);
  swap(a.playerList, b.playerList);
  swap(a.roomSize, b.roomSize);
  swap(a.mathPattern, b.mathPattern);
  swap(a.__isset, b.__isset);
}

SCRoomInfo::SCRoomInfo(const SCRoomInfo& other28) {
  roomId = other28.roomId;
  masterId = other28.masterId;
  playerList = other28.playerList;
  roomSize = other28.roomSize;
  mathPattern = other28.mathPattern;
  __isset = other28.__isset;
}
SCRoomInfo& SCRoomInfo::operator=(const SCRoomInfo& other29) {
  roomId = other29.roomId;
  masterId = other29.masterId;
  playerList = other29.playerList;
  roomSize = other29.roomSize;
  mathPattern = other29.mathPattern;
  __isset = other29.__isset;
  return *this;
}
void SCRoomInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRoomInfo(";
  out << "roomId=" << to_string(roomId);
  out << ", " << "masterId=" << to_string(masterId);
  out << ", " << "playerList=" << to_string(playerList);
  out << ", " << "roomSize=" << to_string(roomSize);
  out << ", " << "mathPattern=" << to_string(mathPattern);
  out << ")";
}


CSSwitchSeat::~CSSwitchSeat() throw() {
}


void CSSwitchSeat::__set_playerId(const int32_t val) {
  this->playerId = val;
}

void CSSwitchSeat::__set_targetPos(const int32_t val) {
  this->targetPos = val;
}

uint32_t CSSwitchSeat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->playerId);
          this->__isset.playerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetPos);
          this->__isset.targetPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSSwitchSeat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSSwitchSeat");

  xfer += oprot->writeFieldBegin("playerId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->playerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetPos", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->targetPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSSwitchSeat &a, CSSwitchSeat &b) {
  using ::std::swap;
  swap(a.playerId, b.playerId);
  swap(a.targetPos, b.targetPos);
  swap(a.__isset, b.__isset);
}

CSSwitchSeat::CSSwitchSeat(const CSSwitchSeat& other30) {
  playerId = other30.playerId;
  targetPos = other30.targetPos;
  __isset = other30.__isset;
}
CSSwitchSeat& CSSwitchSeat::operator=(const CSSwitchSeat& other31) {
  playerId = other31.playerId;
  targetPos = other31.targetPos;
  __isset = other31.__isset;
  return *this;
}
void CSSwitchSeat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSSwitchSeat(";
  out << "playerId=" << to_string(playerId);
  out << ", " << "targetPos=" << to_string(targetPos);
  out << ")";
}


SCSwitchSeat::~SCSwitchSeat() throw() {
}


void SCSwitchSeat::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCSwitchSeat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCSwitchSeat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCSwitchSeat");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCSwitchSeat &a, SCSwitchSeat &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCSwitchSeat::SCSwitchSeat(const SCSwitchSeat& other32) {
  result = other32.result;
  __isset = other32.__isset;
}
SCSwitchSeat& SCSwitchSeat::operator=(const SCSwitchSeat& other33) {
  result = other33.result;
  __isset = other33.__isset;
  return *this;
}
void SCSwitchSeat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCSwitchSeat(";
  out << "result=" << to_string(result);
  out << ")";
}


CSSwitchShip::~CSSwitchShip() throw() {
}


void CSSwitchShip::__set_shipId(const int32_t val) {
  this->shipId = val;
}

uint32_t CSSwitchShip::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shipId);
          this->__isset.shipId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSSwitchShip::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSSwitchShip");

  xfer += oprot->writeFieldBegin("shipId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->shipId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSSwitchShip &a, CSSwitchShip &b) {
  using ::std::swap;
  swap(a.shipId, b.shipId);
  swap(a.__isset, b.__isset);
}

CSSwitchShip::CSSwitchShip(const CSSwitchShip& other34) {
  shipId = other34.shipId;
  __isset = other34.__isset;
}
CSSwitchShip& CSSwitchShip::operator=(const CSSwitchShip& other35) {
  shipId = other35.shipId;
  __isset = other35.__isset;
  return *this;
}
void CSSwitchShip::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSSwitchShip(";
  out << "shipId=" << to_string(shipId);
  out << ")";
}


SCSwitchShip::~SCSwitchShip() throw() {
}


void SCSwitchShip::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCSwitchShip::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCSwitchShip::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCSwitchShip");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCSwitchShip &a, SCSwitchShip &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCSwitchShip::SCSwitchShip(const SCSwitchShip& other36) {
  result = other36.result;
  __isset = other36.__isset;
}
SCSwitchShip& SCSwitchShip::operator=(const SCSwitchShip& other37) {
  result = other37.result;
  __isset = other37.__isset;
  return *this;
}
void SCSwitchShip::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCSwitchShip(";
  out << "result=" << to_string(result);
  out << ")";
}


CSSwitchSlot::~CSSwitchSlot() throw() {
}


void CSSwitchSlot::__set_slotCount(const int32_t val) {
  this->slotCount = val;
}

void CSSwitchSlot::__set_uniqueSkills(const std::vector<int32_t> & val) {
  this->uniqueSkills = val;
}

void CSSwitchSlot::__set_bulletCount(const int32_t val) {
  this->bulletCount = val;
}

uint32_t CSSwitchSlot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slotCount);
          this->__isset.slotCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->uniqueSkills.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->uniqueSkills.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readI32(this->uniqueSkills[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.uniqueSkills = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bulletCount);
          this->__isset.bulletCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSSwitchSlot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSSwitchSlot");

  xfer += oprot->writeFieldBegin("slotCount", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->slotCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uniqueSkills", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->uniqueSkills.size()));
    std::vector<int32_t> ::const_iterator _iter43;
    for (_iter43 = this->uniqueSkills.begin(); _iter43 != this->uniqueSkills.end(); ++_iter43)
    {
      xfer += oprot->writeI32((*_iter43));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bulletCount", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->bulletCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSSwitchSlot &a, CSSwitchSlot &b) {
  using ::std::swap;
  swap(a.slotCount, b.slotCount);
  swap(a.uniqueSkills, b.uniqueSkills);
  swap(a.bulletCount, b.bulletCount);
  swap(a.__isset, b.__isset);
}

CSSwitchSlot::CSSwitchSlot(const CSSwitchSlot& other44) {
  slotCount = other44.slotCount;
  uniqueSkills = other44.uniqueSkills;
  bulletCount = other44.bulletCount;
  __isset = other44.__isset;
}
CSSwitchSlot& CSSwitchSlot::operator=(const CSSwitchSlot& other45) {
  slotCount = other45.slotCount;
  uniqueSkills = other45.uniqueSkills;
  bulletCount = other45.bulletCount;
  __isset = other45.__isset;
  return *this;
}
void CSSwitchSlot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSSwitchSlot(";
  out << "slotCount=" << to_string(slotCount);
  out << ", " << "uniqueSkills=" << to_string(uniqueSkills);
  out << ", " << "bulletCount=" << to_string(bulletCount);
  out << ")";
}


SCSwitchSlot::~SCSwitchSlot() throw() {
}


void SCSwitchSlot::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCSwitchSlot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCSwitchSlot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCSwitchSlot");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCSwitchSlot &a, SCSwitchSlot &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCSwitchSlot::SCSwitchSlot(const SCSwitchSlot& other46) {
  result = other46.result;
  __isset = other46.__isset;
}
SCSwitchSlot& SCSwitchSlot::operator=(const SCSwitchSlot& other47) {
  result = other47.result;
  __isset = other47.__isset;
  return *this;
}
void SCSwitchSlot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCSwitchSlot(";
  out << "result=" << to_string(result);
  out << ")";
}


CSExitRoom::~CSExitRoom() throw() {
}


uint32_t CSExitRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSExitRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSExitRoom");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSExitRoom &a, CSExitRoom &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSExitRoom::CSExitRoom(const CSExitRoom& other48) {
  (void) other48;
}
CSExitRoom& CSExitRoom::operator=(const CSExitRoom& other49) {
  (void) other49;
  return *this;
}
void CSExitRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSExitRoom(";
  out << ")";
}


SCExitRoom::~SCExitRoom() throw() {
}


void SCExitRoom::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCExitRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCExitRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCExitRoom");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCExitRoom &a, SCExitRoom &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCExitRoom::SCExitRoom(const SCExitRoom& other50) {
  result = other50.result;
  __isset = other50.__isset;
}
SCExitRoom& SCExitRoom::operator=(const SCExitRoom& other51) {
  result = other51.result;
  __isset = other51.__isset;
  return *this;
}
void SCExitRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCExitRoom(";
  out << "result=" << to_string(result);
  out << ")";
}


SCRoomDestroyed::~SCRoomDestroyed() throw() {
}


void SCRoomDestroyed::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCRoomDestroyed::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRoomDestroyed::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRoomDestroyed");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRoomDestroyed &a, SCRoomDestroyed &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCRoomDestroyed::SCRoomDestroyed(const SCRoomDestroyed& other52) {
  result = other52.result;
  __isset = other52.__isset;
}
SCRoomDestroyed& SCRoomDestroyed::operator=(const SCRoomDestroyed& other53) {
  result = other53.result;
  __isset = other53.__isset;
  return *this;
}
void SCRoomDestroyed::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRoomDestroyed(";
  out << "result=" << to_string(result);
  out << ")";
}


CSStartBattle::~CSStartBattle() throw() {
}


uint32_t CSStartBattle::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSStartBattle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSStartBattle");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSStartBattle &a, CSStartBattle &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSStartBattle::CSStartBattle(const CSStartBattle& other54) {
  (void) other54;
}
CSStartBattle& CSStartBattle::operator=(const CSStartBattle& other55) {
  (void) other55;
  return *this;
}
void CSStartBattle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSStartBattle(";
  out << ")";
}


SCBeginLoadResource::~SCBeginLoadResource() throw() {
}


void SCBeginLoadResource::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCBeginLoadResource::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCBeginLoadResource::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCBeginLoadResource");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCBeginLoadResource &a, SCBeginLoadResource &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCBeginLoadResource::SCBeginLoadResource(const SCBeginLoadResource& other56) {
  result = other56.result;
  __isset = other56.__isset;
}
SCBeginLoadResource& SCBeginLoadResource::operator=(const SCBeginLoadResource& other57) {
  result = other57.result;
  __isset = other57.__isset;
  return *this;
}
void SCBeginLoadResource::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCBeginLoadResource(";
  out << "result=" << to_string(result);
  out << ")";
}


CSEndLoadResource::~CSEndLoadResource() throw() {
}


uint32_t CSEndLoadResource::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSEndLoadResource::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSEndLoadResource");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSEndLoadResource &a, CSEndLoadResource &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSEndLoadResource::CSEndLoadResource(const CSEndLoadResource& other58) {
  (void) other58;
}
CSEndLoadResource& CSEndLoadResource::operator=(const CSEndLoadResource& other59) {
  (void) other59;
  return *this;
}
void CSEndLoadResource::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSEndLoadResource(";
  out << ")";
}


SCStartBattle::~SCStartBattle() throw() {
}


void SCStartBattle::__set_result(const int32_t val) {
  this->result = val;
}

void SCStartBattle::__set_startTime(const int64_t val) {
  this->startTime = val;
}

uint32_t SCStartBattle::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          this->__isset.startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCStartBattle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCStartBattle");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 20);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCStartBattle &a, SCStartBattle &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.startTime, b.startTime);
  swap(a.__isset, b.__isset);
}

SCStartBattle::SCStartBattle(const SCStartBattle& other60) {
  result = other60.result;
  startTime = other60.startTime;
  __isset = other60.__isset;
}
SCStartBattle& SCStartBattle::operator=(const SCStartBattle& other61) {
  result = other61.result;
  startTime = other61.startTime;
  __isset = other61.__isset;
  return *this;
}
void SCStartBattle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCStartBattle(";
  out << "result=" << to_string(result);
  out << ", " << "startTime=" << to_string(startTime);
  out << ")";
}


SCBattleResult::~SCBattleResult() throw() {
}


void SCBattleResult::__set_result(const int32_t val) {
  this->result = val;
}

void SCBattleResult::__set_fectionScore(const std::map<int32_t, int32_t> & val) {
  this->fectionScore = val;
}

uint32_t SCBattleResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fectionScore.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _ktype63;
            ::apache::thrift::protocol::TType _vtype64;
            xfer += iprot->readMapBegin(_ktype63, _vtype64, _size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              int32_t _key67;
              xfer += iprot->readI32(_key67);
              int32_t& _val68 = this->fectionScore[_key67];
              xfer += iprot->readI32(_val68);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fectionScore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCBattleResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCBattleResult");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fectionScore", ::apache::thrift::protocol::T_MAP, 20);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->fectionScore.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter69;
    for (_iter69 = this->fectionScore.begin(); _iter69 != this->fectionScore.end(); ++_iter69)
    {
      xfer += oprot->writeI32(_iter69->first);
      xfer += oprot->writeI32(_iter69->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCBattleResult &a, SCBattleResult &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.fectionScore, b.fectionScore);
  swap(a.__isset, b.__isset);
}

SCBattleResult::SCBattleResult(const SCBattleResult& other70) {
  result = other70.result;
  fectionScore = other70.fectionScore;
  __isset = other70.__isset;
}
SCBattleResult& SCBattleResult::operator=(const SCBattleResult& other71) {
  result = other71.result;
  fectionScore = other71.fectionScore;
  __isset = other71.__isset;
  return *this;
}
void SCBattleResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCBattleResult(";
  out << "result=" << to_string(result);
  out << ", " << "fectionScore=" << to_string(fectionScore);
  out << ")";
}


CSEndBattle::~CSEndBattle() throw() {
}


uint32_t CSEndBattle::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSEndBattle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSEndBattle");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSEndBattle &a, CSEndBattle &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSEndBattle::CSEndBattle(const CSEndBattle& other72) {
  (void) other72;
}
CSEndBattle& CSEndBattle::operator=(const CSEndBattle& other73) {
  (void) other73;
  return *this;
}
void CSEndBattle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSEndBattle(";
  out << ")";
}


SCEndBattle::~SCEndBattle() throw() {
}


void SCEndBattle::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCEndBattle::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCEndBattle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCEndBattle");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCEndBattle &a, SCEndBattle &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCEndBattle::SCEndBattle(const SCEndBattle& other74) {
  result = other74.result;
  __isset = other74.__isset;
}
SCEndBattle& SCEndBattle::operator=(const SCEndBattle& other75) {
  result = other75.result;
  __isset = other75.__isset;
  return *this;
}
void SCEndBattle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCEndBattle(";
  out << "result=" << to_string(result);
  out << ")";
}


CSPlayerInput::~CSPlayerInput() throw() {
}


void CSPlayerInput::__set_commandList(const std::vector< ::PlayerOperateCommand> & val) {
  this->commandList = val;
}

uint32_t CSPlayerInput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->commandList.clear();
            uint32_t _size76;
            ::apache::thrift::protocol::TType _etype79;
            xfer += iprot->readListBegin(_etype79, _size76);
            this->commandList.resize(_size76);
            uint32_t _i80;
            for (_i80 = 0; _i80 < _size76; ++_i80)
            {
              xfer += this->commandList[_i80].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.commandList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSPlayerInput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSPlayerInput");

  xfer += oprot->writeFieldBegin("commandList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->commandList.size()));
    std::vector< ::PlayerOperateCommand> ::const_iterator _iter81;
    for (_iter81 = this->commandList.begin(); _iter81 != this->commandList.end(); ++_iter81)
    {
      xfer += (*_iter81).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSPlayerInput &a, CSPlayerInput &b) {
  using ::std::swap;
  swap(a.commandList, b.commandList);
  swap(a.__isset, b.__isset);
}

CSPlayerInput::CSPlayerInput(const CSPlayerInput& other82) {
  commandList = other82.commandList;
  __isset = other82.__isset;
}
CSPlayerInput& CSPlayerInput::operator=(const CSPlayerInput& other83) {
  commandList = other83.commandList;
  __isset = other83.__isset;
  return *this;
}
void CSPlayerInput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSPlayerInput(";
  out << "commandList=" << to_string(commandList);
  out << ")";
}


SCPlayerInput::~SCPlayerInput() throw() {
}


void SCPlayerInput::__set_commandList(const std::vector< ::PlayerOperateCommand> & val) {
  this->commandList = val;
}

uint32_t SCPlayerInput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->commandList.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->commandList.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->commandList[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.commandList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCPlayerInput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCPlayerInput");

  xfer += oprot->writeFieldBegin("commandList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->commandList.size()));
    std::vector< ::PlayerOperateCommand> ::const_iterator _iter89;
    for (_iter89 = this->commandList.begin(); _iter89 != this->commandList.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCPlayerInput &a, SCPlayerInput &b) {
  using ::std::swap;
  swap(a.commandList, b.commandList);
  swap(a.__isset, b.__isset);
}

SCPlayerInput::SCPlayerInput(const SCPlayerInput& other90) {
  commandList = other90.commandList;
  __isset = other90.__isset;
}
SCPlayerInput& SCPlayerInput::operator=(const SCPlayerInput& other91) {
  commandList = other91.commandList;
  __isset = other91.__isset;
  return *this;
}
void SCPlayerInput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCPlayerInput(";
  out << "commandList=" << to_string(commandList);
  out << ")";
}


CSSyncCommandMsg::~CSSyncCommandMsg() throw() {
}


void CSSyncCommandMsg::__set_commandList(const std::vector< ::SyncData> & val) {
  this->commandList = val;
}

uint32_t CSSyncCommandMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->commandList.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->commandList.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->commandList[_i96].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.commandList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSSyncCommandMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSSyncCommandMsg");

  xfer += oprot->writeFieldBegin("commandList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->commandList.size()));
    std::vector< ::SyncData> ::const_iterator _iter97;
    for (_iter97 = this->commandList.begin(); _iter97 != this->commandList.end(); ++_iter97)
    {
      xfer += (*_iter97).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSSyncCommandMsg &a, CSSyncCommandMsg &b) {
  using ::std::swap;
  swap(a.commandList, b.commandList);
  swap(a.__isset, b.__isset);
}

CSSyncCommandMsg::CSSyncCommandMsg(const CSSyncCommandMsg& other98) {
  commandList = other98.commandList;
  __isset = other98.__isset;
}
CSSyncCommandMsg& CSSyncCommandMsg::operator=(const CSSyncCommandMsg& other99) {
  commandList = other99.commandList;
  __isset = other99.__isset;
  return *this;
}
void CSSyncCommandMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSSyncCommandMsg(";
  out << "commandList=" << to_string(commandList);
  out << ")";
}


SCSyncCommandMsg::~SCSyncCommandMsg() throw() {
}


void SCSyncCommandMsg::__set_time(const int32_t val) {
  this->time = val;
}

void SCSyncCommandMsg::__set_commandList(const std::vector< ::SyncData> & val) {
  this->commandList = val;
}

uint32_t SCSyncCommandMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->commandList.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->commandList.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += this->commandList[_i104].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.commandList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCSyncCommandMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCSyncCommandMsg");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("commandList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->commandList.size()));
    std::vector< ::SyncData> ::const_iterator _iter105;
    for (_iter105 = this->commandList.begin(); _iter105 != this->commandList.end(); ++_iter105)
    {
      xfer += (*_iter105).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCSyncCommandMsg &a, SCSyncCommandMsg &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.commandList, b.commandList);
  swap(a.__isset, b.__isset);
}

SCSyncCommandMsg::SCSyncCommandMsg(const SCSyncCommandMsg& other106) {
  time = other106.time;
  commandList = other106.commandList;
  __isset = other106.__isset;
}
SCSyncCommandMsg& SCSyncCommandMsg::operator=(const SCSyncCommandMsg& other107) {
  time = other107.time;
  commandList = other107.commandList;
  __isset = other107.__isset;
  return *this;
}
void SCSyncCommandMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCSyncCommandMsg(";
  out << "time=" << to_string(time);
  out << ", " << "commandList=" << to_string(commandList);
  out << ")";
}


SCInstantiate::~SCInstantiate() throw() {
}


void SCInstantiate::__set_objList(const std::vector< ::InstantiateData> & val) {
  this->objList = val;
}

uint32_t SCInstantiate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->objList.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _etype111;
            xfer += iprot->readListBegin(_etype111, _size108);
            this->objList.resize(_size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              xfer += this->objList[_i112].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.objList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCInstantiate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCInstantiate");

  xfer += oprot->writeFieldBegin("objList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->objList.size()));
    std::vector< ::InstantiateData> ::const_iterator _iter113;
    for (_iter113 = this->objList.begin(); _iter113 != this->objList.end(); ++_iter113)
    {
      xfer += (*_iter113).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCInstantiate &a, SCInstantiate &b) {
  using ::std::swap;
  swap(a.objList, b.objList);
  swap(a.__isset, b.__isset);
}

SCInstantiate::SCInstantiate(const SCInstantiate& other114) {
  objList = other114.objList;
  __isset = other114.__isset;
}
SCInstantiate& SCInstantiate::operator=(const SCInstantiate& other115) {
  objList = other115.objList;
  __isset = other115.__isset;
  return *this;
}
void SCInstantiate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCInstantiate(";
  out << "objList=" << to_string(objList);
  out << ")";
}


CSPing::~CSPing() throw() {
}


uint32_t CSPing::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSPing::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSPing");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSPing &a, CSPing &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSPing::CSPing(const CSPing& other116) {
  (void) other116;
}
CSPing& CSPing::operator=(const CSPing& other117) {
  (void) other117;
  return *this;
}
void CSPing::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSPing(";
  out << ")";
}


SCPing::~SCPing() throw() {
}


void SCPing::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCPing::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCPing::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCPing");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCPing &a, SCPing &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCPing::SCPing(const SCPing& other118) {
  result = other118.result;
  __isset = other118.__isset;
}
SCPing& SCPing::operator=(const SCPing& other119) {
  result = other119.result;
  __isset = other119.__isset;
  return *this;
}
void SCPing::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCPing(";
  out << "result=" << to_string(result);
  out << ")";
}


SCServerInfo::~SCServerInfo() throw() {
}


void SCServerInfo::__set_currentServerTime(const int64_t val) {
  this->currentServerTime = val;
}

uint32_t SCServerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->currentServerTime);
          this->__isset.currentServerTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCServerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCServerInfo");

  xfer += oprot->writeFieldBegin("currentServerTime", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->currentServerTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCServerInfo &a, SCServerInfo &b) {
  using ::std::swap;
  swap(a.currentServerTime, b.currentServerTime);
  swap(a.__isset, b.__isset);
}

SCServerInfo::SCServerInfo(const SCServerInfo& other120) {
  currentServerTime = other120.currentServerTime;
  __isset = other120.__isset;
}
SCServerInfo& SCServerInfo::operator=(const SCServerInfo& other121) {
  currentServerTime = other121.currentServerTime;
  __isset = other121.__isset;
  return *this;
}
void SCServerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCServerInfo(";
  out << "currentServerTime=" << to_string(currentServerTime);
  out << ")";
}


SCFactionMsg::~SCFactionMsg() throw() {
}


void SCFactionMsg::__set_shipId(const int32_t val) {
  this->shipId = val;
}

void SCFactionMsg::__set_regionId(const int32_t val) {
  this->regionId = val;
}

uint32_t SCFactionMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shipId);
          this->__isset.shipId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->regionId);
          this->__isset.regionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCFactionMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCFactionMsg");

  xfer += oprot->writeFieldBegin("shipId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->shipId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("regionId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->regionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCFactionMsg &a, SCFactionMsg &b) {
  using ::std::swap;
  swap(a.shipId, b.shipId);
  swap(a.regionId, b.regionId);
  swap(a.__isset, b.__isset);
}

SCFactionMsg::SCFactionMsg(const SCFactionMsg& other122) {
  shipId = other122.shipId;
  regionId = other122.regionId;
  __isset = other122.__isset;
}
SCFactionMsg& SCFactionMsg::operator=(const SCFactionMsg& other123) {
  shipId = other123.shipId;
  regionId = other123.regionId;
  __isset = other123.__isset;
  return *this;
}
void SCFactionMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCFactionMsg(";
  out << "shipId=" << to_string(shipId);
  out << ", " << "regionId=" << to_string(regionId);
  out << ")";
}


